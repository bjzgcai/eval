{
  "sha": "e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5",
  "node_id": "C_kwDOP2Zrm9oAKGU3ZDVlYTgzYjgyZTdmNWNmZmQ4ZTUyYjk1YjYwMTkwZTRjZWVjZDU",
  "commit": {
    "author": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-11-22T03:48:00Z"
    },
    "committer": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-11-22T03:48:00Z"
    },
    "message": "Refactor sessions for timezone-safe calendar",
    "tree": {
      "sha": "fb6afe5a45afda976345577a8289050d72e9ec1b",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/trees/fb6afe5a45afda976345577a8289050d72e9ec1b"
    },
    "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/commits/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null,
      "verified_at": null
    }
  },
  "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5",
  "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5",
  "comments_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "ad35b36acdb5957964dcb99b941a07ca20504917",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/ad35b36acdb5957964dcb99b941a07ca20504917",
      "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/ad35b36acdb5957964dcb99b941a07ca20504917"
    }
  ],
  "stats": {
    "total": 630,
    "additions": 510,
    "deletions": 120
  },
  "files": [
    {
      "sha": "48ce52aa6cf10f18c8e7c5660db7e6ec6a885b9d",
      "filename": "backend/database.py",
      "status": "modified",
      "additions": 16,
      "deletions": 5,
      "changes": 21,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/backend%2Fdatabase.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/backend%2Fdatabase.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fdatabase.py?ref=e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5",
      "patch": "@@ -13,6 +13,7 @@\n import os\n from pathlib import Path\n from datetime import datetime, timedelta\n+from typing import Optional, Union\n import json\n \n # Database location\n@@ -1024,18 +1025,28 @@ def get_user_by_id(user_id: int):\n \n # ========== Session Storage ==========\n \n-def save_session(user_id: int, session_id: str, editor_state: dict, name: str = None):\n+def _normalize_created_at(created_at: Optional[Union[str, datetime]]) -> Optional[str]:\n+    if created_at is None:\n+        return None\n+    if isinstance(created_at, datetime):\n+        return created_at.strftime(\"%Y-%m-%d %H:%M:%S\")\n+    return str(created_at)\n+\n+\n+def save_session(user_id: int, session_id: str, editor_state: dict, name: str = None,\n+                 created_at: Optional[Union[str, datetime]] = None):\n     \"\"\"Save or update a user session.\"\"\"\n     db = get_db()\n     try:\n+        created_at_value = _normalize_created_at(created_at)\n         db.execute(\"\"\"\n-        INSERT INTO user_sessions (id, user_id, name, editor_state_json, updated_at)\n-        VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)\n+        INSERT INTO user_sessions (id, user_id, name, editor_state_json, created_at, updated_at)\n+        VALUES (?, ?, ?, ?, COALESCE(?, CURRENT_TIMESTAMP), CURRENT_TIMESTAMP)\n         ON CONFLICT(id) DO UPDATE SET\n           editor_state_json = excluded.editor_state_json,\n-          name = COALESCE(excluded.name, name),\n+          name = COALESCE(excluded.name, user_sessions.name),\n           updated_at = CURRENT_TIMESTAMP\n-        \"\"\", (session_id, user_id, name, json.dumps(editor_state)))\n+        \"\"\", (session_id, user_id, name, json.dumps(editor_state), created_at_value))\n         db.commit()\n     finally:\n         db.close()"
    },
    {
      "sha": "000a38039eb04b87e6cecb9a80cdb0b6649f4348",
      "filename": "backend/tools/session_inserter.py",
      "status": "added",
      "additions": 93,
      "deletions": 0,
      "changes": 93,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/backend%2Ftools%2Fsession_inserter.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/backend%2Ftools%2Fsession_inserter.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Ftools%2Fsession_inserter.py?ref=e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5",
      "patch": "@@ -0,0 +1,93 @@\n+#!/usr/bin/env python3\n+\"\"\"\n+Create synthetic sessions for a specific user/day.\n+\n+Useful for timezone sanity checks and regression testing.\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import argparse\n+import uuid\n+from datetime import datetime, timezone\n+from zoneinfo import ZoneInfo\n+\n+import database\n+\n+\n+def parse_args() -> argparse.Namespace:\n+    parser = argparse.ArgumentParser(description=\"Insert a session for a specific user/day.\")\n+    parser.add_argument(\"--email\", help=\"User email (alternative to --user-id)\")\n+    parser.add_argument(\"--user-id\", type=int, help=\"User ID (alternative to --email)\")\n+    parser.add_argument(\"--date\", required=True, help=\"Local date in YYYY-MM-DD\")\n+    parser.add_argument(\"--time\", default=\"09:00\", help=\"Local time in HH:MM (default 09:00)\")\n+    parser.add_argument(\"--timezone\", default=\"UTC\", help=\"IANA timezone name (default UTC)\")\n+    parser.add_argument(\"--title\", help=\"Optional session title\")\n+    parser.add_argument(\"--text\", default=\"\", help=\"Optional text content for the first text cell\")\n+    parser.add_argument(\"--session-id\", help=\"Optional explicit session id (default random UUID)\")\n+    return parser.parse_args()\n+\n+\n+def resolve_user_id(email: str | None, user_id: int | None) -> int:\n+    if user_id:\n+        user = database.get_user_by_id(user_id)\n+        if not user:\n+            raise SystemExit(f\"User ID {user_id} not found\")\n+        return user[\"id\"]\n+\n+    if email:\n+        user = database.get_user_by_email(email)\n+        if not user:\n+            raise SystemExit(f\"User with email {email} not found\")\n+        return user[\"id\"]\n+\n+    raise SystemExit(\"Either --email or --user-id is required.\")\n+\n+\n+def local_timestamp(date: str, time_str: str, tz_name: str) -> tuple[str, str]:\n+    tz = ZoneInfo(tz_name)\n+    local_dt = datetime.strptime(f\"{date} {time_str}\", \"%Y-%m-%d %H:%M\").replace(tzinfo=tz)\n+    utc_dt = local_dt.astimezone(timezone.utc)\n+    created_at_db = utc_dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n+    created_at_state = utc_dt.isoformat().replace(\"+00:00\", \"Z\")\n+    return created_at_db, created_at_state\n+\n+\n+def build_editor_state(session_id: str, text: str, created_at_iso: str) -> dict:\n+    text_cell_id = uuid.uuid4().hex[:12]\n+    return {\n+        \"cells\": [\n+            {\"id\": text_cell_id, \"type\": \"text\", \"content\": text}\n+        ],\n+        \"commentors\": [],\n+        \"tasks\": [],\n+        \"weightPath\": [],\n+        \"overlappedPhrases\": [],\n+        \"sessionId\": session_id,\n+        \"currentEntryId\": session_id,\n+        \"selectedState\": None,\n+        \"createdAt\": created_at_iso\n+    }\n+\n+\n+def main() -> None:\n+    args = parse_args()\n+    user_id = resolve_user_id(args.email, args.user_id)\n+    created_at_db, created_at_state = local_timestamp(args.date, args.time, args.timezone)\n+    session_id = args.session_id or str(uuid.uuid4())\n+    text_content = args.text.strip()\n+    title = args.title or (text_content.splitlines()[0][:60] if text_content else f\"Session {args.date}\")\n+\n+    editor_state = build_editor_state(session_id, text_content, created_at_state)\n+    database.save_session(\n+        user_id,\n+        session_id,\n+        editor_state,\n+        name=title,\n+        created_at=created_at_db,\n+    )\n+    print(f\"âœ… Inserted session {session_id} for user {user_id} at {created_at_db} UTC.\")\n+\n+\n+if __name__ == \"__main__\":\n+    main()"
    },
    {
      "sha": "d94bcc79a1c019f6b3684054bbd293f173567617",
      "filename": "backend/tools/session_inspector.py",
      "status": "added",
      "additions": 118,
      "deletions": 0,
      "changes": 118,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/backend%2Ftools%2Fsession_inspector.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/backend%2Ftools%2Fsession_inspector.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Ftools%2Fsession_inspector.py?ref=e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5",
      "patch": "@@ -0,0 +1,118 @@\n+#!/usr/bin/env python3\n+\"\"\"\n+Inspect and rebuild sessions for a specific user/day.\n+\n+This utility lists every session that lands within the requested local day,\n+prints their metadata, deletes each row, and recreates it using the same\n+`database.save_session()` helper so we can verify our understanding of the schema.\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import argparse\n+import json\n+from datetime import datetime, timedelta, timezone\n+from zoneinfo import ZoneInfo\n+\n+import database\n+\n+\n+def parse_args() -> argparse.Namespace:\n+    parser = argparse.ArgumentParser(description=\"Inspect and rebuild sessions for a given day.\")\n+    parser.add_argument(\"--email\", help=\"User email (alternative to --user-id)\")\n+    parser.add_argument(\"--user-id\", type=int, help=\"User ID (alternative to --email)\")\n+    parser.add_argument(\"--date\", required=True, help=\"Local date in YYYY-MM-DD\")\n+    parser.add_argument(\"--timezone\", default=\"UTC\", help=\"IANA timezone name (default: UTC)\")\n+    return parser.parse_args()\n+\n+\n+def resolve_user_id(email: str | None, user_id: int | None) -> int:\n+    if user_id:\n+        user = database.get_user_by_id(user_id)\n+        if not user:\n+            raise SystemExit(f\"User ID {user_id} not found\")\n+        return user[\"id\"]\n+\n+    if email:\n+        user = database.get_user_by_email(email)\n+        if not user:\n+            raise SystemExit(f\"User with email {email} not found\")\n+        return user[\"id\"]\n+\n+    raise SystemExit(\"Either --email or --user-id is required.\")\n+\n+\n+def local_day_bounds(day: str, tz_name: str) -> tuple[str, str]:\n+    tz = ZoneInfo(tz_name)\n+    local_start = datetime.strptime(day, \"%Y-%m-%d\").replace(tzinfo=tz)\n+    local_end = local_start + timedelta(days=1)\n+    utc_start = local_start.astimezone(timezone.utc)\n+    utc_end = local_end.astimezone(timezone.utc)\n+    return (\n+        utc_start.strftime(\"%Y-%m-%d %H:%M:%S\"),\n+        utc_end.strftime(\"%Y-%m-%d %H:%M:%S\"),\n+    )\n+\n+\n+def fetch_sessions(user_id: int, utc_start: str, utc_end: str) -> list[dict]:\n+    db = database.get_db()\n+    try:\n+        rows = db.execute(\n+            \"\"\"\n+            SELECT id, name, editor_state_json, created_at, updated_at\n+            FROM user_sessions\n+            WHERE user_id = ?\n+              AND created_at >= ?\n+              AND created_at < ?\n+            ORDER BY created_at ASC\n+            \"\"\",\n+            (user_id, utc_start, utc_end),\n+        ).fetchall()\n+        return [dict(row) for row in rows]\n+    finally:\n+        db.close()\n+\n+\n+def rebuild_sessions(user_id: int, sessions: list[dict]) -> None:\n+    if not sessions:\n+        print(\"âš ï¸  No sessions found for the requested window.\")\n+        return\n+\n+    for session in sessions:\n+        session_id = session[\"id\"]\n+        created_at = session[\"created_at\"]\n+        updated_at = session[\"updated_at\"]\n+        name = session.get(\"name\")\n+        editor_state = json.loads(session[\"editor_state_json\"])\n+        first_line = editor_state.get(\"cells\", [{}])[0].get(\"content\", \"\").split(\"\\n\")[0]\n+\n+        print(\"------------------------------------------------------------\")\n+        print(f\"ðŸ—‚  Session ID:   {session_id}\")\n+        print(f\"ðŸ“…  Created At:   {created_at}\")\n+        print(f\"ðŸ•’  Updated At:   {updated_at}\")\n+        print(f\"ðŸ·ï¸   Name:         {name or '(none)'}\")\n+        print(f\"ðŸ“  First Line:   {first_line or '(empty)'}\")\n+        print(\"ðŸ” Rebuilding row through database.save_session()...\")\n+\n+        database.delete_session(user_id, session_id)\n+        database.save_session(\n+            user_id,\n+            session_id,\n+            editor_state,\n+            name=name,\n+            created_at=created_at,\n+        )\n+        print(\"âœ… Recreated successfully.\")\n+\n+\n+def main() -> None:\n+    args = parse_args()\n+    user_id = resolve_user_id(args.email, args.user_id)\n+    utc_start, utc_end = local_day_bounds(args.date, args.timezone)\n+    sessions = fetch_sessions(user_id, utc_start, utc_end)\n+    print(f\"Found {len(sessions)} session(s) for user {user_id} between {utc_start} and {utc_end} UTC.\")\n+    rebuild_sessions(user_id, sessions)\n+\n+\n+if __name__ == \"__main__\":\n+    main()"
    },
    {
      "sha": "a0e2007f492d690fec942d4767b97814b8ff8a30",
      "filename": "frontend/src/App.tsx",
      "status": "modified",
      "additions": 138,
      "deletions": 23,
      "changes": 161,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/frontend%2Fsrc%2FApp.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/frontend%2Fsrc%2FApp.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2FApp.tsx?ref=e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5",
      "patch": "@@ -32,6 +32,14 @@ import { useAuth } from './contexts/AuthContext';\n import LoginForm from './components/Auth/LoginForm';\n import RegisterForm from './components/Auth/RegisterForm';\n import { STORAGE_KEYS } from './constants/storageKeys';\n+import { getLocalDayKey, getTodayKeyInTimezone } from './utils/timezone';\n+\n+function createSessionId() {\n+  if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {\n+    return crypto.randomUUID();\n+  }\n+  return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n+}\n \n // @@@ Left Toolbar Component - floating toolbelt within left margin\n function LeftToolbar({\n@@ -307,20 +315,26 @@ export default function App() {\n     }\n   }, []);\n   const timezoneSyncRef = useRef<string | null>(null);\n+  const [userTimezone, setUserTimezone] = useState(browserTimezone);\n+  const ensuredSessionForDayRef = useRef<string | null>(null);\n+  const userTimezoneRef = useRef(userTimezone);\n+\n+  useEffect(() => {\n+    userTimezoneRef.current = userTimezone;\n+  }, [userTimezone]);\n \n   const ensureStateForPersistence = useCallback((): EditorState | null => {\n     if (engineRef.current) {\n       const engineState = engineRef.current.getState();\n       if (!engineState.createdAt) {\n-        engineState.createdAt = new Date().toISOString().split('T')[0];\n+        engineState.createdAt = new Date().toISOString();\n         setState({ ...engineState });\n       }\n       return engineState;\n     }\n \n     if (state && !state.createdAt) {\n-      const today = new Date().toISOString().split('T')[0];\n-      const nextState = { ...state, createdAt: today };\n+      const nextState = { ...state, createdAt: new Date().toISOString() };\n       setState(nextState);\n       return nextState;\n     }\n@@ -344,6 +358,16 @@ export default function App() {\n     return sessionId;\n   }, [getFirstLineFromState]);\n \n+  const persistSessionImmediately = useCallback(async (editorState: EditorState) => {\n+    if (!isAuthenticated) return;\n+    try {\n+      const firstLine = getFirstLineFromState(editorState);\n+      await saveSessionToDatabase(editorState, firstLine);\n+    } catch (error) {\n+      console.error('Failed to persist session immediately:', error);\n+    }\n+  }, [getFirstLineFromState, isAuthenticated, saveSessionToDatabase]);\n+\n   // @@@ Detect if this is a new inspiration appearing (different from previous)\n   // Only check appearing when NOT disappearing (to avoid conflict)\n   const inspirationAppearing = !inspirationDisappearing &&\n@@ -388,6 +412,7 @@ export default function App() {\n     }\n   }, [selectedState]);\n \n+\n   // @@@ Handle inspiration disappearing animation\n   useEffect(() => {\n     if (inspirationDisappearing) {\n@@ -508,9 +533,15 @@ export default function App() {\n   }, [isAuthenticated, isLoading]);\n \n   useEffect(() => {\n-    if (!isAuthenticated) return;\n     const timezone = browserTimezone || 'UTC';\n     if (!timezone) return;\n+\n+    if (!isAuthenticated) {\n+      setUserTimezone(timezone);\n+      timezoneSyncRef.current = timezone;\n+      return;\n+    }\n+\n     if (timezoneSyncRef.current === timezone) return;\n \n     const syncTimezone = async () => {\n@@ -519,6 +550,9 @@ export default function App() {\n         const prefs = await getPreferences();\n         if ((prefs?.timezone || 'UTC') !== timezone) {\n           await savePreferences({ timezone });\n+          setUserTimezone(timezone);\n+        } else {\n+          setUserTimezone(prefs?.timezone || timezone);\n         }\n       } catch (error) {\n         console.error('Failed to sync timezone preference:', error);\n@@ -539,7 +573,7 @@ export default function App() {\n     // @@@ Initialize createdAt for new session\n     const initialState = engine.getState();\n     if (!initialState.createdAt) {\n-      initialState.createdAt = new Date().toISOString().split('T')[0]; // YYYY-MM-DD\n+      initialState.createdAt = new Date().toISOString();\n       setState(initialState);\n     }\n \n@@ -550,6 +584,11 @@ export default function App() {\n         localStorage.setItem(STORAGE_KEYS.EDITOR_STATE, JSON.stringify(newState));\n       }\n     });\n+    const unsubscribeBlankReset = engine.onBlankReset(async () => {\n+      if (!isAuthenticated) return;\n+      const blankState = engine.getState();\n+      await persistSessionImmediately(blankState);\n+    });\n \n     // Load initial state\n     const loadInitialState = async () => {\n@@ -579,8 +618,9 @@ export default function App() {\n             )[0];\n \n             // @@@ Daily reset check - same logic as StateChooser\n-            const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD\n-            const sessionDate = mostRecent.updated_at.split(' ')[0]; // Extract date from \"YYYY-MM-DD HH:MM:SS\"\n+            const timezoneForDay = userTimezoneRef.current || 'UTC';\n+            const today = getTodayKeyInTimezone(timezoneForDay);\n+            const sessionDate = getLocalDayKey(mostRecent.updated_at, timezoneForDay);\n \n             if (sessionDate === today) {\n               // Same day - load the session\n@@ -623,13 +663,17 @@ export default function App() {\n             if (prefs.state_config) {\n               setStateConfig(prefs.state_config);\n             }\n+            if (prefs.timezone) {\n+              setUserTimezone(prefs.timezone);\n+            }\n \n             // @@@ Load selectedState with daily reset check for authenticated users\n             if (prefs.selected_state !== undefined && prefs.selected_state !== null) {\n-              const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD\n-\n-              // Extract date from database's updated_at timestamp (format: \"YYYY-MM-DD HH:MM:SS\")\n-              const updatedAtDate = prefs.updated_at ? prefs.updated_at.split(' ')[0] : null;\n+              const timezoneForDay = userTimezoneRef.current || 'UTC';\n+              const today = getTodayKeyInTimezone(timezoneForDay);\n+              const updatedAtDate = prefs.updated_at\n+                ? getLocalDayKey(prefs.updated_at, timezoneForDay)\n+                : null;\n \n               // Check if state was updated today\n               if (updatedAtDate === today) {\n@@ -672,7 +716,7 @@ export default function App() {\n         // @@@ Load selectedState with daily reset check\n         const savedState = localStorage.getItem(STORAGE_KEYS.SELECTED_STATE);\n         const savedDate = localStorage.getItem('selected-state-date');\n-        const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD\n+        const today = getTodayKeyInTimezone(userTimezoneRef.current || browserTimezone);\n \n         // Reset state if it's a new day\n         if (savedState && savedDate === today) {\n@@ -684,10 +728,17 @@ export default function App() {\n           setSelectedState(null);\n         }\n       }\n+      if (!isAuthenticated) {\n+        setUserTimezone(browserTimezone);\n+      }\n     };\n \n     loadInitialState();\n-  }, [isAuthenticated]);\n+\n+    return () => {\n+      unsubscribeBlankReset();\n+    };\n+  }, [isAuthenticated, persistSessionImmediately]);\n \n   // @@@ Sync localTexts from state when not composing\n   useEffect(() => {\n@@ -1114,6 +1165,57 @@ export default function App() {\n     setShowWarning(true);\n   }, []);\n \n+  const buildBlankState = useCallback((): EditorState | null => {\n+    const preservedSelectedState = engineRef.current?.getState().selectedState ?? selectedState ?? null;\n+    const newSessionId = createSessionId();\n+    return {\n+      cells: [{ id: Math.random().toString(36).slice(2), type: 'text' as const, content: '' }],\n+      commentors: [],\n+      tasks: [],\n+      weightPath: [],\n+      overlappedPhrases: [],\n+      sessionId: newSessionId,\n+      currentEntryId: newSessionId,\n+      selectedState: preservedSelectedState,\n+      createdAt: new Date().toISOString()\n+    };\n+  }, [selectedState]);\n+\n+  const startDetachedBlankSession = useCallback((persistImmediately: boolean = false) => {\n+    if (!engineRef.current) return;\n+    const blankState = buildBlankState();\n+    if (!blankState) return;\n+\n+    engineRef.current.loadState(blankState);\n+    setState(blankState);\n+    setLocalTexts(new Map());\n+\n+    if (!isAuthenticated) {\n+      localStorage.setItem(STORAGE_KEYS.EDITOR_STATE, JSON.stringify(blankState));\n+    } else if (persistImmediately) {\n+      persistSessionImmediately(blankState);\n+    }\n+  }, [buildBlankState, isAuthenticated, persistSessionImmediately]);\n+\n+  useEffect(() => {\n+    if (!isAuthenticated) return;\n+    if (!engineRef.current) return;\n+    if (selectedState !== null) return;\n+    const todayKey = getTodayKeyInTimezone(userTimezone);\n+    if (!todayKey) return;\n+\n+    const currentState = engineRef.current.getState();\n+    const currentKey = currentState.createdAt\n+      ? getLocalDayKey(currentState.createdAt, userTimezone)\n+      : null;\n+\n+    if (currentKey === todayKey) return;\n+    if (ensuredSessionForDayRef.current === todayKey) return;\n+\n+    ensuredSessionForDayRef.current = todayKey;\n+    startDetachedBlankSession(true);\n+  }, [isAuthenticated, selectedState, startDetachedBlankSession, userTimezone]);\n+\n   // @@@ New session: save current, then create fresh (no data loss, no warning)\n   const handleNewSession = useCallback(async () => {\n     if (!state || !engineRef.current) return;\n@@ -1150,15 +1252,16 @@ export default function App() {\n     }\n \n     // @@@ Create empty state with NEW sessionId\n-    const newSessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n+    const newSessionId = createSessionId();\n     const emptyState: EditorState = {\n       cells: [{ id: Math.random().toString(36).slice(2), type: 'text' as const, content: '' }],\n       commentors: [],\n       tasks: [],\n       weightPath: [],\n       overlappedPhrases: [],\n       sessionId: newSessionId,\n-      currentEntryId: newSessionId\n+      currentEntryId: newSessionId,\n+      createdAt: new Date().toISOString()\n     };\n \n     // @@@ Load empty state directly into engine (immediate UI update)\n@@ -1182,15 +1285,16 @@ export default function App() {\n     if (!engineRef.current) return;\n \n     // @@@ Create empty state with NEW sessionId\n-    const newSessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n+    const newSessionId = createSessionId();\n     const emptyState: EditorState = {\n       cells: [{ id: Math.random().toString(36).slice(2), type: 'text' as const, content: '' }],\n       commentors: [],\n       tasks: [],\n       weightPath: [],\n       overlappedPhrases: [],\n       sessionId: newSessionId,\n-      currentEntryId: newSessionId  // @@@ Set currentEntryId to maintain invariant I5\n+      currentEntryId: newSessionId,  // @@@ Set currentEntryId to maintain invariant I5\n+      createdAt: new Date().toISOString()\n     };\n \n     // @@@ Load empty state directly into engine (immediate UI update)\n@@ -1292,7 +1396,7 @@ export default function App() {\n       }\n \n       if (!loadedState.createdAt) {\n-        loadedState.createdAt = new Date().toISOString().split('T')[0];\n+        loadedState.createdAt = new Date().toISOString();\n         engineRef.current.loadState(loadedState);\n       }\n \n@@ -1312,17 +1416,25 @@ export default function App() {\n     setTimelineFriendToSelect(null);\n   }, []);\n \n+  const handleCalendarEntryDeleted = useCallback((entryId: string) => {\n+    if (!entryId || !engineRef.current) return;\n+    const currentId = engineRef.current.getState().currentEntryId;\n+    if (currentId === entryId) {\n+      startDetachedBlankSession();\n+    }\n+  }, [startDetachedBlankSession]);\n+\n   const handleStateChoose = useCallback(async (stateId: string) => {\n     setSelectedState(stateId);\n-    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD\n+    const todayKey = getTodayKeyInTimezone(userTimezone);\n \n     // @@@ NEW: Save to EditorState (per-session storage)\n     if (engineRef.current) {\n       const currentState = engineRef.current.getState();\n       currentState.selectedState = stateId;\n       // Set createdAt only if not already set\n       if (!currentState.createdAt) {\n-        currentState.createdAt = today;\n+        currentState.createdAt = new Date().toISOString();\n       }\n       setState(currentState);\n     }\n@@ -1338,9 +1450,9 @@ export default function App() {\n       }\n     } else {\n       localStorage.setItem(STORAGE_KEYS.SELECTED_STATE, stateId);\n-      localStorage.setItem('selected-state-date', today);\n+      localStorage.setItem('selected-state-date', todayKey);\n     }\n-  }, [isAuthenticated]);\n+  }, [isAuthenticated, userTimezone]);\n \n   // @@@ Insert @ character at the end of last text cell\n   const handleInsertAgent = useCallback(() => {\n@@ -2517,6 +2629,7 @@ export default function App() {\n           voiceConfigs={voiceConfigs}\n           friendToSelect={timelineFriendToSelect}\n           onFriendSelectionHandled={handleFriendSelectionHandled}\n+          timezone={userTimezone}\n         />\n       </div>\n       {currentView === 'analysis' && (\n@@ -2650,8 +2763,10 @@ export default function App() {\n       {showCalendarPopup && (\n         <CalendarPopup\n           onLoadEntry={handleLoadEntry}\n-          currentEntryId={state.currentEntryId}\n+          currentEntryId={state?.currentEntryId}\n+          onEntryDeleted={handleCalendarEntryDeleted}\n           onClose={() => setShowCalendarPopup(false)}\n+          timezone={userTimezone}\n         />\n       )}\n     </>"
    },
    {
      "sha": "53ba2983fc737a64744186a580c7ff05c222058a",
      "filename": "frontend/src/components/AnalysisView.tsx",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/frontend%2Fsrc%2Fcomponents%2FAnalysisView.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/frontend%2Fsrc%2Fcomponents%2FAnalysisView.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FAnalysisView.tsx?ref=e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5",
      "patch": "@@ -501,7 +501,7 @@ export default function AnalysisView() {\n               gap: '1.5rem',\n               marginBottom: '2rem'\n             }}>\n-              {savedReports.map((report, idx) => (\n+              {savedReports.slice(0, 3).map((report, idx) => (\n                 <div\n                   key={report.id}\n                   onClick={() => {"
    },
    {
      "sha": "cb0f8eb62d7962f9f750866acf6b0cb10d8c3f58",
      "filename": "frontend/src/components/CalendarPopup.tsx",
      "status": "modified",
      "additions": 27,
      "deletions": 51,
      "changes": 78,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/frontend%2Fsrc%2Fcomponents%2FCalendarPopup.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/frontend%2Fsrc%2Fcomponents%2FCalendarPopup.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FCalendarPopup.tsx?ref=e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5",
      "patch": "@@ -1,4 +1,4 @@\n-import { useState, useEffect } from 'react';\n+import { useState, useEffect, useCallback } from 'react';\n import { useTranslation } from 'react-i18next';\n import { getDateLocale } from '../i18n';\n import {\n@@ -15,38 +15,40 @@ interface Props {\n   onLoadEntry: (entry: CalendarEntry) => void;\n   onClose: () => void;\n   currentEntryId?: string | null;\n+  onEntryDeleted?: (entryId: string) => void;\n+  timezone: string;\n }\n \n-export default function CalendarPopup({ onLoadEntry, onClose, currentEntryId }: Props) {\n+export default function CalendarPopup({ onLoadEntry, onClose, currentEntryId, onEntryDeleted, timezone }: Props) {\n   const { isAuthenticated } = useAuth();\n   const { t, i18n } = useTranslation();\n   const dateLocale = getDateLocale(i18n.language);\n   const [currentMonth, setCurrentMonth] = useState(new Date());\n   const [selectedDate, setSelectedDate] = useState<string | null>(getTodayKey());\n   const [calendarData, setCalendarData] = useState<Record<string, CalendarEntry[]>>({});\n \n-  // @@@ Load calendar data from database if authenticated, localStorage if guest\n-  useEffect(() => {\n-    const loadData = async () => {\n-      if (isAuthenticated) {\n-        try {\n-          // Load from database - sessions imported during migration\n-          const { listSessions, getSession } = await import('../api/voiceApi');\n-          const grouped = await loadSessionsGroupedByDate(listSessions, getSession, { requireName: true });\n-          setCalendarData(grouped);\n-        } catch (error) {\n-          console.error('Failed to load calendar from database:', error);\n-          // Fallback to localStorage\n-          setCalendarData(getCalendarData());\n-        }\n-      } else {\n-        // Guest mode: load from localStorage\n-        setCalendarData(getCalendarData());\n+  // @@@ Shared loader for calendar data (DB or localStorage)\n+  const refreshCalendarData = useCallback(async () => {\n+    if (isAuthenticated) {\n+      try {\n+        const { listSessions, getSession } = await import('../api/voiceApi');\n+        const grouped = await loadSessionsGroupedByDate(listSessions, getSession, {\n+          requireName: true,\n+          timezone\n+        });\n+        setCalendarData(grouped);\n+        return;\n+      } catch (error) {\n+        console.error('Failed to load calendar from database:', error);\n       }\n-    };\n+    }\n+    setCalendarData(getCalendarData());\n+  }, [isAuthenticated, timezone]);\n \n-    loadData();\n-  }, [isAuthenticated]);\n+  // @@@ Initial load\n+  useEffect(() => {\n+    refreshCalendarData();\n+  }, [refreshCalendarData]);\n \n   const today = getTodayKey();\n   const datesWithEntries = Object.keys(calendarData);\n@@ -100,35 +102,8 @@ export default function CalendarPopup({ onLoadEntry, onClose, currentEntryId }:\n           const { deleteSession } = await import('../api/voiceApi');\n           await deleteSession(entryId);\n \n-          // Reload calendar data\n-          const { listSessions, getSession } = await import('../api/voiceApi');\n-          const sessions = await listSessions();\n-          const grouped: Record<string, CalendarEntry[]> = {};\n-\n-          for (const session of sessions) {\n-            // @@@ Skip unnamed sessions (same check as initial load)\n-            if (!session.name) continue;\n-\n-            const fullSession = await getSession(session.id);\n-            // @@@ Extract date from created_at timestamp (format: \"2025-11-02 10:42:17\")\n-            let dateKey = session.created_at?.substring(0, 10) || getTodayKey();\n-\n-            // Legacy: if name starts with YYYY-MM-DD format, use that\n-            if (session.name && /^\\d{4}-\\d{2}-\\d{2}/.test(session.name)) {\n-              dateKey = session.name.split(' - ')[0];\n-            }\n-\n-            if (!grouped[dateKey]) {\n-              grouped[dateKey] = [];\n-            }\n-            grouped[dateKey].push({\n-              id: session.id,\n-              timestamp: new Date(session.created_at || Date.now()).getTime(),\n-              state: fullSession.editor_state,\n-              firstLine: session.name\n-            });\n-          }\n-          setCalendarData(grouped);\n+          await refreshCalendarData();\n+          onEntryDeleted?.(entryId);\n         } catch (error) {\n           console.error('Failed to delete from database:', error);\n           alert(t('calendar.deleteError'));\n@@ -137,6 +112,7 @@ export default function CalendarPopup({ onLoadEntry, onClose, currentEntryId }:\n         // Guest mode: delete from localStorage\n         deleteEntry(dateKey, entryId);\n         setCalendarData(getCalendarData());\n+        onEntryDeleted?.(entryId);\n       }\n     }\n   };"
    },
    {
      "sha": "8e81d7bae2479c9d1566d3fb7df7bf7fd61568f7",
      "filename": "frontend/src/components/CollectionsView.tsx",
      "status": "modified",
      "additions": 10,
      "deletions": 4,
      "changes": 14,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx?ref=e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5",
      "patch": "@@ -35,9 +35,10 @@ interface CollectionsViewProps {\n   voiceConfigs: Record<string, any>;\n   friendToSelect?: number | null;\n   onFriendSelectionHandled?: () => void;\n+  timezone: string;\n }\n \n-export default function CollectionsView({ isVisible, voiceConfigs, friendToSelect, onFriendSelectionHandled }: CollectionsViewProps) {\n+export default function CollectionsView({ isVisible, voiceConfigs, friendToSelect, onFriendSelectionHandled, timezone }: CollectionsViewProps) {\n   const { i18n } = useTranslation();\n   const dateLocale = getDateLocale(i18n.language);\n   return (\n@@ -55,6 +56,7 @@ export default function CollectionsView({ isVisible, voiceConfigs, friendToSelec\n         dateLocale={dateLocale}\n         friendToSelect={friendToSelect}\n         onFriendSelectionHandled={onFriendSelectionHandled}\n+        timezone={timezone}\n       />\n     </div>\n   );\n@@ -455,9 +457,10 @@ interface TimelinePageProps {\n   dateLocale: string;\n   friendToSelect?: number | null;\n   onFriendSelectionHandled?: () => void;\n+  timezone: string;\n }\n \n-function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onFriendSelectionHandled }: TimelinePageProps) {\n+function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onFriendSelectionHandled, timezone }: TimelinePageProps) {\n   const { t } = useTranslation();\n   const { isAuthenticated } = useAuth();\n   const [starredComments, setStarredComments] = useState<Commentor[]>([]);\n@@ -584,7 +587,10 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n       if (isAuthenticated) {\n         try {\n           const { listSessions, getSession } = await import('../api/voiceApi');\n-          const groupedEntries = await loadSessionsGroupedByDate(listSessions, getSession, { requireName: true });\n+          const groupedEntries = await loadSessionsGroupedByDate(listSessions, getSession, {\n+            requireName: true,\n+            timezone\n+          });\n \n           const allStarred: Commentor[] = [];\n           const commentsByDate = new Map<string, Commentor[]>();\n@@ -773,7 +779,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n \n     loadTimelineData();\n     loadFriendsList();\n-  }, [isAuthenticated]);\n+  }, [isAuthenticated, timezone, dateLocale]);\n \n   // @@@ Group items by date (using YYYY-MM-DD format to match timeline days)\n   const timelineByDate = new Map<string, TimelineEntryData>();"
    },
    {
      "sha": "0981394355c24aafbebf29c87171a865daa32752",
      "filename": "frontend/src/components/StateChooser.tsx",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/frontend%2Fsrc%2Fcomponents%2FStateChooser.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/frontend%2Fsrc%2Fcomponents%2FStateChooser.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FStateChooser.tsx?ref=e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5",
      "patch": "@@ -3,11 +3,12 @@ import { useTranslation } from 'react-i18next';\n import { StateCube } from './StateCube';\n import type { StateConfig } from '../api/voiceApi';\n import { getDateLocale } from '../i18n';\n+import { parseFlexibleTimestamp } from '../utils/timezone';\n \n interface Props {\n   stateConfig: StateConfig;\n   selectedState: string | null;\n-  createdAt?: string;  // @@@ Optional creation date (YYYY-MM-DD)\n+  createdAt?: string;  // ISO timestamp recorded when the session was created\n   onChoose: (stateId: string) => void;\n }\n \n@@ -31,9 +32,8 @@ export default function StateChooser({ stateConfig, selectedState, createdAt, on\n   const selectedStateData = selectedState ? stateConfig.states[selectedState] : null;\n \n   // @@@ Use createdAt if provided, otherwise use today\n-  const displayDate = createdAt\n-    ? new Date(createdAt + 'T00:00:00')\n-    : new Date();\n+  const timestamp = createdAt ? parseFlexibleTimestamp(createdAt) : null;\n+  const displayDate = timestamp ?? new Date();\n \n   const dateLocale = getDateLocale(i18n.language);\n   const dateString = displayDate.toLocaleDateString(dateLocale, {"
    },
    {
      "sha": "0943506b4a193e130a4129ca417f241859a73893",
      "filename": "frontend/src/engine/EditorEngine.ts",
      "status": "modified",
      "additions": 23,
      "deletions": 5,
      "changes": 28,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/frontend%2Fsrc%2Fengine%2FEditorEngine.ts",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/frontend%2Fsrc%2Fengine%2FEditorEngine.ts",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fengine%2FEditorEngine.ts?ref=e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5",
      "patch": "@@ -16,7 +16,7 @@ export interface EditorState {\n   sessionId: string;\n   currentEntryId?: string;  // Track which calendar entry is being edited (for overwrite on save)\n   selectedState?: string | null;  // @@@ Emotional state for this session (stored per-session)\n-  createdAt?: string;  // @@@ ISO date when session was created (YYYY-MM-DD)\n+  createdAt?: string;  // @@@ ISO timestamp when session was created\n }\n \n export type Cell = TextCell | WidgetCell;\n@@ -123,6 +123,7 @@ export class EditorEngine {\n   private sentCache: Map<string, string> = new Map(); // Track sent sentences -> commentor hash\n   private onStateChange?: (state: EditorState) => void;\n   private isRequesting: boolean = false; // Track if request in progress\n+  private blankResetSubscribers: Set<() => void> = new Set();\n \n   constructor(sessionId: string) {\n     this.state = {\n@@ -136,6 +137,21 @@ export class EditorEngine {\n     };\n   }\n \n+  onBlankReset(callback: () => void) {\n+    this.blankResetSubscribers.add(callback);\n+    return () => this.blankResetSubscribers.delete(callback);\n+  }\n+\n+  private notifyBlankReset() {\n+    this.blankResetSubscribers.forEach(cb => {\n+      try {\n+        cb();\n+      } catch (error) {\n+        console.error('Blank reset subscriber failed', error);\n+      }\n+    });\n+  }\n+\n   // @@@ Update voice configurations from settings\n   // No-op: Backend now loads voice configs from database, not from frontend\n   setVoiceConfigs(_configs: Record<string, any>) {\n@@ -216,9 +232,10 @@ export class EditorEngine {\n     return combinedText.trim().length === 0;\n   }\n \n-  // @@@ Restore editor to pristine state while preserving session metadata\n+  // @@@ Restore editor to pristine state while starting a fresh session\n   private resetEditorToBlank() {\n-    const { sessionId, currentEntryId, selectedState, createdAt } = this.state;\n+    const { selectedState, sessionId, currentEntryId, createdAt } = this.state;\n+    const preservedTimestamp = createdAt ?? new Date().toISOString();\n \n     this.state = {\n       cells: [{ id: generateId(), type: 'text', content: '' }],\n@@ -227,9 +244,9 @@ export class EditorEngine {\n       weightPath: [],\n       overlappedPhrases: [],\n       sessionId,\n-      currentEntryId,\n+      currentEntryId: currentEntryId ?? sessionId,\n       selectedState,\n-      createdAt\n+      createdAt: preservedTimestamp\n     };\n \n     this.usedEnergy = 0;\n@@ -238,6 +255,7 @@ export class EditorEngine {\n     this.isRequesting = false;\n \n     this.notifyChange();\n+    this.notifyBlankReset();\n   }\n \n "
    },
    {
      "sha": "b65073f82dda2d4bbace33c0dafe9c46d9e38957",
      "filename": "frontend/src/utils/sessionGrouping.ts",
      "status": "modified",
      "additions": 19,
      "deletions": 27,
      "changes": 46,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/frontend%2Fsrc%2Futils%2FsessionGrouping.ts",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/frontend%2Fsrc%2Futils%2FsessionGrouping.ts",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Futils%2FsessionGrouping.ts?ref=e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5",
      "patch": "@@ -1,37 +1,29 @@\n import type { CalendarEntry } from './calendarStorage';\n import { extractFirstLine, getTodayKey } from './calendarStorage';\n import type { EditorState } from '../engine/EditorEngine';\n+import { getLocalDayKey, parseFlexibleTimestamp } from './timezone';\n \n type ListSessionsFn = () => Promise<any[]>;\n type GetSessionFn = (id: string) => Promise<any>;\n \n-function normalizeTimestamp(raw?: string | null): Date | null {\n-  if (!raw) return null;\n-  const normalized = raw.includes('T') ? raw : raw.replace(' ', 'T');\n-  const withZone = /[zZ]$/.test(normalized) ? normalized : `${normalized}Z`;\n-  const parsed = Date.parse(withZone);\n-  if (Number.isNaN(parsed)) {\n-    return null;\n-  }\n-  return new Date(parsed);\n-}\n+function getSessionTimestamp(sessionMeta: any, fullSession: any): Date | null {\n+  const stateTimestamp = parseFlexibleTimestamp(fullSession?.editor_state?.createdAt);\n+  if (stateTimestamp) return stateTimestamp;\n \n-export function getSessionDateKey(session: any, state?: EditorState): string {\n-  const name = session?.name;\n-  if (name && /^\\d{4}-\\d{2}-\\d{2}/.test(name)) {\n-    return name.split(' - ')[0];\n-  }\n+  const createdAt = parseFlexibleTimestamp(fullSession?.created_at || sessionMeta?.created_at);\n+  if (createdAt) return createdAt;\n \n-  if (state?.createdAt) {\n-    return state.createdAt;\n-  }\n+  const updatedAt = parseFlexibleTimestamp(fullSession?.updated_at || sessionMeta?.updated_at);\n+  return updatedAt;\n+}\n \n-  const timestamp = normalizeTimestamp(session?.updated_at || session?.created_at);\n-  if (timestamp) {\n-    return timestamp.toISOString().substring(0, 10);\n+function getSessionDateKey(session: any, fullSession: any, timezone: string): string {\n+  const timestamp = getSessionTimestamp(session, fullSession);\n+  if (!timestamp) {\n+    console.warn('Session missing timestamp data', session?.id);\n+    return getTodayKey();\n   }\n-\n-  return getTodayKey();\n+  return getLocalDayKey(timestamp, timezone) ?? getTodayKey();\n }\n \n function getEntryFirstLine(sessionName: string | undefined, state?: EditorState): string {\n@@ -47,9 +39,9 @@ function getEntryFirstLine(sessionName: string | undefined, state?: EditorState)\n export async function loadSessionsGroupedByDate(\n   listSessions: ListSessionsFn,\n   getSession: GetSessionFn,\n-  options: { requireName?: boolean } = {}\n+  options: { requireName?: boolean; timezone?: string } = {}\n ): Promise<Record<string, CalendarEntry[]>> {\n-  const { requireName = false } = options;\n+  const { requireName = false, timezone = 'UTC' } = options;\n   const sessions = await listSessions();\n   const grouped: Record<string, CalendarEntry[]> = {};\n \n@@ -60,13 +52,13 @@ export async function loadSessionsGroupedByDate(\n       const fullSession = await getSession(session.id);\n       if (!fullSession?.editor_state) continue;\n \n-      const dateKey = getSessionDateKey(session, fullSession.editor_state);\n+      const dateKey = getSessionDateKey(session, fullSession, timezone);\n       const firstLine = getEntryFirstLine(session.name, fullSession.editor_state);\n       if (!grouped[dateKey]) {\n         grouped[dateKey] = [];\n       }\n \n-      const timestamp = normalizeTimestamp(session?.created_at || session?.updated_at);\n+      const timestamp = getSessionTimestamp(session, fullSession);\n       const displayTimestamp = timestamp ? timestamp.getTime() : Date.now();\n \n       grouped[dateKey].push({"
    },
    {
      "sha": "119fa135598d02e0537eb0ffbf3b1281f997e311",
      "filename": "frontend/src/utils/timezone.ts",
      "status": "added",
      "additions": 61,
      "deletions": 0,
      "changes": 61,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/frontend%2Fsrc%2Futils%2Ftimezone.ts",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5/frontend%2Fsrc%2Futils%2Ftimezone.ts",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Futils%2Ftimezone.ts?ref=e7d5ea83b82e7f5cffd8e52b95b60190e4ceecd5",
      "patch": "@@ -0,0 +1,61 @@\n+const CANONICAL_LOCALE = 'en-CA';\n+\n+function ensureDate(value?: string | number | Date | null): Date | null {\n+  if (!value && value !== 0) return null;\n+  if (value instanceof Date) return Number.isNaN(value.getTime()) ? null : value;\n+  if (typeof value === 'number') {\n+    const parsed = new Date(value);\n+    return Number.isNaN(parsed.getTime()) ? null : parsed;\n+  }\n+  if (typeof value === 'string') {\n+    const normalized = value.includes('T') ? value : `${value}T00:00:00Z`;\n+    const parsed = new Date(normalized);\n+    return Number.isNaN(parsed.getTime()) ? null : parsed;\n+  }\n+  return null;\n+}\n+\n+export function formatDateInTimeZone(date: Date, timeZone: string): string {\n+  return new Intl.DateTimeFormat(CANONICAL_LOCALE, {\n+    timeZone,\n+    year: 'numeric',\n+    month: '2-digit',\n+    day: '2-digit'\n+  }).format(date);\n+}\n+\n+export function getLocalDayKey(value: Date | string | number | null | undefined, timeZone: string): string | null {\n+  const date = ensureDate(value ?? null);\n+  if (!date) return null;\n+  return formatDateInTimeZone(date, timeZone);\n+}\n+\n+export function parseFlexibleTimestamp(value?: string | null): Date | null {\n+  if (!value) return null;\n+  return ensureDate(value);\n+}\n+\n+export function getTodayKeyInTimezone(timeZone: string): string {\n+  return formatDateInTimeZone(new Date(), timeZone);\n+}\n+\n+export function areDatesSameLocalDay(a?: string, b?: string, timeZone: string = 'UTC'): boolean {\n+  if (!a || !b) return false;\n+  const dayA = getLocalDayKey(a, timeZone);\n+  const dayB = getLocalDayKey(b, timeZone);\n+  return Boolean(dayA && dayB && dayA === dayB);\n+}\n+\n+export function convertLocalDayToUtcRange(dayKey: string, timeZone: string): { start: Date; end: Date } {\n+  const [year, month, day] = dayKey.split('-').map(Number);\n+  const local = new Date(Date.UTC(year, month - 1, day));\n+  const tzDate = new Date(local.toLocaleString('en-US', { timeZone }));\n+  const start = new Date(tzDate);\n+  start.setHours(0, 0, 0, 0);\n+  const end = new Date(start);\n+  end.setDate(end.getDate() + 1);\n+  return {\n+    start: new Date(start.toLocaleString('en-US', { timeZone: 'UTC' })),\n+    end: new Date(end.toLocaleString('en-US', { timeZone: 'UTC' }))\n+  };\n+}"
    }
  ]
}