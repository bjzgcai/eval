{
  "sha": "2d3d70520cee9077fdc27b77ccff340a7e14093a",
  "node_id": "C_kwDOP2Zrm9oAKDJkM2Q3MDUyMGNlZTkwNzdmZGMyN2I3N2NjZmYzNDBhN2UxNDA5M2E",
  "commit": {
    "author": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-10-26T06:08:20Z"
    },
    "committer": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-10-26T06:08:20Z"
    },
    "message": "Integrate new engine as main App\n\n- Rename AppSimplified.tsx -> App.tsx\n- Archive old App.tsx -> App.old.tsx\n- Update localStorage key to ink_memory_state\n- Fix TypeScript errors (useRef typing, unused param)\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude <noreply@anthropic.com>",
    "tree": {
      "sha": "936f79332777fd7b56e17ec4eb690dfa43cb1195",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/trees/936f79332777fd7b56e17ec4eb690dfa43cb1195"
    },
    "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/commits/2d3d70520cee9077fdc27b77ccff340a7e14093a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null,
      "verified_at": null
    }
  },
  "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/2d3d70520cee9077fdc27b77ccff340a7e14093a",
  "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/2d3d70520cee9077fdc27b77ccff340a7e14093a",
  "comments_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/2d3d70520cee9077fdc27b77ccff340a7e14093a/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "a5dc1232b4cb102653a5ef9f6e129b1117f44ac4",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/a5dc1232b4cb102653a5ef9f6e129b1117f44ac4",
      "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/a5dc1232b4cb102653a5ef9f6e129b1117f44ac4"
    }
  ],
  "stats": {
    "total": 2267,
    "additions": 1131,
    "deletions": 1136
  },
  "files": [
    {
      "sha": "e6d859fd38fa5f5522ac71b33a3a41817934befb",
      "filename": "frontend/src/App.old.tsx",
      "status": "added",
      "additions": 415,
      "deletions": 0,
      "changes": 415,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/2d3d70520cee9077fdc27b77ccff340a7e14093a/frontend%2Fsrc%2FApp.old.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/2d3d70520cee9077fdc27b77ccff340a7e14093a/frontend%2Fsrc%2FApp.old.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2FApp.old.tsx?ref=2d3d70520cee9077fdc27b77ccff340a7e14093a",
      "patch": "@@ -0,0 +1,415 @@\n+import { useState, useEffect, useRef } from 'react'\n+import './App.css'\n+import WritingArea from './components/WritingArea'\n+import type { EditableTextAreaRef } from './components/EditableTextArea'\n+import VoicesPanel from './components/VoicesPanel'\n+import VoiceComment from './components/VoiceComment'\n+import BinderRings from './components/BinderRings'\n+import VoiceSettings from './components/VoiceSettings'\n+import CalendarView from './components/CalendarView'\n+import AnalysisView from './components/AnalysisView'\n+import AboutView from './components/AboutView'\n+import LeftSidebar from './components/LeftSidebar'\n+import type { VoiceTrigger } from './extensions/VoiceHighlight'\n+import type { VoiceConfig } from './types/voice'\n+import { analyzeText, getDefaultVoices } from './api/voiceApi'\n+import { getVoices } from './utils/voiceStorage'\n+\n+interface Voice {\n+  name: string;\n+  text: string;\n+  icon: string;\n+  color: string;\n+  position: number;\n+}\n+\n+// @@@ UUID fallback for non-secure contexts\n+function generateUUID() {\n+  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n+    const r = Math.random() * 16 | 0;\n+    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n+    return v.toString(16);\n+  });\n+}\n+\n+function App() {\n+  // @@@ Multi-user support - Generate unique session ID on mount\n+  const sessionId = useRef(\n+    typeof crypto !== 'undefined' && crypto.randomUUID\n+      ? crypto.randomUUID()\n+      : generateUUID()\n+  ).current;\n+\n+  // @@@ Version logging and initialize default voices from backend\n+  useEffect(() => {\n+    console.log('üé≠ Ink & Memory - Version: v1.2.1-energy-refund');\n+    console.log('‚ö° Energy pool trigger: accumulate weight changes, trigger at 40 energy');\n+    console.log('‚ôªÔ∏è  Energy refund: if LLM returns no voices, refund 20 energy');\n+    console.log('üìê Weights: CJK=2, punctuation(.!?„ÄÇÔºÅÔºüÔºå\\\\n)=4, other=1');\n+    console.log('üîí Single-threaded: max 1 backend request at a time');\n+\n+    // Fetch default voices from backend\n+    getDefaultVoices().then(backendVoices => {\n+      // Convert backend format to frontend VoiceConfig format (keep text names)\n+      const converted: Record<string, VoiceConfig> = {};\n+      for (const [name, data] of Object.entries(backendVoices)) {\n+        const v = data as any;\n+        converted[name] = {\n+          name,\n+          systemPrompt: v.tagline,\n+          enabled: true,\n+          icon: v.icon,    // Keep text name: \"brain\"\n+          color: v.color   // Keep text name: \"blue\"\n+        };\n+      }\n+      // Store the original defaults separately (never modified)\n+      setDefaultVoiceConfigs(converted);\n+      // Use localStorage if exists, otherwise use backend defaults\n+      setVoiceConfigs(getVoices() || converted);\n+    });\n+  }, [sessionId]);\n+\n+  const [currentView, setCurrentView] = useState<'writing' | 'settings' | 'calendar' | 'analysis' | 'about'>('writing');\n+  const [voices, setVoices] = useState<Voice[]>([]);\n+  const [voiceTriggers, setVoiceTriggers] = useState<VoiceTrigger[]>([]);\n+  const [voiceConfigs, setVoiceConfigs] = useState<Record<string, VoiceConfig>>({});\n+  const [defaultVoiceConfigs, setDefaultVoiceConfigs] = useState<Record<string, VoiceConfig>>({});\n+  const [currentText, setCurrentText] = useState<string>('');\n+  const [currentHTML, setCurrentHTML] = useState<string>('');\n+  const [cursorPosition, setCursorPosition] = useState<number>(0);\n+  const [focusedVoiceIndex, setFocusedVoiceIndex] = useState<number | undefined>(undefined);\n+  const [hoveredPhrase, setHoveredPhrase] = useState<string | null>(null);\n+  const [quotedComments, setQuotedComments] = useState<Array<{ voiceName: string; comment: string }>>([]);\n+  const currentTextRef = useRef<string>('');\n+  const isAnalyzingRef = useRef<boolean>(false);\n+  const editorRef = useRef<EditableTextAreaRef>(null);\n+\n+  // @@@ Energy pool trigger system\n+  const energyRef = useRef<number>(0);\n+  const lastPollWeightRef = useRef<number>(0);\n+\n+  const detectVoices = (text: string, triggers: VoiceTrigger[]) => {\n+    const newVoices: Voice[] = [];\n+    const lowerText = text.toLowerCase();\n+\n+    triggers.forEach(({ phrase, voice, comment, icon, color }) => {\n+      const index = lowerText.indexOf(phrase.toLowerCase());\n+      if (index !== -1) {\n+        newVoices.push({ name: voice, text: comment, icon, color, position: index });\n+      }\n+    });\n+\n+    // Sort by position in text\n+    newVoices.sort((a, b) => a.position - b.position);\n+\n+    setVoices(newVoices);\n+  };\n+\n+  // @@@ Track which voice comment to focus based on cursor position\n+  useEffect(() => {\n+    if (voices.length === 0) {\n+      setFocusedVoiceIndex(undefined);\n+      return;\n+    }\n+\n+    // Find the comment whose trigger phrase is closest to cursor\n+    let closestIndex = 0;\n+    let closestDistance = Math.abs(voices[0].position - cursorPosition);\n+\n+    for (let i = 1; i < voices.length; i++) {\n+      const distance = Math.abs(voices[i].position - cursorPosition);\n+      if (distance < closestDistance) {\n+        closestDistance = distance;\n+        closestIndex = i;\n+      }\n+    }\n+\n+    setFocusedVoiceIndex(closestIndex);\n+  }, [cursorPosition, voices]);\n+\n+  // @@@ weighted-character-counting with punctuation bonus\n+  // Sentence separators get high weight to encourage natural boundaries\n+  const getWeightedLength = (text: string): number => {\n+    let weight = 0;\n+\n+    for (const char of text) {\n+      // Sentence separators (English + Chinese) and newlines = 4 weight\n+      if (/[.!?„ÄÇÔºÅÔºü\\n]/.test(char)) {\n+        weight += 4;\n+      }\n+      // Chinese comma = 0 weight (ignored)\n+      else if (char === 'Ôºå') {\n+        weight += 0;\n+      }\n+      // CJK characters (Chinese, Japanese, Korean) = 2 weight\n+      else if (/[\\u4e00-\\u9fa5\\u3040-\\u309f\\u30a0-\\u30ff]/.test(char)) {\n+        weight += 2;\n+      }\n+      // English/other = 1 weight\n+      else {\n+        weight += 1;\n+      }\n+    }\n+\n+    return weight;\n+  };\n+\n+  const analyzeIfNeeded = async () => {\n+    // Skip if already analyzing (single-threaded)\n+    if (isAnalyzingRef.current) {\n+      return;\n+    }\n+\n+    // @@@ Use text without quotes for weight calculation\n+    // Atomic quote widgets are automatically excluded\n+    const textForWeighting = editorRef.current?.getTextWithoutQuotes() || currentTextRef.current;\n+    const currentWeight = getWeightedLength(textForWeighting);\n+\n+    // Still use full text for backend analysis\n+    const currentTextValue = currentTextRef.current;\n+\n+    // Calculate weight difference since last poll\n+    const weightDiff = currentWeight - lastPollWeightRef.current;\n+\n+    // Accumulate energy (only positive changes, ignore deletions)\n+    if (weightDiff > 0) {\n+      energyRef.current += weightDiff;\n+      console.log(`‚ö° Energy accumulated: +${weightDiff} ‚Üí ${energyRef.current} total`);\n+    }\n+\n+    // @@@ Update last poll weight ALWAYS (every cycle, even if negative)\n+    lastPollWeightRef.current = currentWeight;\n+\n+    // Check if we have enough energy to trigger\n+    if (energyRef.current < 40) {\n+      return;\n+    }\n+\n+    // Trigger backend request and consume energy\n+    isAnalyzingRef.current = true;\n+    energyRef.current -= 40;\n+    const remainingEnergy = energyRef.current;\n+\n+    try {\n+      console.log(`üîç Calling backend analysis (consumed 40 energy, ${remainingEnergy} remaining)...`);\n+      console.log(`üìù Current voiceConfigs:`, voiceConfigs);\n+      // Convert frontend VoiceConfig to backend format\n+      const backendFormat: Record<string, any> = {};\n+      for (const [name, cfg] of Object.entries(voiceConfigs)) {\n+        if (cfg.enabled) {\n+          backendFormat[name] = {\n+            name: cfg.name,\n+            tagline: cfg.systemPrompt,\n+            icon: cfg.icon,\n+            color: cfg.color\n+          };\n+        }\n+      }\n+      console.log(`üì§ Sending to backend:`, backendFormat);\n+      const result = await analyzeText(currentTextValue, sessionId, backendFormat);\n+      console.log(`‚úÖ Got ${result.voices.length} total voices (${result.new_voices_added} new from this LLM call)`);\n+\n+      // @@@ Energy refund mechanism - if LLM returns no NEW comments, refund 20 energy\n+      // This prevents wasting energy when nothing interesting is detected\n+      if (result.new_voices_added === 0) {\n+        energyRef.current += 20;\n+        console.log(`‚ôªÔ∏è  No new voices detected, refunded 20 energy ‚Üí ${energyRef.current} total`);\n+      }\n+\n+      setVoiceTriggers(result.voices);\n+      detectVoices(currentTextValue, result.voices);\n+    } catch (error) {\n+      console.error('‚ùå Voice analysis failed:', error);\n+    } finally {\n+      isAnalyzingRef.current = false;\n+    }\n+  };\n+\n+  // @@@ Reset weight baseline when switching back to writing view\n+  // Prevents energy accumulation from \"seeing\" the full text again\n+  useEffect(() => {\n+    if (currentView === 'writing' && editorRef.current) {\n+      const textForWeighting = editorRef.current.getTextWithoutQuotes() || currentTextRef.current;\n+      lastPollWeightRef.current = getWeightedLength(textForWeighting);\n+      console.log(`üîÑ Switched to writing view, reset baseline weight to ${lastPollWeightRef.current}`);\n+    }\n+  }, [currentView]);\n+\n+  // @@@ Polling strategy - Check every 5 seconds (stable interval)\n+  // Must include voiceConfigs in deps so interval uses latest config\n+  // Only run when in writing view to prevent energy accumulation when switched away\n+  useEffect(() => {\n+    if (currentView !== 'writing') {\n+      return;\n+    }\n+\n+    const interval = setInterval(analyzeIfNeeded, 5000);\n+    return () => clearInterval(interval);\n+  }, [voiceConfigs, currentView]);\n+\n+  const handleTextChange = (newText: string) => {\n+    setCurrentText(newText);\n+    currentTextRef.current = newText;\n+\n+    // Instantly update display with current triggers\n+    detectVoices(newText, voiceTriggers);\n+  };\n+\n+  const handleContentChange = (newHTML: string) => {\n+    setCurrentHTML(newHTML);\n+\n+    // @@@ Update quoted comments list whenever content changes\n+    if (editorRef.current?.getQuotedComments) {\n+      setQuotedComments(editorRef.current.getQuotedComments());\n+    }\n+  };\n+\n+  const handleQuote = (voiceName: string, comment: string) => {\n+    // @@@ Insert atomic voice quote widget\n+    // Quotes are now special nodes that are automatically excluded from weight calculation\n+    if (editorRef.current?.insertVoiceQuote) {\n+      // Get voice config for this voice (for chat context)\n+      const voiceConfig = voiceConfigs[voiceName] || {\n+        tagline: `${voiceName} voice`\n+      };\n+\n+      editorRef.current.insertVoiceQuote(voiceName, comment, {\n+        tagline: voiceConfig.systemPrompt,\n+        icon: voiceConfig.icon,\n+        color: voiceConfig.color\n+      });\n+    } else {\n+      console.error('insertVoiceQuote method not available on editorRef');\n+    }\n+  };\n+\n+  // @@@ Re-detect voices when triggers change\n+  useEffect(() => {\n+    detectVoices(currentText, voiceTriggers);\n+  }, [voiceTriggers]);\n+\n+  // @@@ Clear old triggers when voice config changes (e.g., Use Default)\n+  // This forces immediate re-analysis with new config\n+  useEffect(() => {\n+    // Skip on initial mount (voiceConfigs is empty)\n+    if (Object.keys(voiceConfigs).length === 0) return;\n+\n+    console.log('üîÑ Voice config changed, clearing old triggers and triggering immediate analysis');\n+    setVoiceTriggers([]);\n+    setVoices([]);\n+\n+    // Force immediate re-analysis (session ID ensures backend returns cached results)\n+    energyRef.current = 40;\n+    analyzeIfNeeded();\n+  }, [voiceConfigs]);\n+\n+  return (\n+    <>\n+      <LeftSidebar currentView={currentView} onViewChange={setCurrentView} />\n+      {currentView === 'writing' && (\n+        <div className=\"book-interface\">\n+          <WritingArea\n+            ref={editorRef}\n+            onChange={handleTextChange}\n+            onContentChange={handleContentChange}\n+            triggers={voiceTriggers}\n+            onCursorChange={setCursorPosition}\n+            onPhraseHover={setHoveredPhrase}\n+            content={currentHTML}\n+          />\n+          <VoicesPanel focusedVoiceIndex={focusedVoiceIndex}>\n+            {voices\n+              .filter(voice => {\n+                // @@@ Hide comments that are already quoted as widgets\n+                return !quotedComments.some(\n+                  quoted => quoted.voiceName === voice.name && quoted.comment === voice.text\n+                );\n+              })\n+              .map((voice, index) => {\n+                // @@@ Find the trigger phrase for this voice\n+                const trigger = voiceTriggers.find(t =>\n+                  t.voice === voice.name && t.comment === voice.text\n+                );\n+                const isHovered = hoveredPhrase !== null && trigger !== undefined &&\n+                  hoveredPhrase.toLowerCase() === trigger.phrase.toLowerCase();\n+\n+                return (\n+                  <VoiceComment\n+                    key={index}\n+                    voice={voice.name}\n+                    text={voice.text}\n+                    icon={voice.icon}\n+                    color={voice.color}\n+                    onQuote={() => handleQuote(voice.name, voice.text)}\n+                    isHovered={isHovered}\n+                  />\n+                );\n+              })}\n+          </VoicesPanel>\n+          <BinderRings />\n+        </div>\n+      )}\n+      {currentView === 'settings' && (\n+        <div style={{\n+          position: 'fixed',\n+          top: 48,\n+          left: 0,\n+          right: 0,\n+          bottom: 0,\n+          background: '#f8f0e6',\n+          display: 'flex',\n+          overflow: 'hidden'\n+        }}>\n+          <VoiceSettings\n+            defaultVoices={defaultVoiceConfigs}\n+            onSave={setVoiceConfigs}\n+          />\n+        </div>\n+      )}\n+      {currentView === 'calendar' && (\n+        <div style={{\n+          position: 'fixed',\n+          top: 48,\n+          left: 0,\n+          right: 0,\n+          bottom: 0,\n+          background: '#f8f0e6',\n+          display: 'flex',\n+          overflow: 'hidden'\n+        }}>\n+          <CalendarView />\n+        </div>\n+      )}\n+      {currentView === 'analysis' && (\n+        <div style={{\n+          position: 'fixed',\n+          top: 48,\n+          left: 0,\n+          right: 0,\n+          bottom: 0,\n+          background: '#f8f0e6',\n+          display: 'flex',\n+          overflow: 'hidden'\n+        }}>\n+          <AnalysisView />\n+        </div>\n+      )}\n+      {currentView === 'about' && (\n+        <div style={{\n+          position: 'fixed',\n+          top: 48,\n+          left: 0,\n+          right: 0,\n+          bottom: 0,\n+          background: '#f8f0e6',\n+          display: 'flex',\n+          overflow: 'hidden'\n+        }}>\n+          <AboutView />\n+        </div>\n+      )}\n+    </>\n+  );\n+}\n+\n+export default App\n\\ No newline at end of file"
    },
    {
      "sha": "0f48d1b2d76909f52dbdff6589dcfe476bec05d1",
      "filename": "frontend/src/App.tsx",
      "status": "modified",
      "additions": 714,
      "deletions": 362,
      "changes": 1076,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/2d3d70520cee9077fdc27b77ccff340a7e14093a/frontend%2Fsrc%2FApp.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/2d3d70520cee9077fdc27b77ccff340a7e14093a/frontend%2Fsrc%2FApp.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2FApp.tsx?ref=2d3d70520cee9077fdc27b77ccff340a7e14093a",
      "patch": "@@ -1,415 +1,767 @@\n-import { useState, useEffect, useRef } from 'react'\n-import './App.css'\n-import WritingArea from './components/WritingArea'\n-import type { EditableTextAreaRef } from './components/EditableTextArea'\n-import VoicesPanel from './components/VoicesPanel'\n-import VoiceComment from './components/VoiceComment'\n-import BinderRings from './components/BinderRings'\n-import VoiceSettings from './components/VoiceSettings'\n-import CalendarView from './components/CalendarView'\n-import AnalysisView from './components/AnalysisView'\n-import AboutView from './components/AboutView'\n-import LeftSidebar from './components/LeftSidebar'\n-import type { VoiceTrigger } from './extensions/VoiceHighlight'\n-import type { VoiceConfig } from './types/voice'\n-import { analyzeText, getDefaultVoices } from './api/voiceApi'\n-import { getVoices } from './utils/voiceStorage'\n-\n-interface Voice {\n-  name: string;\n-  text: string;\n-  icon: string;\n-  color: string;\n-  position: number;\n+import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\n+import { EditorEngine } from './engine/EditorEngine';\n+import type { EditorState, Commentor, TextCell } from './engine/EditorEngine';\n+import './App.css';\n+import {\n+  FaSync, FaBold, FaItalic, FaUnderline, FaAlignLeft, FaAlignCenter,\n+  FaAlignRight, FaListUl, FaListOl, FaQuoteRight, FaTable, FaLink, FaImage,\n+  FaBrain, FaHeart, FaQuestion, FaCloud, FaTheaterMasks, FaEye,\n+  FaFistRaised, FaLightbulb, FaShieldAlt, FaWind, FaFire, FaCompass\n+} from 'react-icons/fa';\n+\n+// @@@ Left Toolbar Component\n+function LeftToolbar({ onStartFresh }: { onStartFresh: () => void }) {\n+  const tools = [\n+    { icon: FaSync, tooltip: 'Start Fresh', action: onStartFresh, functional: true, separator: true },\n+    { icon: FaBold, tooltip: 'Bold', functional: false, separator: false },\n+    { icon: FaItalic, tooltip: 'Italic', functional: false, separator: false },\n+    { icon: FaUnderline, tooltip: 'Underline', functional: false, separator: true },\n+    { icon: FaAlignLeft, tooltip: 'Align Left', functional: false, separator: false },\n+    { icon: FaAlignCenter, tooltip: 'Align Center', functional: false, separator: false },\n+    { icon: FaAlignRight, tooltip: 'Align Right', functional: false, separator: true },\n+    { icon: FaListUl, tooltip: 'Bullet List', functional: false, separator: false },\n+    { icon: FaListOl, tooltip: 'Numbered List', functional: false, separator: true },\n+    { icon: FaQuoteRight, tooltip: 'Quote', functional: false, separator: false },\n+    { icon: FaTable, tooltip: 'Insert Table', functional: false, separator: false },\n+    { icon: FaLink, tooltip: 'Insert Link', functional: false, separator: false },\n+    { icon: FaImage, tooltip: 'Insert Image', functional: false, separator: false },\n+  ];\n+\n+  return (\n+    <div style={{\n+      width: '48px',\n+      borderRight: '1px solid #e0e0e0',\n+      backgroundColor: '#fafafa',\n+      display: 'flex',\n+      flexDirection: 'column',\n+      alignItems: 'center',\n+      paddingTop: '10px',\n+      gap: '4px'\n+    }}>\n+      {tools.map((tool, idx) => (\n+        <React.Fragment key={idx}>\n+          <button\n+            onClick={tool.functional ? tool.action : undefined}\n+            disabled={!tool.functional}\n+            title={tool.tooltip}\n+            style={{\n+              width: '36px',\n+              height: '36px',\n+              border: 'none',\n+              borderRadius: '4px',\n+              backgroundColor: tool.functional ? '#fff' : 'transparent',\n+              cursor: tool.functional ? 'pointer' : 'not-allowed',\n+              display: 'flex',\n+              alignItems: 'center',\n+              justifyContent: 'center',\n+              opacity: tool.functional ? 1 : 0.3,\n+              transition: 'all 0.2s ease',\n+              ...(tool.functional && {\n+                ':hover': {\n+                  backgroundColor: '#f0f0f0'\n+                }\n+              })\n+            }}\n+            onMouseEnter={tool.functional ? (e) => {\n+              e.currentTarget.style.backgroundColor = '#f0f0f0';\n+            } : undefined}\n+            onMouseLeave={tool.functional ? (e) => {\n+              e.currentTarget.style.backgroundColor = '#fff';\n+            } : undefined}\n+          >\n+            <tool.icon size={18} color={tool.functional ? '#333' : '#999'} />\n+          </button>\n+          {tool.separator && idx < tools.length - 1 && (\n+            <div style={{\n+              width: '30px',\n+              height: '1px',\n+              backgroundColor: '#e0e0e0',\n+              margin: '4px 0'\n+            }} />\n+          )}\n+        </React.Fragment>\n+      ))}\n+    </div>\n+  );\n }\n \n-// @@@ UUID fallback for non-secure contexts\n-function generateUUID() {\n-  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n-    const r = Math.random() * 16 | 0;\n-    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n-    return v.toString(16);\n-  });\n+// @@@ Icon map with React Icons (matching original)\n+const iconMap = {\n+  brain: FaBrain,\n+  heart: FaHeart,\n+  question: FaQuestion,\n+  cloud: FaCloud,\n+  masks: FaTheaterMasks,\n+  eye: FaEye,\n+  fist: FaFistRaised,\n+  lightbulb: FaLightbulb,\n+  shield: FaShieldAlt,\n+  wind: FaWind,\n+  fire: FaFire,\n+  compass: FaCompass,\n+};\n+\n+// @@@ Color map with gradient colors for watercolor effect (right to left fade)\n+const colorMap: Record<string, { gradient: string; text: string; glow: string }> = {\n+  blue: {\n+    gradient: 'linear-gradient(90deg, rgba(77,159,255,0) 0%, rgba(77,159,255,0.05) 30%, rgba(77,159,255,0.12) 60%, rgba(77,159,255,0.25) 100%)',\n+    text: '#0066cc',\n+    glow: 'rgba(77,159,255,0.15)'\n+  },\n+  pink: {\n+    gradient: 'linear-gradient(90deg, rgba(255,102,179,0) 0%, rgba(255,102,179,0.05) 30%, rgba(255,102,179,0.12) 60%, rgba(255,102,179,0.25) 100%)',\n+    text: '#cc0066',\n+    glow: 'rgba(255,102,179,0.15)'\n+  },\n+  yellow: {\n+    gradient: 'linear-gradient(90deg, rgba(255,221,51,0) 0%, rgba(255,221,51,0.05) 30%, rgba(255,221,51,0.12) 60%, rgba(255,221,51,0.25) 100%)',\n+    text: '#996600',\n+    glow: 'rgba(255,221,51,0.15)'\n+  },\n+  green: {\n+    gradient: 'linear-gradient(90deg, rgba(102,255,102,0) 0%, rgba(102,255,102,0.05) 30%, rgba(102,255,102,0.12) 60%, rgba(102,255,102,0.25) 100%)',\n+    text: '#006600',\n+    glow: 'rgba(102,255,102,0.15)'\n+  },\n+  purple: {\n+    gradient: 'linear-gradient(90deg, rgba(179,102,255,0) 0%, rgba(179,102,255,0.05) 30%, rgba(179,102,255,0.12) 60%, rgba(179,102,255,0.25) 100%)',\n+    text: '#6600cc',\n+    glow: 'rgba(179,102,255,0.15)'\n+  },\n+};\n+\n+// @@@ Group Comment Card Component - elegant gradient watercolor style\n+function CommentGroupCard({\n+  comments,\n+  currentIndex,\n+  onNavigate,\n+  position\n+}: {\n+  comments: Commentor[];\n+  currentIndex: number;\n+  onNavigate: (index: number) => void;\n+  position: { top: number; left: number };\n+}) {\n+  const [isHovered, setIsHovered] = React.useState(false);\n+\n+  if (comments.length === 0) return null;\n+\n+  // @@@ Bounds check - ensure currentIndex is valid\n+  const safeIndex = Math.min(Math.max(0, currentIndex), comments.length - 1);\n+  const currentComment = comments[safeIndex];\n+\n+  if (!currentComment) return null;\n+\n+  const Icon = iconMap[currentComment.icon as keyof typeof iconMap] || FaBrain;\n+  const colors = colorMap[currentComment.color] || colorMap.blue;\n+\n+  return (\n+    <div\n+      style={{\n+        position: 'absolute',\n+        top: `${position.top}px`,\n+        left: `${position.left}px`,\n+        transform: `translateY(-50%) ${isHovered ? 'scale(1.02)' : 'scale(1)'}`,\n+        minWidth: '200px',\n+        maxWidth: '400px',\n+        height: '54px', // Fixed 3 rows: ~18px per row\n+        padding: '8px 12px',\n+        background: colors.gradient,\n+        borderLeft: `2px solid ${colors.glow}`,\n+        borderRadius: '4px',\n+        fontSize: '13px',\n+        lineHeight: '1.4',\n+        zIndex: 10,\n+        cursor: comments.length > 1 ? 'pointer' : 'default',\n+        transition: 'all 0.2s ease',\n+        fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif',\n+        boxShadow: isHovered ? '0 4px 12px rgba(0,0,0,0.15)' : 'none',\n+        animation: 'slideInFromRight 0.3s ease-out',\n+      }}\n+      onClick={() => {\n+        // Click to cycle through comments (only if multiple)\n+        if (comments.length > 1) {\n+          onNavigate((safeIndex + 1) % comments.length);\n+        }\n+      }}\n+      onMouseEnter={() => setIsHovered(true)}\n+      onMouseLeave={() => setIsHovered(false)}\n+    >\n+      <div style={{\n+        display: 'flex',\n+        gap: '10px',\n+        height: '100%',\n+        alignItems: 'center'\n+      }}>\n+        {/* Icon with pagination counter below */}\n+        <div style={{\n+          display: 'flex',\n+          flexDirection: 'column',\n+          alignItems: 'center',\n+          justifyContent: 'center',\n+          flexShrink: 0,\n+          width: '24px'\n+        }}>\n+          <Icon size={15} color={colors.text} style={{ opacity: 0.75 }} />\n+          {comments.length > 1 && (\n+            <span style={{\n+              fontSize: '8px',\n+              color: colors.text,\n+              opacity: 0.5,\n+              marginTop: '1px',\n+              fontWeight: 500\n+            }}>\n+              {safeIndex + 1}/{comments.length}\n+            </span>\n+          )}\n+        </div>\n+\n+        {/* Voice name inline with comment */}\n+        <div style={{\n+          flex: 1,\n+          overflow: 'hidden',\n+          textOverflow: 'ellipsis',\n+          display: '-webkit-box',\n+          WebkitLineClamp: 3,\n+          WebkitBoxOrient: 'vertical',\n+          color: colors.text,\n+          opacity: 0.85\n+        }}>\n+          <strong style={{ fontWeight: 600 }}>{currentComment.voice}:</strong> {currentComment.comment}\n+        </div>\n+      </div>\n+    </div>\n+  );\n }\n \n-function App() {\n-  // @@@ Multi-user support - Generate unique session ID on mount\n-  const sessionId = useRef(\n-    typeof crypto !== 'undefined' && crypto.randomUUID\n-      ? crypto.randomUUID()\n-      : generateUUID()\n-  ).current;\n+// @@@ Main App Component\n+export default function App() {\n+  const engineRef = useRef<EditorEngine | null>(null);\n+  const [state, setState] = useState<EditorState | null>(null);\n+  const [localText, setLocalText] = useState(''); // Local text for textarea\n+  const [isComposing, setIsComposing] = useState(false);\n+  const [groupPages, setGroupPages] = useState<Map<number, number>>(new Map());\n+  const [cursorPosition, setCursorPosition] = useState<number>(0);\n \n-  // @@@ Version logging and initialize default voices from backend\n+  const textareaRef = useRef<HTMLTextAreaElement>(null);\n+  const containerRef = useRef<HTMLDivElement>(null);\n+\n+  // Initialize engine\n   useEffect(() => {\n-    console.log('üé≠ Ink & Memory - Version: v1.2.1-energy-refund');\n-    console.log('‚ö° Energy pool trigger: accumulate weight changes, trigger at 40 energy');\n-    console.log('‚ôªÔ∏è  Energy refund: if LLM returns no voices, refund 20 energy');\n-    console.log('üìê Weights: CJK=2, punctuation(.!?„ÄÇÔºÅÔºüÔºå\\\\n)=4, other=1');\n-    console.log('üîí Single-threaded: max 1 backend request at a time');\n-\n-    // Fetch default voices from backend\n-    getDefaultVoices().then(backendVoices => {\n-      // Convert backend format to frontend VoiceConfig format (keep text names)\n-      const converted: Record<string, VoiceConfig> = {};\n-      for (const [name, data] of Object.entries(backendVoices)) {\n-        const v = data as any;\n-        converted[name] = {\n-          name,\n-          systemPrompt: v.tagline,\n-          enabled: true,\n-          icon: v.icon,    // Keep text name: \"brain\"\n-          color: v.color   // Keep text name: \"blue\"\n-        };\n-      }\n-      // Store the original defaults separately (never modified)\n-      setDefaultVoiceConfigs(converted);\n-      // Use localStorage if exists, otherwise use backend defaults\n-      setVoiceConfigs(getVoices() || converted);\n-    });\n-  }, [sessionId]);\n-\n-  const [currentView, setCurrentView] = useState<'writing' | 'settings' | 'calendar' | 'analysis' | 'about'>('writing');\n-  const [voices, setVoices] = useState<Voice[]>([]);\n-  const [voiceTriggers, setVoiceTriggers] = useState<VoiceTrigger[]>([]);\n-  const [voiceConfigs, setVoiceConfigs] = useState<Record<string, VoiceConfig>>({});\n-  const [defaultVoiceConfigs, setDefaultVoiceConfigs] = useState<Record<string, VoiceConfig>>({});\n-  const [currentText, setCurrentText] = useState<string>('');\n-  const [currentHTML, setCurrentHTML] = useState<string>('');\n-  const [cursorPosition, setCursorPosition] = useState<number>(0);\n-  const [focusedVoiceIndex, setFocusedVoiceIndex] = useState<number | undefined>(undefined);\n-  const [hoveredPhrase, setHoveredPhrase] = useState<string | null>(null);\n-  const [quotedComments, setQuotedComments] = useState<Array<{ voiceName: string; comment: string }>>([]);\n-  const currentTextRef = useRef<string>('');\n-  const isAnalyzingRef = useRef<boolean>(false);\n-  const editorRef = useRef<EditableTextAreaRef>(null);\n-\n-  // @@@ Energy pool trigger system\n-  const energyRef = useRef<number>(0);\n-  const lastPollWeightRef = useRef<number>(0);\n-\n-  const detectVoices = (text: string, triggers: VoiceTrigger[]) => {\n-    const newVoices: Voice[] = [];\n-    const lowerText = text.toLowerCase();\n-\n-    triggers.forEach(({ phrase, voice, comment, icon, color }) => {\n-      const index = lowerText.indexOf(phrase.toLowerCase());\n-      if (index !== -1) {\n-        newVoices.push({ name: voice, text: comment, icon, color, position: index });\n-      }\n+    const sessionId = crypto.randomUUID ? crypto.randomUUID() : Date.now().toString();\n+    const engine = new EditorEngine(sessionId);\n+    engineRef.current = engine;\n+\n+    // Subscribe to state changes\n+    engine.subscribe((newState) => {\n+      setState({ ...newState });\n+      // Save to localStorage\n+      localStorage.setItem('ink_memory_state', JSON.stringify(newState));\n     });\n \n-    // Sort by position in text\n-    newVoices.sort((a, b) => a.position - b.position);\n-\n-    setVoices(newVoices);\n-  };\n+    // Load saved state if exists\n+    const saved = localStorage.getItem('ink_memory_state');\n+    if (saved) {\n+      try {\n+        const parsed = JSON.parse(saved);\n+        engine.loadState(parsed);\n+\n+        // Load initial text and state together\n+        const textCell = parsed.cells?.find((c: any) => c.type === 'text');\n+        const initialText = textCell?.content || '';\n+\n+        setLocalText(initialText);\n+        setState(engine.getState());\n+\n+        // Double-check: force re-render after a tick to ensure everything is initialized\n+        setTimeout(() => {\n+          setLocalText(initialText);\n+          setState({ ...engine.getState() });\n+        }, 10);\n+      } catch (e) {\n+        console.error('Failed to load saved state:', e);\n+      }\n+    } else {\n+      setState(engine.getState());\n+    }\n+  }, []);\n \n-  // @@@ Track which voice comment to focus based on cursor position\n+  // Sync local text with state (when not composing)\n   useEffect(() => {\n-    if (voices.length === 0) {\n-      setFocusedVoiceIndex(undefined);\n-      return;\n+    if (!isComposing && state) {\n+      const textCell = state.cells.find(c => c.type === 'text') as TextCell;\n+      if (textCell) {\n+        setLocalText(textCell.content || '');\n+      }\n+    }\n+  }, [state, isComposing]);\n+\n+  // @@@ Group comments by 2-row blocks using visual lines (accounting for wrapping)\n+  const commentGroups = useMemo(() => {\n+    const groups = new Map<number, {\n+      comments: Commentor[];\n+      blockIndex: number;\n+      visualLineStart: number;\n+      visualLineEnd: number;\n+      maxLineWidth: number;\n+      centerY: number;\n+    }>();\n+\n+    if (!textareaRef.current || !state) return groups;\n+\n+    const text = localText;\n+    const maxTextareaWidth = 600;\n+\n+    // Get actual line height from computed styles\n+    const computedStyle = window.getComputedStyle(textareaRef.current);\n+    const fontSize = parseFloat(computedStyle.fontSize) || 18;\n+    const lineHeightRatio = parseFloat(computedStyle.lineHeight) / fontSize || 1.8;\n+    const lineHeight = fontSize * lineHeightRatio;\n+\n+    // Create a temporary canvas to measure text width\n+    const canvas = document.createElement('canvas');\n+    const ctx = canvas.getContext('2d');\n+    if (ctx) {\n+      // Use actual font from computed styles\n+      const fontFamily = computedStyle.fontFamily || 'system-ui, -apple-system, sans-serif';\n+      ctx.font = `${fontSize}px ${fontFamily}`;\n     }\n \n-    // Find the comment whose trigger phrase is closest to cursor\n-    let closestIndex = 0;\n-    let closestDistance = Math.abs(voices[0].position - cursorPosition);\n-\n-    for (let i = 1; i < voices.length; i++) {\n-      const distance = Math.abs(voices[i].position - cursorPosition);\n-      if (distance < closestDistance) {\n-        closestDistance = distance;\n-        closestIndex = i;\n+    // @@@ Build a map from character index to visual line number\n+    const charToVisualLine: number[] = new Array(text.length);\n+    let currentVisualLine = 0;\n+    let currentLineStartIndex = 0;\n+\n+    for (let i = 0; i < text.length; i++) {\n+      charToVisualLine[i] = currentVisualLine;\n+\n+      if (text[i] === '\\n') {\n+        // Hard line break - move to next visual line\n+        currentVisualLine++;\n+        currentLineStartIndex = i + 1;\n+      } else {\n+        // Check if we need to wrap\n+        const currentLineText = text.substring(currentLineStartIndex, i + 1);\n+        const width = ctx ? ctx.measureText(currentLineText).width : currentLineText.length * (fontSize * 0.6);\n+\n+        if (width > maxTextareaWidth && i > currentLineStartIndex) {\n+          // This character causes a wrap - move to next visual line\n+          currentVisualLine++;\n+          currentLineStartIndex = i;\n+          charToVisualLine[i] = currentVisualLine;\n+        }\n       }\n     }\n \n-    setFocusedVoiceIndex(closestIndex);\n-  }, [cursorPosition, voices]);\n+    // Process each commentor\n+    state.commentors\n+      .filter(c => c.appliedAt)\n+      .forEach(commentor => {\n+        const index = text.toLowerCase().indexOf(commentor.phrase.toLowerCase());\n+        if (index === -1) return;\n+\n+        // Get visual line number for this character position\n+        const visualLineNumber = charToVisualLine[index] || 0;\n+\n+        // Determine which 2-row block this belongs to (0-1, 2-3, 4-5, etc.)\n+        const blockIndex = Math.floor(visualLineNumber / 2);\n+        const visualLineStart = blockIndex * 2;\n+        const visualLineEnd = visualLineStart + 1;\n+\n+        if (!groups.has(blockIndex)) {\n+          // For visual lines, we can assume they're all ~700px wide (or less)\n+          // So maxWidth is just the width of the longer of the two visual lines in this block\n+          let maxWidth = 0;\n+\n+          // Find all text on these two visual lines\n+          for (let i = 0; i < text.length; i++) {\n+            const vLine = charToVisualLine[i];\n+            if (vLine === visualLineStart || vLine === visualLineEnd) {\n+              // Find the end of this visual line\n+              let lineEnd = i;\n+              while (lineEnd < text.length && charToVisualLine[lineEnd] === vLine) {\n+                lineEnd++;\n+              }\n+              const lineText = text.substring(i, lineEnd);\n+              const width = ctx ? ctx.measureText(lineText).width : lineText.length * (fontSize * 0.6);\n+              maxWidth = Math.max(maxWidth, Math.min(width, maxTextareaWidth));\n+              i = lineEnd - 1; // Skip to end of this visual line\n+            }\n+          }\n+\n+          // Calculate vertical center of the 2-row block\n+          const centerY = (visualLineStart + 1) * lineHeight;\n+\n+          groups.set(blockIndex, {\n+            comments: [],\n+            blockIndex,\n+            visualLineStart,\n+            visualLineEnd,\n+            maxLineWidth: maxWidth,\n+            centerY\n+          });\n+        }\n \n-  // @@@ weighted-character-counting with punctuation bonus\n-  // Sentence separators get high weight to encourage natural boundaries\n-  const getWeightedLength = (text: string): number => {\n-    let weight = 0;\n+        groups.get(blockIndex)!.comments.push(commentor);\n+      });\n \n-    for (const char of text) {\n-      // Sentence separators (English + Chinese) and newlines = 4 weight\n-      if (/[.!?„ÄÇÔºÅÔºü\\n]/.test(char)) {\n-        weight += 4;\n-      }\n-      // Chinese comma = 0 weight (ignored)\n-      else if (char === 'Ôºå') {\n-        weight += 0;\n-      }\n-      // CJK characters (Chinese, Japanese, Korean) = 2 weight\n-      else if (/[\\u4e00-\\u9fa5\\u3040-\\u309f\\u30a0-\\u30ff]/.test(char)) {\n-        weight += 2;\n-      }\n-      // English/other = 1 weight\n-      else {\n-        weight += 1;\n-      }\n-    }\n+    return groups;\n+  }, [state?.commentors, localText, state]);\n \n-    return weight;\n-  };\n+  // @@@ Auto-switch to newest comment when group size changes\n+  useEffect(() => {\n+    if (!commentGroups) return;\n \n-  const analyzeIfNeeded = async () => {\n-    // Skip if already analyzing (single-threaded)\n-    if (isAnalyzingRef.current) {\n-      return;\n-    }\n+    setGroupPages(prev => {\n+      const next = new Map(prev);\n \n-    // @@@ Use text without quotes for weight calculation\n-    // Atomic quote widgets are automatically excluded\n-    const textForWeighting = editorRef.current?.getTextWithoutQuotes() || currentTextRef.current;\n-    const currentWeight = getWeightedLength(textForWeighting);\n+      // For each group, ensure the page index is valid\n+      commentGroups.forEach((group, blockIndex) => {\n+        if (group.comments.length === 0) {\n+          next.delete(blockIndex);\n+          return;\n+        }\n \n-    // Still use full text for backend analysis\n-    const currentTextValue = currentTextRef.current;\n+        const currentPage = prev.get(blockIndex) || 0;\n+        const maxPage = group.comments.length - 1;\n \n-    // Calculate weight difference since last poll\n-    const weightDiff = currentWeight - lastPollWeightRef.current;\n+        // If we're on an old page and there are new comments, switch to the newest\n+        if (group.comments.length > 1 && currentPage < maxPage) {\n+          next.set(blockIndex, maxPage); // Show the newest comment\n+        } else if (currentPage > maxPage) {\n+          // Current page is out of bounds, reset to last valid page\n+          next.set(blockIndex, maxPage);\n+        }\n+      });\n \n-    // Accumulate energy (only positive changes, ignore deletions)\n-    if (weightDiff > 0) {\n-      energyRef.current += weightDiff;\n-      console.log(`‚ö° Energy accumulated: +${weightDiff} ‚Üí ${energyRef.current} total`);\n-    }\n+      // Remove pages for groups that no longer exist\n+      prev.forEach((_, blockIndex) => {\n+        if (!commentGroups.has(blockIndex)) {\n+          next.delete(blockIndex);\n+        }\n+      });\n \n-    // @@@ Update last poll weight ALWAYS (every cycle, even if negative)\n-    lastPollWeightRef.current = currentWeight;\n+      return next;\n+    });\n+  }, [commentGroups]);\n+\n+  // @@@ Handle page navigation for comment groups\n+  const handleGroupNavigate = useCallback((blockIndex: number, newIndex: number) => {\n+    setGroupPages(prev => {\n+      const next = new Map(prev);\n+      next.set(blockIndex, newIndex);\n+      return next;\n+    });\n+  }, []);\n \n-    // Check if we have enough energy to trigger\n-    if (energyRef.current < 40) {\n-      return;\n-    }\n+  // @@@ Detect which comment the cursor is inside and switch to it\n+  useEffect(() => {\n+    if (!state || !localText) return;\n+\n+    const appliedComments = state.commentors.filter(c => c.appliedAt);\n+    if (appliedComments.length === 0) return;\n+\n+    // Find which comment contains the cursor\n+    let foundComment: Commentor | null = null;\n+    for (const comment of appliedComments) {\n+      const index = localText.toLowerCase().indexOf(comment.phrase.toLowerCase());\n+      if (index !== -1) {\n+        const start = index;\n+        const end = index + comment.phrase.length;\n \n-    // Trigger backend request and consume energy\n-    isAnalyzingRef.current = true;\n-    energyRef.current -= 40;\n-    const remainingEnergy = energyRef.current;\n-\n-    try {\n-      console.log(`üîç Calling backend analysis (consumed 40 energy, ${remainingEnergy} remaining)...`);\n-      console.log(`üìù Current voiceConfigs:`, voiceConfigs);\n-      // Convert frontend VoiceConfig to backend format\n-      const backendFormat: Record<string, any> = {};\n-      for (const [name, cfg] of Object.entries(voiceConfigs)) {\n-        if (cfg.enabled) {\n-          backendFormat[name] = {\n-            name: cfg.name,\n-            tagline: cfg.systemPrompt,\n-            icon: cfg.icon,\n-            color: cfg.color\n-          };\n+        // Check if cursor is inside this phrase\n+        if (cursorPosition >= start && cursorPosition <= end) {\n+          foundComment = comment;\n+          break;\n         }\n       }\n-      console.log(`üì§ Sending to backend:`, backendFormat);\n-      const result = await analyzeText(currentTextValue, sessionId, backendFormat);\n-      console.log(`‚úÖ Got ${result.voices.length} total voices (${result.new_voices_added} new from this LLM call)`);\n-\n-      // @@@ Energy refund mechanism - if LLM returns no NEW comments, refund 20 energy\n-      // This prevents wasting energy when nothing interesting is detected\n-      if (result.new_voices_added === 0) {\n-        energyRef.current += 20;\n-        console.log(`‚ôªÔ∏è  No new voices detected, refunded 20 energy ‚Üí ${energyRef.current} total`);\n-      }\n-\n-      setVoiceTriggers(result.voices);\n-      detectVoices(currentTextValue, result.voices);\n-    } catch (error) {\n-      console.error('‚ùå Voice analysis failed:', error);\n-    } finally {\n-      isAnalyzingRef.current = false;\n     }\n-  };\n \n-  // @@@ Reset weight baseline when switching back to writing view\n-  // Prevents energy accumulation from \"seeing\" the full text again\n-  useEffect(() => {\n-    if (currentView === 'writing' && editorRef.current) {\n-      const textForWeighting = editorRef.current.getTextWithoutQuotes() || currentTextRef.current;\n-      lastPollWeightRef.current = getWeightedLength(textForWeighting);\n-      console.log(`üîÑ Switched to writing view, reset baseline weight to ${lastPollWeightRef.current}`);\n+    if (!foundComment) return;\n+\n+    // Find which group this comment belongs to\n+    commentGroups.forEach((group, blockIndex) => {\n+      const commentIndex = group.comments.findIndex(c => c.id === foundComment!.id);\n+      if (commentIndex !== -1) {\n+        // Switch to this comment in the group\n+        setGroupPages(prev => {\n+          const next = new Map(prev);\n+          if (next.get(blockIndex) !== commentIndex) {\n+            next.set(blockIndex, commentIndex);\n+          }\n+          return next;\n+        });\n+      }\n+    });\n+  }, [cursorPosition, state, localText, commentGroups]);\n+\n+  // @@@ Handle text changes (with IME support)\n+  const handleTextChange = useCallback((newText: string) => {\n+    // Always update local text for the textarea\n+    setLocalText(newText);\n+    // Only update the engine when not composing\n+    if (!isComposing && engineRef.current) {\n+      engineRef.current.updateText(newText);\n     }\n-  }, [currentView]);\n-\n-  // @@@ Polling strategy - Check every 5 seconds (stable interval)\n-  // Must include voiceConfigs in deps so interval uses latest config\n-  // Only run when in writing view to prevent energy accumulation when switched away\n-  useEffect(() => {\n-    if (currentView !== 'writing') {\n-      return;\n+  }, [isComposing]);\n+\n+  const handleCompositionStart = useCallback(() => {\n+    setIsComposing(true);\n+  }, []);\n+\n+  const handleCompositionEnd = useCallback((e: React.CompositionEvent<HTMLTextAreaElement>) => {\n+    setIsComposing(false);\n+    const newText = e.currentTarget.value;\n+    setLocalText(newText);\n+    if (engineRef.current) {\n+      engineRef.current.updateText(newText);\n     }\n+  }, []);\n+\n+  // @@@ Handle paste events to ensure highlighting is triggered\n+  const handlePaste = useCallback((e: React.ClipboardEvent<HTMLTextAreaElement>) => {\n+    // Let the default paste happen, then update the engine\n+    setTimeout(() => {\n+      const newText = e.currentTarget.value;\n+      setLocalText(newText);\n+      if (engineRef.current) {\n+        engineRef.current.updateText(newText);\n+      }\n+    }, 0);\n+  }, []);\n \n-    const interval = setInterval(analyzeIfNeeded, 5000);\n-    return () => clearInterval(interval);\n-  }, [voiceConfigs, currentView]);\n+  // @@@ Handle cursor position changes\n+  const handleCursorChange = useCallback(() => {\n+    if (textareaRef.current) {\n+      setCursorPosition(textareaRef.current.selectionStart);\n+    }\n+  }, []);\n \n-  const handleTextChange = (newText: string) => {\n-    setCurrentText(newText);\n-    currentTextRef.current = newText;\n+  // @@@ Handle Start Fresh\n+  const handleStartFresh = useCallback(() => {\n+    if (confirm('Clear everything and start fresh? This will delete all your current writing and comments.')) {\n+      localStorage.removeItem('ink_memory_state');\n+      window.location.reload();\n+    }\n+  }, []);\n \n-    // Instantly update display with current triggers\n-    detectVoices(newText, voiceTriggers);\n-  };\n+  // @@@ Render text with highlights\n+  const renderHighlightedText = () => {\n+    if (!state) return null;\n \n-  const handleContentChange = (newHTML: string) => {\n-    setCurrentHTML(newHTML);\n+    const appliedComments = state.commentors.filter(c => c.appliedAt);\n \n-    // @@@ Update quoted comments list whenever content changes\n-    if (editorRef.current?.getQuotedComments) {\n-      setQuotedComments(editorRef.current.getQuotedComments());\n+    if (appliedComments.length === 0) {\n+      return <div style={{ whiteSpace: 'pre-wrap' }}>{localText}</div>;\n     }\n-  };\n \n-  const handleQuote = (voiceName: string, comment: string) => {\n-    // @@@ Insert atomic voice quote widget\n-    // Quotes are now special nodes that are automatically excluded from weight calculation\n-    if (editorRef.current?.insertVoiceQuote) {\n-      // Get voice config for this voice (for chat context)\n-      const voiceConfig = voiceConfigs[voiceName] || {\n-        tagline: `${voiceName} voice`\n+    // Create highlight ranges\n+    const highlights: Array<{ start: number; end: number; comment: Commentor }> = [];\n+    appliedComments.forEach(comment => {\n+      const index = localText.toLowerCase().indexOf(comment.phrase.toLowerCase());\n+      if (index !== -1) {\n+        highlights.push({\n+          start: index,\n+          end: index + comment.phrase.length,\n+          comment\n+        });\n+      }\n+    });\n+\n+    // Sort by start position\n+    highlights.sort((a, b) => a.start - b.start);\n+\n+    // Build highlighted text\n+    const elements: React.ReactNode[] = [];\n+    let lastEnd = 0;\n+\n+    // Get watercolor brush URL for color\n+    const getWatercolorBg = (color: string) => {\n+      const brushes: Record<string, string> = {\n+        yellow: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-9&color=ffff43)',\n+        blue: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-7&color=a3d5ff)',\n+        pink: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-8&color=ffb3d9)',\n+        green: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-6&color=b3ffb3)',\n+        purple: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-5&color=ddb3ff)'\n       };\n+      return brushes[color] || 'none';\n+    };\n+\n+    highlights.forEach((highlight, idx) => {\n+      // Add text before highlight\n+      if (highlight.start > lastEnd) {\n+        elements.push(\n+          <span key={`text-${idx}`}>\n+            {localText.substring(lastEnd, highlight.start)}\n+          </span>\n+        );\n+      }\n \n-      editorRef.current.insertVoiceQuote(voiceName, comment, {\n-        tagline: voiceConfig.systemPrompt,\n-        icon: voiceConfig.icon,\n-        color: voiceConfig.color\n-      });\n-    } else {\n-      console.error('insertVoiceQuote method not available on editorRef');\n-    }\n-  };\n+      // Add highlighted text with watercolor effect\n+      elements.push(\n+        <span\n+          key={`highlight-${idx}`}\n+          className=\"voice-highlight\"\n+          data-comment-id={highlight.comment.id}\n+          style={{\n+            margin: '-2px -6px',\n+            padding: '2px 6px',\n+            background: getWatercolorBg(highlight.comment.color),\n+            transition: 'all 0.2s ease'\n+          }}\n+        >\n+          {localText.substring(highlight.start, highlight.end)}\n+        </span>\n+      );\n+\n+      lastEnd = highlight.end;\n+    });\n \n-  // @@@ Re-detect voices when triggers change\n-  useEffect(() => {\n-    detectVoices(currentText, voiceTriggers);\n-  }, [voiceTriggers]);\n+    // Add remaining text\n+    if (lastEnd < localText.length) {\n+      elements.push(\n+        <span key=\"text-final\">\n+          {localText.substring(lastEnd)}\n+        </span>\n+      );\n+    }\n \n-  // @@@ Clear old triggers when voice config changes (e.g., Use Default)\n-  // This forces immediate re-analysis with new config\n-  useEffect(() => {\n-    // Skip on initial mount (voiceConfigs is empty)\n-    if (Object.keys(voiceConfigs).length === 0) return;\n+    return <div style={{ whiteSpace: 'pre-wrap' }}>{elements}</div>;\n+  };\n \n-    console.log('üîÑ Voice config changed, clearing old triggers and triggering immediate analysis');\n-    setVoiceTriggers([]);\n-    setVoices([]);\n+  if (!state || !engineRef.current) {\n+    return <div>Loading...</div>;\n+  }\n \n-    // Force immediate re-analysis (session ID ensures backend returns cached results)\n-    energyRef.current = 40;\n-    analyzeIfNeeded();\n-  }, [voiceConfigs]);\n+  const lastEntry = state.weightPath[state.weightPath.length - 1];\n+  const currentEnergy = lastEntry?.energy || 0;\n+  const usedEnergy = state.commentors.filter(c => c.appliedAt).length * 40;\n+  const unusedEnergy = currentEnergy - usedEnergy;\n+  const appliedComments = state.commentors.filter(c => c.appliedAt);\n \n   return (\n-    <>\n-      <LeftSidebar currentView={currentView} onViewChange={setCurrentView} />\n-      {currentView === 'writing' && (\n-        <div className=\"book-interface\">\n-          <WritingArea\n-            ref={editorRef}\n-            onChange={handleTextChange}\n-            onContentChange={handleContentChange}\n-            triggers={voiceTriggers}\n-            onCursorChange={setCursorPosition}\n-            onPhraseHover={setHoveredPhrase}\n-            content={currentHTML}\n-          />\n-          <VoicesPanel focusedVoiceIndex={focusedVoiceIndex}>\n-            {voices\n-              .filter(voice => {\n-                // @@@ Hide comments that are already quoted as widgets\n-                return !quotedComments.some(\n-                  quoted => quoted.voiceName === voice.name && quoted.comment === voice.text\n-                );\n-              })\n-              .map((voice, index) => {\n-                // @@@ Find the trigger phrase for this voice\n-                const trigger = voiceTriggers.find(t =>\n-                  t.voice === voice.name && t.comment === voice.text\n-                );\n-                const isHovered = hoveredPhrase !== null && trigger !== undefined &&\n-                  hoveredPhrase.toLowerCase() === trigger.phrase.toLowerCase();\n-\n-                return (\n-                  <VoiceComment\n-                    key={index}\n-                    voice={voice.name}\n-                    text={voice.text}\n-                    icon={voice.icon}\n-                    color={voice.color}\n-                    onQuote={() => handleQuote(voice.name, voice.text)}\n-                    isHovered={isHovered}\n-                  />\n-                );\n-              })}\n-          </VoicesPanel>\n-          <BinderRings />\n-        </div>\n-      )}\n-      {currentView === 'settings' && (\n-        <div style={{\n-          position: 'fixed',\n-          top: 48,\n-          left: 0,\n-          right: 0,\n-          bottom: 0,\n-          background: '#f8f0e6',\n-          display: 'flex',\n+    <div style={{\n+      display: 'flex',\n+      height: '100vh',\n+      fontFamily: 'system-ui, -apple-system, sans-serif'\n+    }}>\n+      {/* Left Toolbar */}\n+      <LeftToolbar onStartFresh={handleStartFresh} />\n+\n+      {/* Main Editor Area with Inline Comments */}\n+      <div\n+        ref={containerRef}\n+        style={{\n+          flex: 1,\n+          position: 'relative',\n           overflow: 'hidden'\n-        }}>\n-          <VoiceSettings\n-            defaultVoices={defaultVoiceConfigs}\n-            onSave={setVoiceConfigs}\n-          />\n-        </div>\n-      )}\n-      {currentView === 'calendar' && (\n+        }}\n+      >\n         <div style={{\n-          position: 'fixed',\n-          top: 48,\n-          left: 0,\n-          right: 0,\n-          bottom: 0,\n-          background: '#f8f0e6',\n+          height: '100%',\n           display: 'flex',\n-          overflow: 'hidden'\n+          flexDirection: 'column',\n+          width: '100%',\n+          margin: '0 auto'\n         }}>\n-          <CalendarView />\n+          {/* Status Bar */}\n+          <div style={{\n+            padding: '10px 20px',\n+            borderBottom: '1px solid #e0e0e0',\n+            fontSize: '12px',\n+            color: '#666',\n+            display: 'flex',\n+            gap: '20px',\n+            backgroundColor: '#fafafa'\n+          }}>\n+            <span>Energy: {unusedEnergy}/{currentEnergy}</span>\n+            <span>Weight: {lastEntry?.weight || 0}</span>\n+            <span>Applied: {appliedComments.length}</span>\n+            <span>Groups: {commentGroups.size}</span>\n+          </div>\n+\n+          {/* Writing Area with Comments */}\n+          <div style={{\n+            flex: 1,\n+            position: 'relative',\n+            overflow: 'auto',\n+            padding: '40px'\n+          }}>\n+            {/* Highlighted text overlay */}\n+            <div style={{\n+              position: 'absolute',\n+              top: '40px',\n+              left: '40px',\n+              right: '40px',\n+              maxWidth: '600px',\n+              pointerEvents: 'none',\n+              fontSize: '18px',\n+              lineHeight: '1.8',\n+              color: 'transparent',\n+              fontFamily: 'inherit'\n+            }}>\n+              {renderHighlightedText()}\n+            </div>\n+\n+            {/* Textarea */}\n+            <textarea\n+              ref={textareaRef}\n+              value={localText}\n+              onChange={(e) => handleTextChange(e.target.value)}\n+              onCompositionStart={handleCompositionStart}\n+              onCompositionEnd={handleCompositionEnd}\n+              onPaste={handlePaste}\n+              onSelect={handleCursorChange}\n+              onClick={handleCursorChange}\n+              onKeyUp={handleCursorChange}\n+              placeholder=\"Start writing...\"\n+              style={{\n+                width: '100%',\n+                maxWidth: '600px',\n+                minHeight: '100%',\n+                border: 'none',\n+                outline: 'none',\n+                resize: 'none',\n+                fontSize: '18px',\n+                lineHeight: '1.8',\n+                fontFamily: 'inherit',\n+                background: 'transparent',\n+                color: '#333',\n+                caretColor: '#333',\n+                position: 'relative',\n+                zIndex: 1\n+              }}\n+            />\n+\n+            {/* Comment Groups - positioned absolutely based on 2-row blocks */}\n+            {Array.from(commentGroups.entries()).map(([blockIndex, group]) => {\n+              const currentIndex = groupPages.get(blockIndex) || 0;\n+\n+              // Get actual padding values from the container\n+              const containerPadding = textareaRef.current?.parentElement ?\n+                parseFloat(window.getComputedStyle(textareaRef.current.parentElement).paddingLeft) || 40 : 40;\n+\n+              // Dynamic gap based on viewport size\n+              const gap = Math.max(30, window.innerWidth * 0.02); // Min 30px, scales with viewport\n+\n+              const leftPosition = containerPadding + group.maxLineWidth + gap;\n+\n+              return (\n+                <CommentGroupCard\n+                  key={blockIndex}\n+                  comments={group.comments}\n+                  currentIndex={currentIndex}\n+                  onNavigate={(idx) => handleGroupNavigate(blockIndex, idx)}\n+                  position={{\n+                    top: group.centerY + containerPadding,\n+                    left: leftPosition\n+                  }}\n+                />\n+              );\n+            })}\n+          </div>\n         </div>\n-      )}\n-      {currentView === 'analysis' && (\n-        <div style={{\n-          position: 'fixed',\n-          top: 48,\n-          left: 0,\n-          right: 0,\n-          bottom: 0,\n-          background: '#f8f0e6',\n-          display: 'flex',\n-          overflow: 'hidden'\n-        }}>\n-          <AnalysisView />\n-        </div>\n-      )}\n-      {currentView === 'about' && (\n-        <div style={{\n-          position: 'fixed',\n-          top: 48,\n-          left: 0,\n-          right: 0,\n-          bottom: 0,\n-          background: '#f8f0e6',\n-          display: 'flex',\n-          overflow: 'hidden'\n-        }}>\n-          <AboutView />\n-        </div>\n-      )}\n-    </>\n+      </div>\n+    </div>\n   );\n-}\n-\n-export default App\n\\ No newline at end of file\n+}\n\\ No newline at end of file"
    },
    {
      "sha": "a32e357e3cad482b25feeda64c393563a5eb2497",
      "filename": "frontend/src/AppSimplified.tsx",
      "status": "removed",
      "additions": 0,
      "deletions": 767,
      "changes": 767,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/a5dc1232b4cb102653a5ef9f6e129b1117f44ac4/frontend%2Fsrc%2FAppSimplified.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/a5dc1232b4cb102653a5ef9f6e129b1117f44ac4/frontend%2Fsrc%2FAppSimplified.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2FAppSimplified.tsx?ref=a5dc1232b4cb102653a5ef9f6e129b1117f44ac4",
      "patch": "@@ -1,767 +0,0 @@\n-import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\n-import { EditorEngine } from './engine/EditorEngine';\n-import type { EditorState, Commentor, TextCell } from './engine/EditorEngine';\n-import './App.css';\n-import {\n-  FaSync, FaBold, FaItalic, FaUnderline, FaAlignLeft, FaAlignCenter,\n-  FaAlignRight, FaListUl, FaListOl, FaQuoteRight, FaTable, FaLink, FaImage,\n-  FaBrain, FaHeart, FaQuestion, FaCloud, FaTheaterMasks, FaEye,\n-  FaFistRaised, FaLightbulb, FaShieldAlt, FaWind, FaFire, FaCompass\n-} from 'react-icons/fa';\n-\n-// @@@ Left Toolbar Component\n-function LeftToolbar({ onStartFresh }: { onStartFresh: () => void }) {\n-  const tools = [\n-    { icon: FaSync, tooltip: 'Start Fresh', action: onStartFresh, functional: true, separator: true },\n-    { icon: FaBold, tooltip: 'Bold', functional: false, separator: false },\n-    { icon: FaItalic, tooltip: 'Italic', functional: false, separator: false },\n-    { icon: FaUnderline, tooltip: 'Underline', functional: false, separator: true },\n-    { icon: FaAlignLeft, tooltip: 'Align Left', functional: false, separator: false },\n-    { icon: FaAlignCenter, tooltip: 'Align Center', functional: false, separator: false },\n-    { icon: FaAlignRight, tooltip: 'Align Right', functional: false, separator: true },\n-    { icon: FaListUl, tooltip: 'Bullet List', functional: false, separator: false },\n-    { icon: FaListOl, tooltip: 'Numbered List', functional: false, separator: true },\n-    { icon: FaQuoteRight, tooltip: 'Quote', functional: false, separator: false },\n-    { icon: FaTable, tooltip: 'Insert Table', functional: false, separator: false },\n-    { icon: FaLink, tooltip: 'Insert Link', functional: false, separator: false },\n-    { icon: FaImage, tooltip: 'Insert Image', functional: false, separator: false },\n-  ];\n-\n-  return (\n-    <div style={{\n-      width: '48px',\n-      borderRight: '1px solid #e0e0e0',\n-      backgroundColor: '#fafafa',\n-      display: 'flex',\n-      flexDirection: 'column',\n-      alignItems: 'center',\n-      paddingTop: '10px',\n-      gap: '4px'\n-    }}>\n-      {tools.map((tool, idx) => (\n-        <React.Fragment key={idx}>\n-          <button\n-            onClick={tool.functional ? tool.action : undefined}\n-            disabled={!tool.functional}\n-            title={tool.tooltip}\n-            style={{\n-              width: '36px',\n-              height: '36px',\n-              border: 'none',\n-              borderRadius: '4px',\n-              backgroundColor: tool.functional ? '#fff' : 'transparent',\n-              cursor: tool.functional ? 'pointer' : 'not-allowed',\n-              display: 'flex',\n-              alignItems: 'center',\n-              justifyContent: 'center',\n-              opacity: tool.functional ? 1 : 0.3,\n-              transition: 'all 0.2s ease',\n-              ...(tool.functional && {\n-                ':hover': {\n-                  backgroundColor: '#f0f0f0'\n-                }\n-              })\n-            }}\n-            onMouseEnter={tool.functional ? (e) => {\n-              e.currentTarget.style.backgroundColor = '#f0f0f0';\n-            } : undefined}\n-            onMouseLeave={tool.functional ? (e) => {\n-              e.currentTarget.style.backgroundColor = '#fff';\n-            } : undefined}\n-          >\n-            <tool.icon size={18} color={tool.functional ? '#333' : '#999'} />\n-          </button>\n-          {tool.separator && idx < tools.length - 1 && (\n-            <div style={{\n-              width: '30px',\n-              height: '1px',\n-              backgroundColor: '#e0e0e0',\n-              margin: '4px 0'\n-            }} />\n-          )}\n-        </React.Fragment>\n-      ))}\n-    </div>\n-  );\n-}\n-\n-// @@@ Icon map with React Icons (matching original)\n-const iconMap = {\n-  brain: FaBrain,\n-  heart: FaHeart,\n-  question: FaQuestion,\n-  cloud: FaCloud,\n-  masks: FaTheaterMasks,\n-  eye: FaEye,\n-  fist: FaFistRaised,\n-  lightbulb: FaLightbulb,\n-  shield: FaShieldAlt,\n-  wind: FaWind,\n-  fire: FaFire,\n-  compass: FaCompass,\n-};\n-\n-// @@@ Color map with gradient colors for watercolor effect (right to left fade)\n-const colorMap: Record<string, { gradient: string; text: string; glow: string }> = {\n-  blue: {\n-    gradient: 'linear-gradient(90deg, rgba(77,159,255,0) 0%, rgba(77,159,255,0.05) 30%, rgba(77,159,255,0.12) 60%, rgba(77,159,255,0.25) 100%)',\n-    text: '#0066cc',\n-    glow: 'rgba(77,159,255,0.15)'\n-  },\n-  pink: {\n-    gradient: 'linear-gradient(90deg, rgba(255,102,179,0) 0%, rgba(255,102,179,0.05) 30%, rgba(255,102,179,0.12) 60%, rgba(255,102,179,0.25) 100%)',\n-    text: '#cc0066',\n-    glow: 'rgba(255,102,179,0.15)'\n-  },\n-  yellow: {\n-    gradient: 'linear-gradient(90deg, rgba(255,221,51,0) 0%, rgba(255,221,51,0.05) 30%, rgba(255,221,51,0.12) 60%, rgba(255,221,51,0.25) 100%)',\n-    text: '#996600',\n-    glow: 'rgba(255,221,51,0.15)'\n-  },\n-  green: {\n-    gradient: 'linear-gradient(90deg, rgba(102,255,102,0) 0%, rgba(102,255,102,0.05) 30%, rgba(102,255,102,0.12) 60%, rgba(102,255,102,0.25) 100%)',\n-    text: '#006600',\n-    glow: 'rgba(102,255,102,0.15)'\n-  },\n-  purple: {\n-    gradient: 'linear-gradient(90deg, rgba(179,102,255,0) 0%, rgba(179,102,255,0.05) 30%, rgba(179,102,255,0.12) 60%, rgba(179,102,255,0.25) 100%)',\n-    text: '#6600cc',\n-    glow: 'rgba(179,102,255,0.15)'\n-  },\n-};\n-\n-// @@@ Group Comment Card Component - elegant gradient watercolor style\n-function CommentGroupCard({\n-  comments,\n-  currentIndex,\n-  onNavigate,\n-  position\n-}: {\n-  comments: Commentor[];\n-  currentIndex: number;\n-  onNavigate: (index: number) => void;\n-  position: { top: number; left: number };\n-}) {\n-  const [isHovered, setIsHovered] = React.useState(false);\n-\n-  if (comments.length === 0) return null;\n-\n-  // @@@ Bounds check - ensure currentIndex is valid\n-  const safeIndex = Math.min(Math.max(0, currentIndex), comments.length - 1);\n-  const currentComment = comments[safeIndex];\n-\n-  if (!currentComment) return null;\n-\n-  const Icon = iconMap[currentComment.icon as keyof typeof iconMap] || FaBrain;\n-  const colors = colorMap[currentComment.color] || colorMap.blue;\n-\n-  return (\n-    <div\n-      style={{\n-        position: 'absolute',\n-        top: `${position.top}px`,\n-        left: `${position.left}px`,\n-        transform: `translateY(-50%) ${isHovered ? 'scale(1.02)' : 'scale(1)'}`,\n-        minWidth: '200px',\n-        maxWidth: '400px',\n-        height: '54px', // Fixed 3 rows: ~18px per row\n-        padding: '8px 12px',\n-        background: colors.gradient,\n-        borderLeft: `2px solid ${colors.glow}`,\n-        borderRadius: '4px',\n-        fontSize: '13px',\n-        lineHeight: '1.4',\n-        zIndex: 10,\n-        cursor: comments.length > 1 ? 'pointer' : 'default',\n-        transition: 'all 0.2s ease',\n-        fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif',\n-        boxShadow: isHovered ? '0 4px 12px rgba(0,0,0,0.15)' : 'none',\n-        animation: 'slideInFromRight 0.3s ease-out',\n-      }}\n-      onClick={() => {\n-        // Click to cycle through comments (only if multiple)\n-        if (comments.length > 1) {\n-          onNavigate((safeIndex + 1) % comments.length);\n-        }\n-      }}\n-      onMouseEnter={() => setIsHovered(true)}\n-      onMouseLeave={() => setIsHovered(false)}\n-    >\n-      <div style={{\n-        display: 'flex',\n-        gap: '10px',\n-        height: '100%',\n-        alignItems: 'center'\n-      }}>\n-        {/* Icon with pagination counter below */}\n-        <div style={{\n-          display: 'flex',\n-          flexDirection: 'column',\n-          alignItems: 'center',\n-          justifyContent: 'center',\n-          flexShrink: 0,\n-          width: '24px'\n-        }}>\n-          <Icon size={15} color={colors.text} style={{ opacity: 0.75 }} />\n-          {comments.length > 1 && (\n-            <span style={{\n-              fontSize: '8px',\n-              color: colors.text,\n-              opacity: 0.5,\n-              marginTop: '1px',\n-              fontWeight: 500\n-            }}>\n-              {safeIndex + 1}/{comments.length}\n-            </span>\n-          )}\n-        </div>\n-\n-        {/* Voice name inline with comment */}\n-        <div style={{\n-          flex: 1,\n-          overflow: 'hidden',\n-          textOverflow: 'ellipsis',\n-          display: '-webkit-box',\n-          WebkitLineClamp: 3,\n-          WebkitBoxOrient: 'vertical',\n-          color: colors.text,\n-          opacity: 0.85\n-        }}>\n-          <strong style={{ fontWeight: 600 }}>{currentComment.voice}:</strong> {currentComment.comment}\n-        </div>\n-      </div>\n-    </div>\n-  );\n-}\n-\n-// @@@ Main App Component\n-export default function AppSimplified() {\n-  const engineRef = useRef<EditorEngine>();\n-  const [state, setState] = useState<EditorState | null>(null);\n-  const [localText, setLocalText] = useState(''); // Local text for textarea\n-  const [isComposing, setIsComposing] = useState(false);\n-  const [groupPages, setGroupPages] = useState<Map<number, number>>(new Map());\n-  const [cursorPosition, setCursorPosition] = useState<number>(0);\n-\n-  const textareaRef = useRef<HTMLTextAreaElement>(null);\n-  const containerRef = useRef<HTMLDivElement>(null);\n-\n-  // Initialize engine\n-  useEffect(() => {\n-    const sessionId = crypto.randomUUID ? crypto.randomUUID() : Date.now().toString();\n-    const engine = new EditorEngine(sessionId);\n-    engineRef.current = engine;\n-\n-    // Subscribe to state changes\n-    engine.subscribe((newState) => {\n-      setState({ ...newState });\n-      // Save to localStorage\n-      localStorage.setItem('ink_memory_inline_state', JSON.stringify(newState));\n-    });\n-\n-    // Load saved state if exists\n-    const saved = localStorage.getItem('ink_memory_inline_state');\n-    if (saved) {\n-      try {\n-        const parsed = JSON.parse(saved);\n-        engine.loadState(parsed);\n-\n-        // Load initial text and state together\n-        const textCell = parsed.cells?.find((c: any) => c.type === 'text');\n-        const initialText = textCell?.content || '';\n-\n-        setLocalText(initialText);\n-        setState(engine.getState());\n-\n-        // Double-check: force re-render after a tick to ensure everything is initialized\n-        setTimeout(() => {\n-          setLocalText(initialText);\n-          setState({ ...engine.getState() });\n-        }, 10);\n-      } catch (e) {\n-        console.error('Failed to load saved state:', e);\n-      }\n-    } else {\n-      setState(engine.getState());\n-    }\n-  }, []);\n-\n-  // Sync local text with state (when not composing)\n-  useEffect(() => {\n-    if (!isComposing && state) {\n-      const textCell = state.cells.find(c => c.type === 'text') as TextCell;\n-      if (textCell) {\n-        setLocalText(textCell.content || '');\n-      }\n-    }\n-  }, [state, isComposing]);\n-\n-  // @@@ Group comments by 2-row blocks using visual lines (accounting for wrapping)\n-  const commentGroups = useMemo(() => {\n-    const groups = new Map<number, {\n-      comments: Commentor[];\n-      blockIndex: number;\n-      visualLineStart: number;\n-      visualLineEnd: number;\n-      maxLineWidth: number;\n-      centerY: number;\n-    }>();\n-\n-    if (!textareaRef.current || !state) return groups;\n-\n-    const text = localText;\n-    const maxTextareaWidth = 600;\n-\n-    // Get actual line height from computed styles\n-    const computedStyle = window.getComputedStyle(textareaRef.current);\n-    const fontSize = parseFloat(computedStyle.fontSize) || 18;\n-    const lineHeightRatio = parseFloat(computedStyle.lineHeight) / fontSize || 1.8;\n-    const lineHeight = fontSize * lineHeightRatio;\n-\n-    // Create a temporary canvas to measure text width\n-    const canvas = document.createElement('canvas');\n-    const ctx = canvas.getContext('2d');\n-    if (ctx) {\n-      // Use actual font from computed styles\n-      const fontFamily = computedStyle.fontFamily || 'system-ui, -apple-system, sans-serif';\n-      ctx.font = `${fontSize}px ${fontFamily}`;\n-    }\n-\n-    // @@@ Build a map from character index to visual line number\n-    const charToVisualLine: number[] = new Array(text.length);\n-    let currentVisualLine = 0;\n-    let currentLineStartIndex = 0;\n-\n-    for (let i = 0; i < text.length; i++) {\n-      charToVisualLine[i] = currentVisualLine;\n-\n-      if (text[i] === '\\n') {\n-        // Hard line break - move to next visual line\n-        currentVisualLine++;\n-        currentLineStartIndex = i + 1;\n-      } else {\n-        // Check if we need to wrap\n-        const currentLineText = text.substring(currentLineStartIndex, i + 1);\n-        const width = ctx ? ctx.measureText(currentLineText).width : currentLineText.length * (fontSize * 0.6);\n-\n-        if (width > maxTextareaWidth && i > currentLineStartIndex) {\n-          // This character causes a wrap - move to next visual line\n-          currentVisualLine++;\n-          currentLineStartIndex = i;\n-          charToVisualLine[i] = currentVisualLine;\n-        }\n-      }\n-    }\n-\n-    // Process each commentor\n-    state.commentors\n-      .filter(c => c.appliedAt)\n-      .forEach(commentor => {\n-        const index = text.toLowerCase().indexOf(commentor.phrase.toLowerCase());\n-        if (index === -1) return;\n-\n-        // Get visual line number for this character position\n-        const visualLineNumber = charToVisualLine[index] || 0;\n-\n-        // Determine which 2-row block this belongs to (0-1, 2-3, 4-5, etc.)\n-        const blockIndex = Math.floor(visualLineNumber / 2);\n-        const visualLineStart = blockIndex * 2;\n-        const visualLineEnd = visualLineStart + 1;\n-\n-        if (!groups.has(blockIndex)) {\n-          // For visual lines, we can assume they're all ~700px wide (or less)\n-          // So maxWidth is just the width of the longer of the two visual lines in this block\n-          let maxWidth = 0;\n-\n-          // Find all text on these two visual lines\n-          for (let i = 0; i < text.length; i++) {\n-            const vLine = charToVisualLine[i];\n-            if (vLine === visualLineStart || vLine === visualLineEnd) {\n-              // Find the end of this visual line\n-              let lineEnd = i;\n-              while (lineEnd < text.length && charToVisualLine[lineEnd] === vLine) {\n-                lineEnd++;\n-              }\n-              const lineText = text.substring(i, lineEnd);\n-              const width = ctx ? ctx.measureText(lineText).width : lineText.length * (fontSize * 0.6);\n-              maxWidth = Math.max(maxWidth, Math.min(width, maxTextareaWidth));\n-              i = lineEnd - 1; // Skip to end of this visual line\n-            }\n-          }\n-\n-          // Calculate vertical center of the 2-row block\n-          const centerY = (visualLineStart + 1) * lineHeight;\n-\n-          groups.set(blockIndex, {\n-            comments: [],\n-            blockIndex,\n-            visualLineStart,\n-            visualLineEnd,\n-            maxLineWidth: maxWidth,\n-            centerY\n-          });\n-        }\n-\n-        groups.get(blockIndex)!.comments.push(commentor);\n-      });\n-\n-    return groups;\n-  }, [state?.commentors, localText, state]);\n-\n-  // @@@ Auto-switch to newest comment when group size changes\n-  useEffect(() => {\n-    if (!commentGroups) return;\n-\n-    setGroupPages(prev => {\n-      const next = new Map(prev);\n-\n-      // For each group, ensure the page index is valid\n-      commentGroups.forEach((group, blockIndex) => {\n-        if (group.comments.length === 0) {\n-          next.delete(blockIndex);\n-          return;\n-        }\n-\n-        const currentPage = prev.get(blockIndex) || 0;\n-        const maxPage = group.comments.length - 1;\n-\n-        // If we're on an old page and there are new comments, switch to the newest\n-        if (group.comments.length > 1 && currentPage < maxPage) {\n-          next.set(blockIndex, maxPage); // Show the newest comment\n-        } else if (currentPage > maxPage) {\n-          // Current page is out of bounds, reset to last valid page\n-          next.set(blockIndex, maxPage);\n-        }\n-      });\n-\n-      // Remove pages for groups that no longer exist\n-      prev.forEach((_, blockIndex) => {\n-        if (!commentGroups.has(blockIndex)) {\n-          next.delete(blockIndex);\n-        }\n-      });\n-\n-      return next;\n-    });\n-  }, [commentGroups]);\n-\n-  // @@@ Handle page navigation for comment groups\n-  const handleGroupNavigate = useCallback((blockIndex: number, newIndex: number) => {\n-    setGroupPages(prev => {\n-      const next = new Map(prev);\n-      next.set(blockIndex, newIndex);\n-      return next;\n-    });\n-  }, []);\n-\n-  // @@@ Detect which comment the cursor is inside and switch to it\n-  useEffect(() => {\n-    if (!state || !localText) return;\n-\n-    const appliedComments = state.commentors.filter(c => c.appliedAt);\n-    if (appliedComments.length === 0) return;\n-\n-    // Find which comment contains the cursor\n-    let foundComment: Commentor | null = null;\n-    for (const comment of appliedComments) {\n-      const index = localText.toLowerCase().indexOf(comment.phrase.toLowerCase());\n-      if (index !== -1) {\n-        const start = index;\n-        const end = index + comment.phrase.length;\n-\n-        // Check if cursor is inside this phrase\n-        if (cursorPosition >= start && cursorPosition <= end) {\n-          foundComment = comment;\n-          break;\n-        }\n-      }\n-    }\n-\n-    if (!foundComment) return;\n-\n-    // Find which group this comment belongs to\n-    commentGroups.forEach((group, blockIndex) => {\n-      const commentIndex = group.comments.findIndex(c => c.id === foundComment!.id);\n-      if (commentIndex !== -1) {\n-        // Switch to this comment in the group\n-        setGroupPages(prev => {\n-          const next = new Map(prev);\n-          if (next.get(blockIndex) !== commentIndex) {\n-            next.set(blockIndex, commentIndex);\n-          }\n-          return next;\n-        });\n-      }\n-    });\n-  }, [cursorPosition, state, localText, commentGroups]);\n-\n-  // @@@ Handle text changes (with IME support)\n-  const handleTextChange = useCallback((newText: string) => {\n-    // Always update local text for the textarea\n-    setLocalText(newText);\n-    // Only update the engine when not composing\n-    if (!isComposing && engineRef.current) {\n-      engineRef.current.updateText(newText);\n-    }\n-  }, [isComposing]);\n-\n-  const handleCompositionStart = useCallback(() => {\n-    setIsComposing(true);\n-  }, []);\n-\n-  const handleCompositionEnd = useCallback((e: React.CompositionEvent<HTMLTextAreaElement>) => {\n-    setIsComposing(false);\n-    const newText = e.currentTarget.value;\n-    setLocalText(newText);\n-    if (engineRef.current) {\n-      engineRef.current.updateText(newText);\n-    }\n-  }, []);\n-\n-  // @@@ Handle paste events to ensure highlighting is triggered\n-  const handlePaste = useCallback((e: React.ClipboardEvent<HTMLTextAreaElement>) => {\n-    // Let the default paste happen, then update the engine\n-    setTimeout(() => {\n-      const newText = e.currentTarget.value;\n-      setLocalText(newText);\n-      if (engineRef.current) {\n-        engineRef.current.updateText(newText);\n-      }\n-    }, 0);\n-  }, []);\n-\n-  // @@@ Handle cursor position changes\n-  const handleCursorChange = useCallback(() => {\n-    if (textareaRef.current) {\n-      setCursorPosition(textareaRef.current.selectionStart);\n-    }\n-  }, []);\n-\n-  // @@@ Handle Start Fresh\n-  const handleStartFresh = useCallback(() => {\n-    if (confirm('Clear everything and start fresh? This will delete all your current writing and comments.')) {\n-      localStorage.removeItem('ink_memory_inline_state');\n-      window.location.reload();\n-    }\n-  }, []);\n-\n-  // @@@ Render text with highlights\n-  const renderHighlightedText = () => {\n-    if (!state) return null;\n-\n-    const appliedComments = state.commentors.filter(c => c.appliedAt);\n-\n-    if (appliedComments.length === 0) {\n-      return <div style={{ whiteSpace: 'pre-wrap' }}>{localText}</div>;\n-    }\n-\n-    // Create highlight ranges\n-    const highlights: Array<{ start: number; end: number; comment: Commentor }> = [];\n-    appliedComments.forEach(comment => {\n-      const index = localText.toLowerCase().indexOf(comment.phrase.toLowerCase());\n-      if (index !== -1) {\n-        highlights.push({\n-          start: index,\n-          end: index + comment.phrase.length,\n-          comment\n-        });\n-      }\n-    });\n-\n-    // Sort by start position\n-    highlights.sort((a, b) => a.start - b.start);\n-\n-    // Build highlighted text\n-    const elements: React.ReactNode[] = [];\n-    let lastEnd = 0;\n-\n-    // Get watercolor brush URL for color\n-    const getWatercolorBg = (color: string) => {\n-      const brushes: Record<string, string> = {\n-        yellow: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-9&color=ffff43)',\n-        blue: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-7&color=a3d5ff)',\n-        pink: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-8&color=ffb3d9)',\n-        green: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-6&color=b3ffb3)',\n-        purple: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-5&color=ddb3ff)'\n-      };\n-      return brushes[color] || 'none';\n-    };\n-\n-    highlights.forEach((highlight, idx) => {\n-      // Add text before highlight\n-      if (highlight.start > lastEnd) {\n-        elements.push(\n-          <span key={`text-${idx}`}>\n-            {localText.substring(lastEnd, highlight.start)}\n-          </span>\n-        );\n-      }\n-\n-      // Add highlighted text with watercolor effect\n-      elements.push(\n-        <span\n-          key={`highlight-${idx}`}\n-          className=\"voice-highlight\"\n-          data-comment-id={highlight.comment.id}\n-          style={{\n-            margin: '-2px -6px',\n-            padding: '2px 6px',\n-            background: getWatercolorBg(highlight.comment.color),\n-            transition: 'all 0.2s ease'\n-          }}\n-        >\n-          {localText.substring(highlight.start, highlight.end)}\n-        </span>\n-      );\n-\n-      lastEnd = highlight.end;\n-    });\n-\n-    // Add remaining text\n-    if (lastEnd < localText.length) {\n-      elements.push(\n-        <span key=\"text-final\">\n-          {localText.substring(lastEnd)}\n-        </span>\n-      );\n-    }\n-\n-    return <div style={{ whiteSpace: 'pre-wrap' }}>{elements}</div>;\n-  };\n-\n-  if (!state || !engineRef.current) {\n-    return <div>Loading...</div>;\n-  }\n-\n-  const lastEntry = state.weightPath[state.weightPath.length - 1];\n-  const currentEnergy = lastEntry?.energy || 0;\n-  const usedEnergy = state.commentors.filter(c => c.appliedAt).length * 40;\n-  const unusedEnergy = currentEnergy - usedEnergy;\n-  const appliedComments = state.commentors.filter(c => c.appliedAt);\n-\n-  return (\n-    <div style={{\n-      display: 'flex',\n-      height: '100vh',\n-      fontFamily: 'system-ui, -apple-system, sans-serif'\n-    }}>\n-      {/* Left Toolbar */}\n-      <LeftToolbar onStartFresh={handleStartFresh} />\n-\n-      {/* Main Editor Area with Inline Comments */}\n-      <div\n-        ref={containerRef}\n-        style={{\n-          flex: 1,\n-          position: 'relative',\n-          overflow: 'hidden'\n-        }}\n-      >\n-        <div style={{\n-          height: '100%',\n-          display: 'flex',\n-          flexDirection: 'column',\n-          width: '100%',\n-          margin: '0 auto'\n-        }}>\n-          {/* Status Bar */}\n-          <div style={{\n-            padding: '10px 20px',\n-            borderBottom: '1px solid #e0e0e0',\n-            fontSize: '12px',\n-            color: '#666',\n-            display: 'flex',\n-            gap: '20px',\n-            backgroundColor: '#fafafa'\n-          }}>\n-            <span>Energy: {unusedEnergy}/{currentEnergy}</span>\n-            <span>Weight: {lastEntry?.weight || 0}</span>\n-            <span>Applied: {appliedComments.length}</span>\n-            <span>Groups: {commentGroups.size}</span>\n-          </div>\n-\n-          {/* Writing Area with Comments */}\n-          <div style={{\n-            flex: 1,\n-            position: 'relative',\n-            overflow: 'auto',\n-            padding: '40px'\n-          }}>\n-            {/* Highlighted text overlay */}\n-            <div style={{\n-              position: 'absolute',\n-              top: '40px',\n-              left: '40px',\n-              right: '40px',\n-              maxWidth: '600px',\n-              pointerEvents: 'none',\n-              fontSize: '18px',\n-              lineHeight: '1.8',\n-              color: 'transparent',\n-              fontFamily: 'inherit'\n-            }}>\n-              {renderHighlightedText()}\n-            </div>\n-\n-            {/* Textarea */}\n-            <textarea\n-              ref={textareaRef}\n-              value={localText}\n-              onChange={(e) => handleTextChange(e.target.value)}\n-              onCompositionStart={handleCompositionStart}\n-              onCompositionEnd={handleCompositionEnd}\n-              onPaste={handlePaste}\n-              onSelect={handleCursorChange}\n-              onClick={handleCursorChange}\n-              onKeyUp={handleCursorChange}\n-              placeholder=\"Start writing...\"\n-              style={{\n-                width: '100%',\n-                maxWidth: '600px',\n-                minHeight: '100%',\n-                border: 'none',\n-                outline: 'none',\n-                resize: 'none',\n-                fontSize: '18px',\n-                lineHeight: '1.8',\n-                fontFamily: 'inherit',\n-                background: 'transparent',\n-                color: '#333',\n-                caretColor: '#333',\n-                position: 'relative',\n-                zIndex: 1\n-              }}\n-            />\n-\n-            {/* Comment Groups - positioned absolutely based on 2-row blocks */}\n-            {Array.from(commentGroups.entries()).map(([blockIndex, group]) => {\n-              const currentIndex = groupPages.get(blockIndex) || 0;\n-\n-              // Get actual padding values from the container\n-              const containerPadding = textareaRef.current?.parentElement ?\n-                parseFloat(window.getComputedStyle(textareaRef.current.parentElement).paddingLeft) || 40 : 40;\n-\n-              // Dynamic gap based on viewport size\n-              const gap = Math.max(30, window.innerWidth * 0.02); // Min 30px, scales with viewport\n-\n-              const leftPosition = containerPadding + group.maxLineWidth + gap;\n-\n-              return (\n-                <CommentGroupCard\n-                  key={blockIndex}\n-                  comments={group.comments}\n-                  currentIndex={currentIndex}\n-                  onNavigate={(idx) => handleGroupNavigate(blockIndex, idx)}\n-                  position={{\n-                    top: group.centerY + containerPadding,\n-                    left: leftPosition\n-                  }}\n-                />\n-              );\n-            })}\n-          </div>\n-        </div>\n-      </div>\n-    </div>\n-  );\n-}\n\\ No newline at end of file"
    },
    {
      "sha": "3e319ff20994591c75c56d94bd4d28564dad1603",
      "filename": "frontend/src/engine/EditorEngine.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/2d3d70520cee9077fdc27b77ccff340a7e14093a/frontend%2Fsrc%2Fengine%2FEditorEngine.ts",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/2d3d70520cee9077fdc27b77ccff340a7e14093a/frontend%2Fsrc%2Fengine%2FEditorEngine.ts",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fengine%2FEditorEngine.ts?ref=2d3d70520cee9077fdc27b77ccff340a7e14093a",
      "patch": "@@ -152,7 +152,7 @@ export class EditorEngine {\n   }\n \n   // @@@ Check if we should send text for analysis\n-  private checkAnalysisTrigger(text: string, currentEnergy: number) {\n+  private checkAnalysisTrigger(text: string, _currentEnergy: number) {\n     const completedSentences = getCompletedSentences(text);\n \n     // Skip if no completed sentences or already requesting"
    },
    {
      "sha": "bef5202a32cbd0632c43de40f6e908532903fd42",
      "filename": "frontend/src/main.tsx",
      "status": "modified",
      "additions": 1,
      "deletions": 6,
      "changes": 7,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/2d3d70520cee9077fdc27b77ccff340a7e14093a/frontend%2Fsrc%2Fmain.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/2d3d70520cee9077fdc27b77ccff340a7e14093a/frontend%2Fsrc%2Fmain.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fmain.tsx?ref=2d3d70520cee9077fdc27b77ccff340a7e14093a",
      "patch": "@@ -2,14 +2,9 @@ import { StrictMode } from 'react'\n import { createRoot } from 'react-dom/client'\n import './index.css'\n import App from './App.tsx'\n-import AppSimplified from './AppSimplified.tsx'\n-\n-// @@@ Switch between original and simplified version\n-const useSimplified = window.location.hash === '#simple';\n-const AppComponent = useSimplified ? AppSimplified : App;\n \n createRoot(document.getElementById('root')!).render(\n   <StrictMode>\n-    <AppComponent />\n+    <App />\n   </StrictMode>,\n )"
    }
  ]
}