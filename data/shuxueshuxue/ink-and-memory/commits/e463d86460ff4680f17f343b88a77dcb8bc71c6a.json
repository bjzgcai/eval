{
  "sha": "e463d86460ff4680f17f343b88a77dcb8bc71c6a",
  "node_id": "C_kwDOP2Zrm9oAKGU0NjNkODY0NjBmZjQ2ODBmMTdmMzQzYjg4YTc3ZGNiOGJjNzFjNmE",
  "commit": {
    "author": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-11-13T10:01:58Z"
    },
    "committer": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-11-13T10:01:58Z"
    },
    "message": "Add CRUD functions for decks and voices\n\n- get_user_decks(): list all visible decks with voice counts\n- get_deck_with_voices(): full deck details + voices\n- create_deck(), update_deck(), delete_deck(): deck lifecycle\n- fork_deck(): copy system deck to user deck (with all voices)\n- create_voice(), update_voice(), delete_voice(): voice lifecycle\n- fork_voice(): copy voice to user deck\n\nAll functions enforce ownership checks for security.\nTested with comprehensive test_crud.py (9 test cases).",
    "tree": {
      "sha": "d802b8c473eee0d8481cc2c2f8d3a84c2da4ad36",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/trees/d802b8c473eee0d8481cc2c2f8d3a84c2da4ad36"
    },
    "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/commits/e463d86460ff4680f17f343b88a77dcb8bc71c6a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null,
      "verified_at": null
    }
  },
  "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/e463d86460ff4680f17f343b88a77dcb8bc71c6a",
  "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/e463d86460ff4680f17f343b88a77dcb8bc71c6a",
  "comments_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/e463d86460ff4680f17f343b88a77dcb8bc71c6a/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "1ce3b33ea7170210c58eabd481e7b31694c630a5",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/1ce3b33ea7170210c58eabd481e7b31694c630a5",
      "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/1ce3b33ea7170210c58eabd481e7b31694c630a5"
    }
  ],
  "stats": {
    "total": 384,
    "additions": 384,
    "deletions": 0
  },
  "files": [
    {
      "sha": "9703ef0321338bc5089a10e3b4aa2882e02563d7",
      "filename": ".gitignore",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/e463d86460ff4680f17f343b88a77dcb8bc71c6a/.gitignore",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/e463d86460ff4680f17f343b88a77dcb8bc71c6a/.gitignore",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/.gitignore?ref=e463d86460ff4680f17f343b88a77dcb8bc71c6a",
      "patch": "@@ -3,6 +3,7 @@ backend/.venv/\n backend/models.json\n backend/.polycache/\n backend/benchmark/\n+backend/test_crud.py\n __pycache__/\n *.pyc\n AGENTS.md"
    },
    {
      "sha": "7cbb8dbebbe4dd11ffb393ba5b6a1d4906502e87",
      "filename": "backend/database.py",
      "status": "modified",
      "additions": 383,
      "deletions": 0,
      "changes": 383,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/e463d86460ff4680f17f343b88a77dcb8bc71c6a/backend%2Fdatabase.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/e463d86460ff4680f17f343b88a77dcb8bc71c6a/backend%2Fdatabase.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fdatabase.py?ref=e463d86460ff4680f17f343b88a77dcb8bc71c6a",
      "patch": "@@ -287,6 +287,389 @@ def seed_system_decks():\n     db.close()\n     print(\"âœ… System decks seeded (3 decks, 16 voices)\")\n \n+# ========== Deck CRUD ==========\n+\n+def get_user_decks(user_id: int):\n+    \"\"\"\n+    Get all decks visible to user (system decks + user's own decks).\n+    Returns list of deck dicts with voice counts.\n+    \"\"\"\n+    db = get_db()\n+    try:\n+        rows = db.execute(\"\"\"\n+        SELECT d.*, COUNT(v.id) as voice_count\n+        FROM decks d\n+        LEFT JOIN voices v ON d.id = v.deck_id AND v.enabled = 1\n+        WHERE d.is_system = 1 OR d.owner_id = ?\n+        GROUP BY d.id\n+        ORDER BY d.order_index, d.created_at\n+        \"\"\", (user_id,)).fetchall()\n+        return [dict(row) for row in rows]\n+    finally:\n+        db.close()\n+\n+def get_deck_with_voices(user_id: int, deck_id: str):\n+    \"\"\"\n+    Get full deck details with all voices.\n+    Returns None if deck doesn't exist or user doesn't have access.\n+    \"\"\"\n+    db = get_db()\n+    try:\n+        # Get deck\n+        deck_row = db.execute(\"\"\"\n+        SELECT * FROM decks\n+        WHERE id = ? AND (is_system = 1 OR owner_id = ?)\n+        \"\"\", (deck_id, user_id)).fetchone()\n+\n+        if not deck_row:\n+            return None\n+\n+        deck = dict(deck_row)\n+\n+        # Get voices in this deck\n+        voice_rows = db.execute(\"\"\"\n+        SELECT * FROM voices\n+        WHERE deck_id = ?\n+        ORDER BY order_index, created_at\n+        \"\"\", (deck_id,)).fetchall()\n+\n+        deck['voices'] = [dict(row) for row in voice_rows]\n+        return deck\n+    finally:\n+        db.close()\n+\n+def create_deck(user_id: int, name: str, description: str = None,\n+                name_zh: str = None, name_en: str = None,\n+                description_zh: str = None, description_en: str = None,\n+                icon: str = None, color: str = None,\n+                order_index: int = None) -> str:\n+    \"\"\"\n+    Create a new user deck. Returns deck_id.\n+    \"\"\"\n+    import uuid\n+\n+    db = get_db()\n+    try:\n+        deck_id = str(uuid.uuid4())\n+\n+        # Get max order_index if not provided\n+        if order_index is None:\n+            max_order = db.execute(\n+                \"SELECT MAX(order_index) as max_order FROM decks WHERE owner_id = ?\",\n+                (user_id,)\n+            ).fetchone()['max_order']\n+            order_index = (max_order or 0) + 1\n+\n+        db.execute(\"\"\"\n+        INSERT INTO decks (id, name, name_zh, name_en, description, description_zh, description_en,\n+                          icon, color, is_system, owner_id, enabled, order_index)\n+        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 0, ?, 1, ?)\n+        \"\"\", (deck_id, name, name_zh, name_en, description, description_zh, description_en,\n+              icon, color, user_id, order_index))\n+\n+        db.commit()\n+        return deck_id\n+    finally:\n+        db.close()\n+\n+def update_deck(user_id: int, deck_id: str, updates: dict) -> bool:\n+    \"\"\"\n+    Update a user's deck. Only works if user owns the deck.\n+    Returns True if updated, False if not found or permission denied.\n+\n+    Updates dict can contain: name, name_zh, name_en, description, description_zh,\n+    description_en, icon, color, enabled, order_index\n+    \"\"\"\n+    db = get_db()\n+    try:\n+        # Check ownership\n+        deck = db.execute(\n+            \"SELECT owner_id FROM decks WHERE id = ?\",\n+            (deck_id,)\n+        ).fetchone()\n+\n+        if not deck or deck['owner_id'] != user_id:\n+            return False\n+\n+        # Build update query\n+        allowed_fields = ['name', 'name_zh', 'name_en', 'description', 'description_zh',\n+                         'description_en', 'icon', 'color', 'enabled', 'order_index']\n+\n+        update_fields = []\n+        params = []\n+        for field in allowed_fields:\n+            if field in updates:\n+                update_fields.append(f\"{field} = ?\")\n+                params.append(updates[field])\n+\n+        if not update_fields:\n+            return True  # No updates\n+\n+        update_fields.append(\"updated_at = CURRENT_TIMESTAMP\")\n+        params.append(deck_id)\n+\n+        db.execute(\n+            f\"UPDATE decks SET {', '.join(update_fields)} WHERE id = ?\",\n+            params\n+        )\n+        db.commit()\n+        return True\n+    finally:\n+        db.close()\n+\n+def delete_deck(user_id: int, deck_id: str) -> bool:\n+    \"\"\"\n+    Delete a user's deck. Only works if user owns the deck.\n+    Cascades to delete all voices in the deck.\n+    Returns True if deleted, False if not found or permission denied.\n+    \"\"\"\n+    db = get_db()\n+    try:\n+        # Check ownership\n+        deck = db.execute(\n+            \"SELECT owner_id FROM decks WHERE id = ?\",\n+            (deck_id,)\n+        ).fetchone()\n+\n+        if not deck or deck['owner_id'] != user_id:\n+            return False\n+\n+        db.execute(\"DELETE FROM decks WHERE id = ?\", (deck_id,))\n+        db.commit()\n+        return True\n+    finally:\n+        db.close()\n+\n+def fork_deck(user_id: int, deck_id: str) -> str:\n+    \"\"\"\n+    Fork a deck (usually system deck) to create user's own copy.\n+    Copies deck + all voices. Returns new deck_id.\n+    \"\"\"\n+    import uuid\n+\n+    db = get_db()\n+    try:\n+        # Get source deck\n+        source_deck = db.execute(\"SELECT * FROM decks WHERE id = ?\", (deck_id,)).fetchone()\n+        if not source_deck:\n+            raise ValueError(f\"Deck {deck_id} not found\")\n+\n+        # Create new deck ID\n+        new_deck_id = str(uuid.uuid4())\n+\n+        # Copy deck\n+        db.execute(\"\"\"\n+        INSERT INTO decks (id, name, name_zh, name_en, description, description_zh, description_en,\n+                          icon, color, is_system, parent_id, owner_id, enabled, order_index)\n+        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 0, ?, ?, 1, ?)\n+        \"\"\", (new_deck_id,\n+              source_deck['name'],\n+              source_deck['name_zh'],\n+              source_deck['name_en'],\n+              source_deck['description'],\n+              source_deck['description_zh'],\n+              source_deck['description_en'],\n+              source_deck['icon'],\n+              source_deck['color'],\n+              deck_id,  # parent_id tracks fork source\n+              user_id,\n+              source_deck['order_index']))\n+\n+        # Copy all voices\n+        source_voices = db.execute(\n+            \"SELECT * FROM voices WHERE deck_id = ? ORDER BY order_index\",\n+            (deck_id,)\n+        ).fetchall()\n+\n+        for voice in source_voices:\n+            new_voice_id = str(uuid.uuid4())\n+            db.execute(\"\"\"\n+            INSERT INTO voices (id, deck_id, name, name_zh, name_en, system_prompt,\n+                              icon, color, is_system, parent_id, owner_id, enabled, order_index)\n+            VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0, ?, ?, 1, ?)\n+            \"\"\", (new_voice_id,\n+                  new_deck_id,\n+                  voice['name'],\n+                  voice['name_zh'],\n+                  voice['name_en'],\n+                  voice['system_prompt'],\n+                  voice['icon'],\n+                  voice['color'],\n+                  voice['id'],  # parent_id tracks fork source\n+                  user_id,\n+                  voice['order_index']))\n+\n+        db.commit()\n+        return new_deck_id\n+    finally:\n+        db.close()\n+\n+# ========== Voice CRUD ==========\n+\n+def create_voice(user_id: int, deck_id: str, name: str, system_prompt: str,\n+                name_zh: str = None, name_en: str = None,\n+                icon: str = None, color: str = None,\n+                order_index: int = None) -> str:\n+    \"\"\"\n+    Create a new voice in a user's deck.\n+    Returns voice_id.\n+    \"\"\"\n+    import uuid\n+\n+    db = get_db()\n+    try:\n+        # Check deck ownership\n+        deck = db.execute(\n+            \"SELECT owner_id FROM decks WHERE id = ?\",\n+            (deck_id,)\n+        ).fetchone()\n+\n+        if not deck or deck['owner_id'] != user_id:\n+            raise ValueError(\"Deck not found or permission denied\")\n+\n+        voice_id = str(uuid.uuid4())\n+\n+        # Get max order_index if not provided\n+        if order_index is None:\n+            max_order = db.execute(\n+                \"SELECT MAX(order_index) as max_order FROM voices WHERE deck_id = ?\",\n+                (deck_id,)\n+            ).fetchone()['max_order']\n+            order_index = (max_order or 0) + 1\n+\n+        db.execute(\"\"\"\n+        INSERT INTO voices (id, deck_id, name, name_zh, name_en, system_prompt,\n+                           icon, color, is_system, owner_id, enabled, order_index)\n+        VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0, ?, 1, ?)\n+        \"\"\", (voice_id, deck_id, name, name_zh, name_en, system_prompt,\n+              icon, color, user_id, order_index))\n+\n+        db.commit()\n+        return voice_id\n+    finally:\n+        db.close()\n+\n+def update_voice(user_id: int, voice_id: str, updates: dict) -> bool:\n+    \"\"\"\n+    Update a user's voice. Only works if user owns the voice.\n+    Returns True if updated, False if not found or permission denied.\n+\n+    Updates dict can contain: name, name_zh, name_en, system_prompt,\n+    icon, color, enabled, order_index\n+    \"\"\"\n+    db = get_db()\n+    try:\n+        # Check ownership\n+        voice = db.execute(\n+            \"SELECT owner_id FROM voices WHERE id = ?\",\n+            (voice_id,)\n+        ).fetchone()\n+\n+        if not voice or voice['owner_id'] != user_id:\n+            return False\n+\n+        # Build update query\n+        allowed_fields = ['name', 'name_zh', 'name_en', 'system_prompt',\n+                         'icon', 'color', 'enabled', 'order_index']\n+\n+        update_fields = []\n+        params = []\n+        for field in allowed_fields:\n+            if field in updates:\n+                update_fields.append(f\"{field} = ?\")\n+                params.append(updates[field])\n+\n+        if not update_fields:\n+            return True  # No updates\n+\n+        update_fields.append(\"updated_at = CURRENT_TIMESTAMP\")\n+        params.append(voice_id)\n+\n+        db.execute(\n+            f\"UPDATE voices SET {', '.join(update_fields)} WHERE id = ?\",\n+            params\n+        )\n+        db.commit()\n+        return True\n+    finally:\n+        db.close()\n+\n+def delete_voice(user_id: int, voice_id: str) -> bool:\n+    \"\"\"\n+    Delete a user's voice. Only works if user owns the voice.\n+    Returns True if deleted, False if not found or permission denied.\n+    \"\"\"\n+    db = get_db()\n+    try:\n+        # Check ownership\n+        voice = db.execute(\n+            \"SELECT owner_id FROM voices WHERE id = ?\",\n+            (voice_id,)\n+        ).fetchone()\n+\n+        if not voice or voice['owner_id'] != user_id:\n+            return False\n+\n+        db.execute(\"DELETE FROM voices WHERE id = ?\", (voice_id,))\n+        db.commit()\n+        return True\n+    finally:\n+        db.close()\n+\n+def fork_voice(user_id: int, voice_id: str, target_deck_id: str) -> str:\n+    \"\"\"\n+    Fork a voice to a user's deck.\n+    Returns new voice_id.\n+    \"\"\"\n+    import uuid\n+\n+    db = get_db()\n+    try:\n+        # Check target deck ownership\n+        deck = db.execute(\n+            \"SELECT owner_id FROM decks WHERE id = ?\",\n+            (target_deck_id,)\n+        ).fetchone()\n+\n+        if not deck or deck['owner_id'] != user_id:\n+            raise ValueError(\"Target deck not found or permission denied\")\n+\n+        # Get source voice\n+        source_voice = db.execute(\"SELECT * FROM voices WHERE id = ?\", (voice_id,)).fetchone()\n+        if not source_voice:\n+            raise ValueError(f\"Voice {voice_id} not found\")\n+\n+        # Create new voice\n+        new_voice_id = str(uuid.uuid4())\n+\n+        # Get max order_index in target deck\n+        max_order = db.execute(\n+            \"SELECT MAX(order_index) as max_order FROM voices WHERE deck_id = ?\",\n+            (target_deck_id,)\n+        ).fetchone()['max_order']\n+        order_index = (max_order or 0) + 1\n+\n+        db.execute(\"\"\"\n+        INSERT INTO voices (id, deck_id, name, name_zh, name_en, system_prompt,\n+                           icon, color, is_system, parent_id, owner_id, enabled, order_index)\n+        VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0, ?, ?, 1, ?)\n+        \"\"\", (new_voice_id,\n+              target_deck_id,\n+              source_voice['name'],\n+              source_voice['name_zh'],\n+              source_voice['name_en'],\n+              source_voice['system_prompt'],\n+              source_voice['icon'],\n+              source_voice['color'],\n+              voice_id,  # parent_id tracks fork source\n+              user_id,\n+              order_index))\n+\n+        db.commit()\n+        return new_voice_id\n+    finally:\n+        db.close()\n+\n # ========== User Management ==========\n \n def create_user(email: str, password_hash: str, display_name: str = None) -> int:"
    }
  ]
}