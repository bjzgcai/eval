{
  "sha": "865f495b6bcade3ef1f5344d1ce769c5fc0197fc",
  "node_id": "C_kwDOP2Zrm9oAKDg2NWY0OTViNmJjYWRlM2VmMWY1MzQ0ZDFjZTc2OWM1ZmMwMTk3ZmM",
  "commit": {
    "author": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-11-05T03:43:43Z"
    },
    "committer": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-11-05T03:43:43Z"
    },
    "message": "Add notebook-style ruled lines and 3D state cube with quaternion rotation\n\nFeatures:\n- Notebook ruled lines with subtle horizontal lines and left margin\n- 3D state cube component with 6 faces (9 states per face)\n- Quaternion-based rotation (no gimbal lock)\n- Smooth trackball-style drag interaction\n- Auto-snap to nearest face with slerp animation\n- Progressive unlock system (currently 1 face unlocked)\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude <noreply@anthropic.com>",
    "tree": {
      "sha": "d5294994258d44b5ea36381404aa938fc4c4bf44",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/trees/d5294994258d44b5ea36381404aa938fc4c4bf44"
    },
    "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/commits/865f495b6bcade3ef1f5344d1ce769c5fc0197fc",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null,
      "verified_at": null
    }
  },
  "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/865f495b6bcade3ef1f5344d1ce769c5fc0197fc",
  "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/865f495b6bcade3ef1f5344d1ce769c5fc0197fc",
  "comments_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/865f495b6bcade3ef1f5344d1ce769c5fc0197fc/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "e6da5ee76c7ec78e9b510f256048f38860583c6b",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/e6da5ee76c7ec78e9b510f256048f38860583c6b",
      "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/e6da5ee76c7ec78e9b510f256048f38860583c6b"
    }
  ],
  "stats": {
    "total": 511,
    "additions": 509,
    "deletions": 2
  },
  "files": [
    {
      "sha": "97b85a7e51540a77e213e68e092866363fa284cf",
      "filename": "frontend/src/App.css",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/865f495b6bcade3ef1f5344d1ce769c5fc0197fc/frontend%2Fsrc%2FApp.css",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/865f495b6bcade3ef1f5344d1ce769c5fc0197fc/frontend%2Fsrc%2FApp.css",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2FApp.css?ref=865f495b6bcade3ef1f5344d1ce769c5fc0197fc",
      "patch": "@@ -226,6 +226,22 @@\n   background: url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-5&color=ddb3ff);\n }\n \n+/* @@@ Notebook ruled lines background */\n+.notebook-lines {\n+  background-image:\n+    /* Vertical margin line (left) */\n+    linear-gradient(to right, transparent 0, transparent 39px, rgba(255, 100, 100, 0.15) 40px, rgba(255, 100, 100, 0.15) 41px, transparent 41px),\n+    /* Horizontal ruled lines */\n+    repeating-linear-gradient(\n+      transparent,\n+      transparent 31.4px,\n+      rgba(170, 170, 180, 0.2) 31.4px,\n+      rgba(170, 170, 180, 0.2) 32.4px\n+    );\n+  background-size: 100% 100%;\n+  background-position: 0 0;\n+}\n+\n /* Scrollbar styling for simplified version */\n .writing-textarea::-webkit-scrollbar,\n .comments-panel::-webkit-scrollbar {"
    },
    {
      "sha": "ad4de094a8512d8512fe6202057b371001b94c40",
      "filename": "frontend/src/App.tsx",
      "status": "modified",
      "additions": 7,
      "deletions": 2,
      "changes": 9,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/865f495b6bcade3ef1f5344d1ce769c5fc0197fc/frontend%2Fsrc%2FApp.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/865f495b6bcade3ef1f5344d1ce769c5fc0197fc/frontend%2Fsrc%2FApp.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2FApp.tsx?ref=865f495b6bcade3ef1f5344d1ce769c5fc0197fc",
      "patch": "@@ -20,6 +20,7 @@ import AboutView from './components/AboutView';\n import AgentDropdown from './components/AgentDropdown';\n import ChatWidgetUI from './components/ChatWidgetUI';\n import StateChooser from './components/StateChooser';\n+import { StateCube } from './components/StateCube';\n import type { VoiceConfig, StateConfig } from './types/voice';\n import { getVoices, getMetaPrompt, getStateConfig } from './utils/voiceStorage';\n import { getDefaultVoices, chatWithVoice, importLocalData } from './api/voiceApi';\n@@ -1715,12 +1716,13 @@ export default function App() {\n               width: '100%',\n               margin: '0 auto'\n             }}>\n-              <div style={{\n+              <div className=\"notebook-lines\" style={{\n                 flex: 1,\n                 position: 'relative',\n                 overflow: 'auto',\n                 padding: '20px',\n-                paddingBottom: '80px'  // Extra space for smooth scrolling to bottom\n+                paddingBottom: '80px',  // Extra space for smooth scrolling to bottom\n+                backgroundColor: '#fffef9'  // @@@ Cream paper background for notebook lines\n               }}>\n                 <div style={{\n                   position: 'relative',\n@@ -2153,6 +2155,9 @@ export default function App() {\n           onClose={() => setShowCalendarPopup(false)}\n         />\n       )}\n+\n+      {/* @@@ TEMPORARY: 3D State Cube for testing */}\n+      <StateCube />\n     </>\n   );\n }"
    },
    {
      "sha": "8597a53a175aa1427d81600fadf8cf4eff320e60",
      "filename": "frontend/src/components/StateCube.tsx",
      "status": "added",
      "additions": 486,
      "deletions": 0,
      "changes": 486,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/865f495b6bcade3ef1f5344d1ce769c5fc0197fc/frontend%2Fsrc%2Fcomponents%2FStateCube.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/865f495b6bcade3ef1f5344d1ce769c5fc0197fc/frontend%2Fsrc%2Fcomponents%2FStateCube.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FStateCube.tsx?ref=865f495b6bcade3ef1f5344d1ce769c5fc0197fc",
      "patch": "@@ -0,0 +1,486 @@\n+import React, { useState, useRef, useEffect } from 'react';\n+\n+interface State {\n+  id: string;\n+  cn: string;\n+  en: string;\n+  locked: boolean;\n+}\n+\n+interface CubeFace {\n+  name: string;\n+  states: State[];\n+  unlocked: boolean;\n+  color: string;\n+}\n+\n+// @@@ Quaternion class for smooth 3D rotation\n+class Quaternion {\n+  constructor(\n+    public w: number,\n+    public x: number,\n+    public y: number,\n+    public z: number\n+  ) {}\n+\n+  static identity(): Quaternion {\n+    return new Quaternion(1, 0, 0, 0);\n+  }\n+\n+  static fromAxisAngle(axis: { x: number; y: number; z: number }, angle: number): Quaternion {\n+    const halfAngle = angle / 2;\n+    const s = Math.sin(halfAngle);\n+    return new Quaternion(\n+      Math.cos(halfAngle),\n+      axis.x * s,\n+      axis.y * s,\n+      axis.z * s\n+    );\n+  }\n+\n+  multiply(q: Quaternion): Quaternion {\n+    return new Quaternion(\n+      this.w * q.w - this.x * q.x - this.y * q.y - this.z * q.z,\n+      this.w * q.x + this.x * q.w + this.y * q.z - this.z * q.y,\n+      this.w * q.y - this.x * q.z + this.y * q.w + this.z * q.x,\n+      this.w * q.z + this.x * q.y - this.y * q.x + this.z * q.w\n+    );\n+  }\n+\n+  normalize(): Quaternion {\n+    const mag = Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);\n+    return new Quaternion(this.w / mag, this.x / mag, this.y / mag, this.z / mag);\n+  }\n+\n+  // @@@ Spherical linear interpolation for smooth animation\n+  slerp(target: Quaternion, t: number): Quaternion {\n+    let { w, x, y, z } = this;\n+    let { w: tw, x: tx, y: ty, z: tz } = target;\n+\n+    // Compute dot product\n+    let dot = w * tw + x * tx + y * ty + z * tz;\n+\n+    // If dot is negative, negate one quaternion to take shorter path\n+    if (dot < 0) {\n+      w = -w; x = -x; y = -y; z = -z;\n+      dot = -dot;\n+    }\n+\n+    // If quaternions are very close, use linear interpolation\n+    if (dot > 0.9995) {\n+      const result = new Quaternion(\n+        w + t * (tw - w),\n+        x + t * (tx - x),\n+        y + t * (ty - y),\n+        z + t * (tz - z)\n+      );\n+      return result.normalize();\n+    }\n+\n+    // Use slerp\n+    const theta = Math.acos(dot);\n+    const sinTheta = Math.sin(theta);\n+    const a = Math.sin((1 - t) * theta) / sinTheta;\n+    const b = Math.sin(t * theta) / sinTheta;\n+\n+    return new Quaternion(\n+      w * a + tw * b,\n+      x * a + tx * b,\n+      y * a + ty * b,\n+      z * a + tz * b\n+    );\n+  }\n+\n+  toRotationMatrix(): string {\n+    const { w, x, y, z } = this;\n+\n+    const m00 = 1 - 2 * (y * y + z * z);\n+    const m01 = 2 * (x * y - w * z);\n+    const m02 = 2 * (x * z + w * y);\n+\n+    const m10 = 2 * (x * y + w * z);\n+    const m11 = 1 - 2 * (x * x + z * z);\n+    const m12 = 2 * (y * z - w * x);\n+\n+    const m20 = 2 * (x * z - w * y);\n+    const m21 = 2 * (y * z + w * x);\n+    const m22 = 1 - 2 * (x * x + y * y);\n+\n+    return `matrix3d(${m00},${m10},${m20},0,${m01},${m11},${m21},0,${m02},${m12},${m22},0,0,0,0,1)`;\n+  }\n+\n+  // @@@ Transform a vector by this quaternion's rotation\n+  transformVector(v: { x: number; y: number; z: number }): { x: number; y: number; z: number } {\n+    const { w, x, y, z } = this;\n+    const { x: vx, y: vy, z: vz } = v;\n+\n+    // q * v * q^-1\n+    const ix = w * vx + y * vz - z * vy;\n+    const iy = w * vy + z * vx - x * vz;\n+    const iz = w * vz + x * vy - y * vx;\n+    const iw = -x * vx - y * vy - z * vz;\n+\n+    return {\n+      x: ix * w + iw * -x + iy * -z - iz * -y,\n+      y: iy * w + iw * -y + iz * -x - ix * -z,\n+      z: iz * w + iw * -z + ix * -y - iy * -x\n+    };\n+  }\n+}\n+\n+// @@@ Canonical orientations for each face (facing camera)\n+const FACE_ORIENTATIONS: Record<string, Quaternion> = {\n+  front: Quaternion.identity(),\n+  back: Quaternion.fromAxisAngle({ x: 0, y: 1, z: 0 }, Math.PI),\n+  left: Quaternion.fromAxisAngle({ x: 0, y: 1, z: 0 }, Math.PI / 2),\n+  right: Quaternion.fromAxisAngle({ x: 0, y: 1, z: 0 }, -Math.PI / 2),\n+  top: Quaternion.fromAxisAngle({ x: 1, y: 0, z: 0 }, Math.PI / 2),  // Swapped\n+  bottom: Quaternion.fromAxisAngle({ x: 1, y: 0, z: 0 }, -Math.PI / 2)  // Swapped\n+};\n+\n+export function StateCube() {\n+  const [rotation, setRotation] = useState(() => FACE_ORIENTATIONS.front);\n+  const [isDragging, setIsDragging] = useState(false);\n+  const [isSnapping, setIsSnapping] = useState(false);\n+  const dragStartRef = useRef({ x: 0, y: 0, rotation: Quaternion.identity() });\n+  const snapAnimationRef = useRef<number | null>(null);\n+\n+  // @@@ Define 6 faces with 9 states each\n+  const faces: CubeFace[] = [\n+    {\n+      name: 'front',\n+      unlocked: true,\n+      color: '#a3d5ff',\n+      states: [\n+        { id: 'calm', cn: 'Âπ≥Èùô', en: 'Calm', locked: false },\n+        { id: 'focused', cn: '‰∏ìÊ≥®', en: 'Focused', locked: false },\n+        { id: 'joyful', cn: 'ÊÑâÊÇ¶', en: 'Joyful', locked: false },\n+        { id: 'confused', cn: 'Âõ∞ÊÉë', en: 'Confused', locked: false },\n+        { id: 'tired', cn: 'Áñ≤ÊÉ´', en: 'Tired', locked: false },\n+        { id: 'curious', cn: 'Â•ΩÂ•á', en: 'Curious', locked: false },\n+        { id: 'anxious', cn: 'ÁÑ¶Ëôë', en: 'Anxious', locked: false },\n+        { id: 'angry', cn: 'ÊÑ§ÊÄí', en: 'Angry', locked: false },\n+        { id: 'sad', cn: 'ÊÇ≤‰º§', en: 'Sad', locked: false },\n+      ]\n+    },\n+    {\n+      name: 'back',\n+      unlocked: false,\n+      color: '#ffb3d9',\n+      states: Array(9).fill(null).map((_, i) => ({\n+        id: `back-${i}`,\n+        cn: 'üîí',\n+        en: 'Locked',\n+        locked: true\n+      }))\n+    },\n+    {\n+      name: 'left',\n+      unlocked: false,\n+      color: '#b3ffb3',\n+      states: Array(9).fill(null).map((_, i) => ({\n+        id: `left-${i}`,\n+        cn: 'üîí',\n+        en: 'Locked',\n+        locked: true\n+      }))\n+    },\n+    {\n+      name: 'right',\n+      unlocked: false,\n+      color: '#ffff43',\n+      states: Array(9).fill(null).map((_, i) => ({\n+        id: `right-${i}`,\n+        cn: 'üîí',\n+        en: 'Locked',\n+        locked: true\n+      }))\n+    },\n+    {\n+      name: 'top',\n+      unlocked: false,\n+      color: '#ddb3ff',\n+      states: Array(9).fill(null).map((_, i) => ({\n+        id: `top-${i}`,\n+        cn: 'üîí',\n+        en: 'Locked',\n+        locked: true\n+      }))\n+    },\n+    {\n+      name: 'bottom',\n+      unlocked: false,\n+      color: '#ffd4a3',\n+      states: Array(9).fill(null).map((_, i) => ({\n+        id: `bottom-${i}`,\n+        cn: 'üîí',\n+        en: 'Locked',\n+        locked: true\n+      }))\n+    }\n+  ];\n+\n+  const handleMouseDown = (e: React.MouseEvent) => {\n+    setIsDragging(true);\n+    dragStartRef.current = {\n+      x: e.clientX,\n+      y: e.clientY,\n+      rotation: rotation\n+    };\n+  };\n+\n+  const handleMouseMove = (e: MouseEvent) => {\n+    if (!isDragging) return;\n+\n+    const deltaX = e.clientX - dragStartRef.current.x;\n+    const deltaY = e.clientY - dragStartRef.current.y;\n+\n+    // @@@ Convert screen-space drag to rotation axis and angle\n+    const sensitivity = 0.005;\n+    const angle = Math.sqrt(deltaX * deltaX + deltaY * deltaY) * sensitivity;\n+\n+    if (angle > 0.0001) {\n+      // Rotation axis perpendicular to drag direction (in screen space)\n+      // deltaY ‚Üí rotation around X axis, deltaX ‚Üí rotation around Y axis\n+      const axis = {\n+        x: -deltaY,\n+        y: deltaX,\n+        z: 0\n+      };\n+\n+      // Normalize axis\n+      const axisMag = Math.sqrt(axis.x * axis.x + axis.y * axis.y);\n+      if (axisMag > 0) {\n+        axis.x /= axisMag;\n+        axis.y /= axisMag;\n+      }\n+\n+      // Create delta quaternion and multiply with start rotation\n+      const deltaQuat = Quaternion.fromAxisAngle(axis, angle);\n+      const newRotation = deltaQuat.multiply(dragStartRef.current.rotation).normalize();\n+      setRotation(newRotation);\n+    }\n+  };\n+\n+  // @@@ Find the nearest canonical face orientation\n+  const findNearestFace = (currentRotation: Quaternion): { name: string; orientation: Quaternion } => {\n+    let maxDot = -Infinity;\n+    let nearestFace = 'front';\n+    let nearestOrientation = FACE_ORIENTATIONS.front;\n+\n+    // Camera direction (looking at cube from user's perspective)\n+    const cameraDir = { x: 0, y: 0, z: 1 };\n+\n+    // Face normals in their local space (each face points toward +Z in its local coords)\n+    const faceNormals: Record<string, { x: number; y: number; z: number }> = {\n+      front: { x: 0, y: 0, z: 1 },\n+      back: { x: 0, y: 0, z: -1 },\n+      left: { x: -1, y: 0, z: 0 },\n+      right: { x: 1, y: 0, z: 0 },\n+      top: { x: 0, y: 1, z: 0 },\n+      bottom: { x: 0, y: -1, z: 0 }\n+    };\n+\n+    for (const [faceName, faceOrientation] of Object.entries(FACE_ORIENTATIONS)) {\n+      // Get which direction this face is pointing in current rotation\n+      const localNormal = faceNormals[faceName];\n+      const worldNormal = currentRotation.transformVector(localNormal);\n+\n+      // Dot product: how much does this face point toward camera?\n+      const dot = worldNormal.x * cameraDir.x +\n+                  worldNormal.y * cameraDir.y +\n+                  worldNormal.z * cameraDir.z;\n+\n+      if (dot > maxDot) {\n+        maxDot = dot;\n+        nearestFace = faceName;\n+        nearestOrientation = faceOrientation;\n+      }\n+    }\n+\n+    return { name: nearestFace, orientation: nearestOrientation };\n+  };\n+\n+  // @@@ Animate snap to target orientation\n+  const snapToFace = (targetOrientation: Quaternion) => {\n+    if (snapAnimationRef.current !== null) {\n+      cancelAnimationFrame(snapAnimationRef.current);\n+    }\n+\n+    const startRotation = rotation;\n+    const startTime = performance.now();\n+    const duration = 500; // ms\n+\n+    const animate = (currentTime: number) => {\n+      const elapsed = currentTime - startTime;\n+      const t = Math.min(elapsed / duration, 1);\n+\n+      // Ease-out cubic\n+      const eased = 1 - Math.pow(1 - t, 3);\n+\n+      const interpolated = startRotation.slerp(targetOrientation, eased);\n+      setRotation(interpolated);\n+\n+      if (t < 1) {\n+        snapAnimationRef.current = requestAnimationFrame(animate);\n+      } else {\n+        setIsSnapping(false);\n+        snapAnimationRef.current = null;\n+      }\n+    };\n+\n+    setIsSnapping(true);\n+    snapAnimationRef.current = requestAnimationFrame(animate);\n+  };\n+\n+  const handleMouseUp = () => {\n+    setIsDragging(false);\n+\n+    // @@@ Snap to nearest face\n+    const { orientation } = findNearestFace(rotation);\n+    snapToFace(orientation);\n+  };\n+\n+  useEffect(() => {\n+    if (isDragging) {\n+      window.addEventListener('mousemove', handleMouseMove);\n+      window.addEventListener('mouseup', handleMouseUp);\n+      return () => {\n+        window.removeEventListener('mousemove', handleMouseMove);\n+        window.removeEventListener('mouseup', handleMouseUp);\n+      };\n+    }\n+  }, [isDragging, rotation]);\n+\n+  // @@@ Cleanup animation on unmount\n+  useEffect(() => {\n+    return () => {\n+      if (snapAnimationRef.current !== null) {\n+        cancelAnimationFrame(snapAnimationRef.current);\n+      }\n+    };\n+  }, []);\n+\n+  const renderFace = (face: CubeFace, transform: string) => {\n+    return (\n+      <div\n+        style={{\n+          position: 'absolute',\n+          width: '300px',\n+          height: '300px',\n+          transform,\n+          backfaceVisibility: 'hidden',\n+          background: face.unlocked\n+            ? `linear-gradient(135deg, ${face.color}40, ${face.color}80)`\n+            : 'linear-gradient(135deg, #ccc, #999)',\n+          border: '2px solid rgba(0,0,0,0.1)',\n+          borderRadius: '8px',\n+          padding: '10px',\n+          boxSizing: 'border-box',\n+          display: 'grid',\n+          gridTemplateColumns: 'repeat(3, 1fr)',\n+          gridTemplateRows: 'repeat(3, 1fr)',\n+          gap: '8px'\n+        }}\n+      >\n+        {face.states.map((state, idx) => (\n+          <div\n+            key={state.id}\n+            style={{\n+              background: state.locked\n+                ? 'rgba(255,255,255,0.3)'\n+                : 'rgba(255,255,255,0.6)',\n+              borderRadius: '4px',\n+              padding: '8px',\n+              display: 'flex',\n+              flexDirection: 'column',\n+              alignItems: 'center',\n+              justifyContent: 'center',\n+              fontSize: '12px',\n+              fontFamily: \"'Excalifont', 'Xiaolai', sans-serif\",\n+              cursor: state.locked ? 'not-allowed' : 'pointer',\n+              transition: 'all 0.2s ease',\n+              opacity: state.locked ? 0.5 : 1,\n+              userSelect: 'none'\n+            }}\n+            onMouseEnter={(e) => {\n+              if (!state.locked) {\n+                e.currentTarget.style.transform = 'scale(1.05)';\n+                e.currentTarget.style.background = 'rgba(255,255,255,0.9)';\n+              }\n+            }}\n+            onMouseLeave={(e) => {\n+              e.currentTarget.style.transform = 'scale(1)';\n+              e.currentTarget.style.background = state.locked\n+                ? 'rgba(255,255,255,0.3)'\n+                : 'rgba(255,255,255,0.6)';\n+            }}\n+          >\n+            <div style={{ fontWeight: 600, marginBottom: '2px' }}>\n+              {state.cn}\n+            </div>\n+            <div style={{ fontSize: '10px', opacity: 0.7 }}>\n+              {state.en}\n+            </div>\n+          </div>\n+        ))}\n+      </div>\n+    );\n+  };\n+\n+  return (\n+    <div\n+      style={{\n+        position: 'fixed',\n+        top: '50%',\n+        left: '50%',\n+        transform: 'translate(-50%, -50%)',\n+        perspective: '1200px',\n+        cursor: isDragging ? 'grabbing' : 'grab',\n+        userSelect: 'none',\n+        zIndex: 1000\n+      }}\n+      onMouseDown={handleMouseDown}\n+    >\n+      <div\n+        style={{\n+          width: '300px',\n+          height: '300px',\n+          position: 'relative',\n+          transformStyle: 'preserve-3d',\n+          transform: rotation.toRotationMatrix(),\n+          transition: (isDragging || isSnapping) ? 'none' : 'transform 0.3s ease-out'\n+        }}\n+      >\n+        {/* Front face */}\n+        {renderFace(faces[0], 'translateZ(150px)')}\n+\n+        {/* Back face */}\n+        {renderFace(faces[1], 'translateZ(-150px) rotateY(180deg)')}\n+\n+        {/* Left face */}\n+        {renderFace(faces[2], 'rotateY(-90deg) translateZ(150px)')}\n+\n+        {/* Right face */}\n+        {renderFace(faces[3], 'rotateY(90deg) translateZ(150px)')}\n+\n+        {/* Top face */}\n+        {renderFace(faces[4], 'rotateX(90deg) translateZ(150px)')}\n+\n+        {/* Bottom face */}\n+        {renderFace(faces[5], 'rotateX(-90deg) translateZ(150px)')}\n+      </div>\n+\n+      {/* Instruction text */}\n+      <div style={{\n+        marginTop: '20px',\n+        textAlign: 'center',\n+        color: '#666',\n+        fontSize: '14px',\n+        fontFamily: \"'Excalifont', 'Xiaolai', sans-serif\"\n+      }}>\n+        ÊãñÊãΩÊóãËΩ¨Êü•Áúã 6 ‰∏™Èù¢ ¬∑ Drag to rotate\n+      </div>\n+    </div>\n+  );\n+}"
    }
  ]
}