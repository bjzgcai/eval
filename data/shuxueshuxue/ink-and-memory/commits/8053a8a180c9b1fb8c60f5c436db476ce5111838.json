{
  "sha": "8053a8a180c9b1fb8c60f5c436db476ce5111838",
  "node_id": "C_kwDOP2Zrm9oAKDgwNTNhOGExODBjOWIxZmI4YzYwZjVjNDM2ZGI0NzZjZTUxMTE4Mzg",
  "commit": {
    "author": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-11-04T15:50:15Z"
    },
    "committer": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-11-04T15:50:15Z"
    },
    "message": "Fix voice key/name confusion - use key as single source of truth\n\nProblem: Custom voice comments failed when replying with error\n\"Voice config not found for ComposureAI\" because backend returned\ndisplay name but frontend expected key for voiceConfigs lookup.\n\nSolution: Establish key as single source of truth throughout system.\n\nBackend changes:\n- stateless_analyzer.py: Return archetype_key instead of name\n- server.py: Add database session persistence and authentication\n- database.py: Add user authentication schema\n\nFrontend changes:\n- App.tsx: Pass voiceConfigs to CommentCard and CollectionsView\n- CommentCard.tsx: Accept voiceConfigs, display names via lookup\n- CollectionsView.tsx: Accept voiceConfigs, display names in timeline\n- EditorEngine.ts: Update Commentor.voice comment to clarify key usage\n- voiceApi.ts: Update API endpoints\n- AnalysisView.tsx, CalendarPopup.tsx: Minor updates\n- VoiceSettings.tsx: Voice management updates\n\nNow comment.voice stores key, frontend looks up name for display.\nFixes reply functionality for custom voices.\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude <noreply@anthropic.com>",
    "tree": {
      "sha": "da6a9b589f62be226b6d1345388c15f68c0a974a",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/trees/da6a9b589f62be226b6d1345388c15f68c0a974a"
    },
    "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/commits/8053a8a180c9b1fb8c60f5c436db476ce5111838",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null,
      "verified_at": null
    }
  },
  "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/8053a8a180c9b1fb8c60f5c436db476ce5111838",
  "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/8053a8a180c9b1fb8c60f5c436db476ce5111838",
  "comments_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/8053a8a180c9b1fb8c60f5c436db476ce5111838/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "9cc1c217bbec2341af2597442fd758c96fa92a8a",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/9cc1c217bbec2341af2597442fd758c96fa92a8a",
      "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/9cc1c217bbec2341af2597442fd758c96fa92a8a"
    }
  ],
  "stats": {
    "total": 628,
    "additions": 516,
    "deletions": 112
  },
  "files": [
    {
      "sha": "e8b3a210c16cfc3daa1e2b1c28cbc069c685d049",
      "filename": "backend/database.py",
      "status": "modified",
      "additions": 101,
      "deletions": 12,
      "changes": 113,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/8053a8a180c9b1fb8c60f5c436db476ce5111838/backend%2Fdatabase.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/8053a8a180c9b1fb8c60f5c436db476ce5111838/backend%2Fdatabase.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fdatabase.py?ref=8053a8a180c9b1fb8c60f5c436db476ce5111838",
      "patch": "@@ -50,6 +50,10 @@ def init_db():\n         migrate_v1(db)\n     if current_version < 2:\n         migrate_v2(db)\n+    if current_version < 3:\n+        migrate_v3(db)\n+    if current_version < 4:\n+        migrate_v4(db)\n \n     db.commit()\n     db.close()\n@@ -166,6 +170,60 @@ def migrate_v2(db):\n \n     print(\"‚úÖ Migration v2 completed\")\n \n+def migrate_v3(db):\n+    \"\"\"Add thumbnail_base64 field to daily_pictures.\"\"\"\n+    print(\"üì¶ Running migration v3: Add thumbnail support for images\")\n+\n+    # Add thumbnail_base64 column to daily_pictures\n+    db.execute(\"\"\"\n+    ALTER TABLE daily_pictures ADD COLUMN thumbnail_base64 TEXT\n+    \"\"\")\n+\n+    # Record migration\n+    db.execute(\"INSERT INTO schema_version (version) VALUES (3)\")\n+\n+    print(\"‚úÖ Migration v3 completed\")\n+\n+def migrate_v4(db):\n+    \"\"\"Remove UNIQUE constraint on (user_id, date) to allow multiple pictures per day.\"\"\"\n+    print(\"üì¶ Running migration v4: Allow multiple pictures per day\")\n+\n+    # @@@ SQLite doesn't support DROP CONSTRAINT, so we need to recreate the table\n+    # Create new table without UNIQUE constraint\n+    db.execute(\"\"\"\n+    CREATE TABLE daily_pictures_new (\n+      id INTEGER PRIMARY KEY AUTOINCREMENT,\n+      user_id INTEGER NOT NULL,\n+      date TEXT NOT NULL,\n+      image_base64 TEXT NOT NULL,\n+      prompt TEXT,\n+      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n+      thumbnail_base64 TEXT,\n+      FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE\n+    )\n+    \"\"\")\n+\n+    # Copy all data from old table to new table\n+    db.execute(\"\"\"\n+    INSERT INTO daily_pictures_new (id, user_id, date, image_base64, prompt, created_at, thumbnail_base64)\n+    SELECT id, user_id, date, image_base64, prompt, created_at, thumbnail_base64\n+    FROM daily_pictures\n+    \"\"\")\n+\n+    # Drop old table\n+    db.execute(\"DROP TABLE daily_pictures\")\n+\n+    # Rename new table to original name\n+    db.execute(\"ALTER TABLE daily_pictures_new RENAME TO daily_pictures\")\n+\n+    # Recreate index (without UNIQUE constraint)\n+    db.execute(\"CREATE INDEX idx_pictures_user_date ON daily_pictures(user_id, date)\")\n+\n+    # Record migration\n+    db.execute(\"INSERT INTO schema_version (version) VALUES (4)\")\n+\n+    print(\"‚úÖ Migration v4 completed\")\n+\n # ========== User Management ==========\n \n def create_user(email: str, password_hash: str, display_name: str = None) -> int:\n@@ -219,7 +277,7 @@ def save_session(user_id: int, session_id: str, editor_state: dict, name: str =\n         VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)\n         ON CONFLICT(id) DO UPDATE SET\n           editor_state_json = excluded.editor_state_json,\n-          name = excluded.name,\n+          name = COALESCE(excluded.name, name),\n           updated_at = CURRENT_TIMESTAMP\n         \"\"\", (session_id, user_id, name, json.dumps(editor_state)))\n         db.commit()\n@@ -270,33 +328,64 @@ def delete_session(user_id: int, session_id: str):\n \n # ========== Daily Pictures ==========\n \n-def save_daily_picture(user_id: int, date: str, image_base64: str, prompt: str = None):\n-    \"\"\"Save or update daily picture.\"\"\"\n+def save_daily_picture(user_id: int, date: str, image_base64: str, prompt: str = None, thumbnail_base64: str = None):\n+    \"\"\"Save daily picture (replaces any existing picture for this user+date).\"\"\"\n     db = get_db()\n     try:\n+        # @@@ Delete old pictures for this user+date combination first\n+        # This ensures only ONE picture per day while avoiding UNIQUE constraint timezone issues\n         db.execute(\"\"\"\n-        INSERT INTO daily_pictures (user_id, date, image_base64, prompt)\n-        VALUES (?, ?, ?, ?)\n-        ON CONFLICT(user_id, date) DO UPDATE SET\n-          image_base64 = excluded.image_base64,\n-          prompt = excluded.prompt\n-        \"\"\", (user_id, date, image_base64, prompt))\n+        DELETE FROM daily_pictures\n+        WHERE user_id = ? AND date = ?\n+        \"\"\", (user_id, date))\n+\n+        # Insert the new picture\n+        db.execute(\"\"\"\n+        INSERT INTO daily_pictures (user_id, date, image_base64, thumbnail_base64, prompt)\n+        VALUES (?, ?, ?, ?, ?)\n+        \"\"\", (user_id, date, image_base64, thumbnail_base64, prompt))\n+\n         db.commit()\n     finally:\n         db.close()\n \n def get_daily_pictures(user_id: int, limit: int = 30):\n-    \"\"\"Get recent daily pictures.\"\"\"\n+    \"\"\"Get recent daily pictures (returns ONLY thumbnails for fast timeline loading).\"\"\"\n     db = get_db()\n     try:\n+        # @@@ Use COALESCE to return thumbnail, fallback to full image only if needed\n+        # This prevents loading full images when thumbnails exist\n         rows = db.execute(\"\"\"\n-        SELECT date, image_base64, prompt, created_at\n+        SELECT date, COALESCE(thumbnail_base64, image_base64) as base64, prompt, created_at\n         FROM daily_pictures\n         WHERE user_id = ?\n         ORDER BY date DESC\n         LIMIT ?\n         \"\"\", (user_id, limit)).fetchall()\n-        return [dict(row) for row in rows]\n+        return [{\n+            'date': row['date'],\n+            'base64': row['base64'],\n+            'prompt': row['prompt'] or '',\n+            'created_at': row['created_at']\n+        } for row in rows]\n+    finally:\n+        db.close()\n+\n+def get_daily_picture_full(user_id: int, date: str):\n+    \"\"\"Get full resolution image for a specific date (on-demand loading).\"\"\"\n+    db = get_db()\n+    try:\n+        row = db.execute(\"\"\"\n+        SELECT image_base64\n+        FROM daily_pictures\n+        WHERE user_id = ? AND date = ?\n+        ORDER BY created_at DESC\n+        LIMIT 1\n+        \"\"\", (user_id, date)).fetchone()\n+\n+        if row:\n+            return row['image_base64']\n+        return None\n     finally:\n         db.close()\n "
    },
    {
      "sha": "c6e0ed3f4dc456756041f3639be423bad5fb99db",
      "filename": "backend/server.py",
      "status": "modified",
      "additions": 75,
      "deletions": 12,
      "changes": 87,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/8053a8a180c9b1fb8c60f5c436db476ce5111838/backend%2Fserver.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/8053a8a180c9b1fb8c60f5c436db476ce5111838/backend%2Fserver.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fserver.py?ref=8053a8a180c9b1fb8c60f5c436db476ce5111838",
      "patch": "@@ -408,13 +408,56 @@ def generate_daily_picture(all_notes: str):\n                         # Extract base64 data (without the data URI prefix)\n                         base64_data = image_data.split(',', 1)[1]\n \n-                        print(f\"‚úÖ Image generated successfully\")\n-                        print(f\"   Size: {len(base64_data)} chars\")\n-\n-                        return {\n-                            \"image_base64\": base64_data,\n-                            \"prompt\": image_description  # Return the creative description\n-                        }\n+                        # @@@ Convert to JPEG and create thumbnail\n+                        try:\n+                            import base64\n+                            from io import BytesIO\n+                            from PIL import Image\n+\n+                            # Decode PNG\n+                            img_bytes = base64.b64decode(base64_data)\n+                            img = Image.open(BytesIO(img_bytes))\n+\n+                            # Convert to RGB (JPEG doesn't support transparency)\n+                            if img.mode in ('RGBA', 'LA', 'P'):\n+                                rgb_img = Image.new('RGB', img.size, (255, 255, 255))\n+                                if img.mode == 'RGBA':\n+                                    rgb_img.paste(img, mask=img.split()[-1])\n+                                else:\n+                                    rgb_img.paste(img)\n+                                img = rgb_img\n+\n+                            # Full JPEG (quality 85)\n+                            full_output = BytesIO()\n+                            img.save(full_output, format='JPEG', quality=85, optimize=True)\n+                            full_jpeg = base64.b64encode(full_output.getvalue()).decode('utf-8')\n+\n+                            # Thumbnail JPEG (400px width, quality 60)\n+                            thumb_width = 400\n+                            thumb_height = int(img.height * (thumb_width / img.width))\n+                            thumb_img = img.resize((thumb_width, thumb_height), Image.Resampling.LANCZOS)\n+\n+                            thumb_output = BytesIO()\n+                            thumb_img.save(thumb_output, format='JPEG', quality=60, optimize=True)\n+                            thumb_jpeg = base64.b64encode(thumb_output.getvalue()).decode('utf-8')\n+\n+                            print(f\"‚úÖ Image generated successfully\")\n+                            print(f\"   Original PNG: {len(base64_data)} chars\")\n+                            print(f\"   Full JPEG: {len(full_jpeg)} chars ({100 * len(full_jpeg) / len(base64_data):.1f}%)\")\n+                            print(f\"   Thumbnail: {len(thumb_jpeg)} chars ({100 * len(thumb_jpeg) / len(base64_data):.1f}%)\")\n+\n+                            return {\n+                                \"image_base64\": full_jpeg,\n+                                \"thumbnail_base64\": thumb_jpeg,\n+                                \"prompt\": image_description\n+                            }\n+                        except Exception as e:\n+                            print(f\"‚ö†Ô∏è JPEG conversion failed: {e}, using original PNG\")\n+                            return {\n+                                \"image_base64\": base64_data,\n+                                \"thumbnail_base64\": base64_data,  # Fallback to full image\n+                                \"prompt\": image_description\n+                            }\n \n             if attempt < config.IMAGE_RETRY_MAX_ATTEMPTS:\n                 print(f\"‚ö†Ô∏è No image in response, retrying...\")\n@@ -837,7 +880,7 @@ def get_pictures(\n     current_user: dict = Depends(get_current_user)\n ):\n     \"\"\"\n-    Get recent daily pictures for current user.\n+    Get recent daily pictures for current user (thumbnails only for fast loading).\n \n     Query params:\n     - limit: Max number of pictures to return (default 30)\n@@ -846,6 +889,25 @@ def get_pictures(\n     pictures = database.get_daily_pictures(user_id, limit)\n     return {\"pictures\": pictures}\n \n+@app.get(\"/api/pictures/{date}/full\")\n+def get_picture_full(\n+    date: str,\n+    current_user: dict = Depends(get_current_user)\n+):\n+    \"\"\"\n+    Get full resolution image for a specific date (on-demand loading).\n+\n+    Path params:\n+    - date: Date in YYYY-MM-DD format\n+    \"\"\"\n+    user_id = current_user['user_id']\n+    full_image = database.get_daily_picture_full(user_id, date)\n+\n+    if not full_image:\n+        raise HTTPException(status_code=404, detail=\"Picture not found for this date\")\n+\n+    return {\"image_base64\": full_image}\n+\n @app.post(\"/api/pictures\")\n def save_picture(\n     request: dict,\n@@ -864,12 +926,13 @@ def save_picture(\n     user_id = current_user['user_id']\n     date = request.get('date')\n     image_base64 = request.get('image_base64')\n+    thumbnail_base64 = request.get('thumbnail_base64')\n     prompt = request.get('prompt', '')\n \n     if not date or not image_base64:\n         raise HTTPException(status_code=400, detail=\"date and image_base64 required\")\n \n-    database.save_daily_picture(user_id, date, image_base64, prompt)\n+    database.save_daily_picture(user_id, date, image_base64, prompt, thumbnail_base64)\n     return {\"success\": True}\n \n # ========== Preferences Endpoints ==========\n@@ -1003,17 +1066,17 @@ async def generate_image_api(request_data: dict):\n     \"\"\"\n     @@@ Generate artistic image from notes (sync API).\n \n-    This may take longer (60s timeout) due to image generation.\n+    This may take longer (120s timeout) due to image generation.\n     \"\"\"\n     async with httpx.AsyncClient() as client:\n         response = await client.post(\n             \"http://localhost:8765/polycli/api/trigger-sync\",\n             json={\n                 \"session_id\": \"generate_daily_picture\",\n                 \"params\": request_data,\n-                \"timeout\": 60.0  # Image generation takes longer\n+                \"timeout\": 120.0  # Image generation takes ~90s without proxy\n             },\n-            timeout=65.0\n+            timeout=125.0\n         )\n         return response.json()\n "
    },
    {
      "sha": "e7c83fa2abcfa4d032e1ccfb91f4f2e104bb89f1",
      "filename": "backend/stateless_analyzer.py",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/8053a8a180c9b1fb8c60f5c436db476ce5111838/backend%2Fstateless_analyzer.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/8053a8a180c9b1fb8c60f5c436db476ce5111838/backend%2Fstateless_analyzer.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fstateless_analyzer.py?ref=8053a8a180c9b1fb8c60f5c436db476ce5111838",
      "patch": "@@ -153,13 +153,13 @@ def analyze_stateless(agent: PolyAgent, text: str, applied_comments: List[dict],\n             user_name = v.get(\"name\", key)\n             name_to_key[user_name] = key\n \n-        # Override icon/color with config values\n+        # @@@ Map LLM's name back to key for frontend voiceConfigs[key] lookup\n         llm_voice_name = voice.get(\"voice\")\n         archetype_key = name_to_key.get(llm_voice_name)\n         if archetype_key and archetype_key in voice_archetypes:\n             voice[\"icon\"] = voice_archetypes[archetype_key][\"icon\"]\n             voice[\"color\"] = voice_archetypes[archetype_key][\"color\"]\n-            voice[\"voice\"] = llm_voice_name\n+            voice[\"voice\"] = archetype_key  # Return key, not name\n \n         return {\"voices\": [voice], \"new_voices_added\": 1}\n     else:"
    },
    {
      "sha": "272db8cecf7eed3aaa2b049ec9b11b5a3dff8aa0",
      "filename": "frontend/src/App.tsx",
      "status": "modified",
      "additions": 39,
      "deletions": 15,
      "changes": 54,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/8053a8a180c9b1fb8c60f5c436db476ce5111838/frontend%2Fsrc%2FApp.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/8053a8a180c9b1fb8c60f5c436db476ce5111838/frontend%2Fsrc%2FApp.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2FApp.tsx?ref=8053a8a180c9b1fb8c60f5c436db476ce5111838",
      "patch": "@@ -268,6 +268,8 @@ export default function App() {\n   const [currentView, setCurrentView] = useState<'writing' | 'settings' | 'timeline' | 'analysis' | 'about'>('writing');\n   const [showCalendarPopup, setShowCalendarPopup] = useState(false);\n   const [voiceConfigs, setVoiceConfigs] = useState<Record<string, VoiceConfig>>({});\n+  const [metaPrompt, setMetaPrompt] = useState<string>('');\n+  const [loadedStateConfig, setLoadedStateConfig] = useState<StateConfig | null>(null);\n   const [defaultVoiceConfigs, setDefaultVoiceConfigs] = useState<Record<string, VoiceConfig>>({});\n \n   const engineRef = useRef<EditorEngine | null>(null);\n@@ -357,6 +359,8 @@ export default function App() {\n   // @@@ Update engine when voice configs change\n   useEffect(() => {\n     if (engineRef.current && Object.keys(voiceConfigs).length > 0) {\n+      console.log('üì¢ App: voiceConfigs changed, updating engine. Enabled:',\n+        Object.entries(voiceConfigs).filter(([_, v]) => v.enabled).map(([k]) => k));\n       engineRef.current.setVoiceConfigs(voiceConfigs);\n     }\n   }, [voiceConfigs]);\n@@ -444,24 +448,29 @@ export default function App() {\n \n           // Load the most recent session or current session\n           let sessionToLoad = null;\n+          let loadedSessionId: string | undefined = undefined;\n           const currentSessionId = 'current-session';\n           const currentSession = sessions.find(s => s.id === currentSessionId);\n \n           if (currentSession) {\n             // Load current session\n             const fullSession = await getSession(currentSessionId);\n             sessionToLoad = fullSession.editor_state;\n+            loadedSessionId = currentSessionId;\n           } else if (sessions.length > 0) {\n             // Load most recent session\n             const mostRecent = sessions.sort((a, b) =>\n               new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime()\n             )[0];\n             const fullSession = await getSession(mostRecent.id);\n             sessionToLoad = fullSession.editor_state;\n+            loadedSessionId = mostRecent.id;\n           }\n \n-          if (sessionToLoad) {\n+          if (sessionToLoad && loadedSessionId) {\n             engine.loadState(sessionToLoad);\n+            // @@@ CRITICAL: Set currentEntryId to the loaded session ID\n+            engine.setCurrentEntryId(loadedSessionId);\n             setState(engine.getState());\n \n             // Initialize localTexts from loaded state\n@@ -480,6 +489,12 @@ export default function App() {\n             if (prefs.voice_configs) {\n               setVoiceConfigs(prefs.voice_configs);\n             }\n+            if (prefs.meta_prompt) {\n+              setMetaPrompt(prefs.meta_prompt);\n+            }\n+            if (prefs.state_config) {\n+              setLoadedStateConfig(prefs.state_config);\n+            }\n             if (prefs.selected_state !== undefined && prefs.selected_state !== null) {\n               setSelectedState(prefs.selected_state);\n             }\n@@ -542,20 +557,19 @@ export default function App() {\n \n   // @@@ Auto-save to database for authenticated users\n   useEffect(() => {\n-    if (!isAuthenticated || !state || !engineRef.current) return;\n+    if (!isAuthenticated || !state) return;\n+\n+    // @@@ currentEntryId is always defined after engine initialization\n+    if (!state.currentEntryId) {\n+      console.error('BUG: currentEntryId should always be defined after engine init');\n+      return;\n+    }\n \n     const autoSaveTimer = setTimeout(async () => {\n       try {\n-        // Use currentEntryId if exists, otherwise create new UUID\n-        let sessionId = state.currentEntryId;\n-        if (!sessionId) {\n-          sessionId = crypto.randomUUID();\n-          engineRef.current?.setCurrentEntryId(sessionId);\n-        }\n-\n         const { saveSession } = await import('./api/voiceApi');\n-        // Auto-save without name (unsaved draft)\n-        await saveSession(sessionId, state);\n+        // Auto-save without name (preserves existing name if any)\n+        await saveSession(state.currentEntryId!, state);\n         console.log('Auto-saved to database');\n       } catch (error) {\n         console.error('Auto-save failed:', error);\n@@ -883,7 +897,7 @@ export default function App() {\n       weightPath: [],\n       overlappedPhrases: [],\n       sessionId: newSessionId,\n-      currentEntryId: undefined\n+      currentEntryId: newSessionId  // @@@ Set currentEntryId to maintain invariant I5\n     };\n \n     // @@@ Load empty state directly into engine (immediate UI update)\n@@ -895,7 +909,7 @@ export default function App() {\n       // @@@ Save to database in background\n       try {\n         const { saveSession } = await import('./api/voiceApi');\n-        await saveSession(emptyState.sessionId, emptyState);\n+        await saveSession(emptyState.currentEntryId!, emptyState);\n       } catch (error) {\n         console.error('Failed to save new session:', error);\n       }\n@@ -1013,20 +1027,26 @@ export default function App() {\n     metaPrompt: string;\n     stateConfig: StateConfig;\n   }) => {\n+    console.log('App: handleVoiceConfigsSave called, isAuthenticated:', isAuthenticated);\n     setVoiceConfigs(data.voices);\n \n     // @@@ Save to database if authenticated\n     if (isAuthenticated) {\n       try {\n+        console.log('App: Saving preferences to database...');\n         const { savePreferences } = await import('./api/voiceApi');\n         await savePreferences({\n           voice_configs: data.voices,\n           meta_prompt: data.metaPrompt,\n           state_config: data.stateConfig\n         });\n+        console.log('App: Preferences saved to database successfully');\n       } catch (error) {\n-        console.error('Failed to save preferences to database:', error);\n+        console.error('App: Failed to save preferences to database:', error);\n+        throw error; // Propagate error to show alert\n       }\n+    } else {\n+      console.log('App: Guest mode, skipping database save');\n     }\n   }, [isAuthenticated]);\n \n@@ -1887,6 +1907,7 @@ export default function App() {\n                       onKill={() => handleCommentKill(displayedComment.id)}\n                       onSendChatMessage={(msg) => handleCommentChatSend(displayedComment.id, msg)}\n                       isChatProcessing={commentChatProcessing.has(displayedComment.id)}\n+                      voiceConfigs={voiceConfigs}\n                     />\n                     );\n                   });\n@@ -1982,6 +2003,9 @@ export default function App() {\n         }}>\n           <VoiceSettings\n             defaultVoices={defaultVoiceConfigs}\n+            currentVoices={voiceConfigs}\n+            currentMetaPrompt={metaPrompt}\n+            currentStateConfig={loadedStateConfig}\n             onSave={handleVoiceConfigsSave}\n           />\n         </div>\n@@ -1997,7 +2021,7 @@ export default function App() {\n         display: currentView === 'timeline' ? 'flex' : 'none',\n         overflow: 'hidden'\n       }}>\n-        <CollectionsView isVisible={currentView === 'timeline'} />\n+        <CollectionsView isVisible={currentView === 'timeline'} voiceConfigs={voiceConfigs} />\n       </div>\n       {currentView === 'analysis' && (\n         <div style={{"
    },
    {
      "sha": "16a3a0fe31aec386c1d7b73d6d519792183af12f",
      "filename": "frontend/src/api/voiceApi.ts",
      "status": "modified",
      "additions": 23,
      "deletions": 3,
      "changes": 26,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/8053a8a180c9b1fb8c60f5c436db476ce5111838/frontend%2Fsrc%2Fapi%2FvoiceApi.ts",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/8053a8a180c9b1fb8c60f5c436db476ce5111838/frontend%2Fsrc%2Fapi%2FvoiceApi.ts",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fapi%2FvoiceApi.ts?ref=8053a8a180c9b1fb8c60f5c436db476ce5111838",
      "patch": "@@ -47,6 +47,7 @@ interface SyncResponse {\n     traits?: any[];  // For traits analysis\n     patterns?: any[];  // For patterns analysis\n     image_base64?: string;  // For image generation\n+    thumbnail_base64?: string;  // Thumbnail for image generation\n     prompt?: string;  // Image generation prompt\n   };\n   error?: string;\n@@ -179,7 +180,7 @@ export async function analyzePatterns(allNotes: string): Promise<any[]> {\n /**\n  * Generate a daily picture based on user's notes (sync API - no polling!)\n  */\n-export async function generateDailyPicture(allNotes: string): Promise<{ image_base64: string; prompt: string }> {\n+export async function generateDailyPicture(allNotes: string): Promise<{ image_base64: string; thumbnail_base64?: string; prompt: string }> {\n   const response = await fetch(`${API_BASE}/api/generate-image`, {\n     method: 'POST',\n     headers: { 'Content-Type': 'application/json' },\n@@ -195,6 +196,7 @@ export async function generateDailyPicture(allNotes: string): Promise<{ image_ba\n   if (data.result?.image_base64) {\n     return {\n       image_base64: data.result.image_base64,\n+      thumbnail_base64: data.result.thumbnail_base64,\n       prompt: data.result.prompt || 'Generated from your notes'\n     };\n   }\n@@ -314,13 +316,14 @@ export async function deleteSession(sessionId: string): Promise<void> {\n /**\n  * Save daily picture\n  */\n-export async function saveDailyPicture(date: string, imageBase64: string, prompt: string): Promise<void> {\n+export async function saveDailyPicture(date: string, imageBase64: string, prompt: string, thumbnailBase64?: string): Promise<void> {\n   const response = await fetch(`${API_BASE}/api/pictures`, {\n     method: 'POST',\n     headers: getAuthHeaders(),\n     body: JSON.stringify({\n       date,\n       image_base64: imageBase64,\n+      thumbnail_base64: thumbnailBase64,\n       prompt\n     })\n   });\n@@ -332,7 +335,7 @@ export async function saveDailyPicture(date: string, imageBase64: string, prompt\n }\n \n /**\n- * Get daily pictures\n+ * Get daily pictures (thumbnails only for fast timeline loading)\n  */\n export async function getDailyPictures(limit: number = 30): Promise<any[]> {\n   const response = await fetch(`${API_BASE}/api/pictures?limit=${limit}`, {\n@@ -348,6 +351,23 @@ export async function getDailyPictures(limit: number = 30): Promise<any[]> {\n   return data.pictures;\n }\n \n+/**\n+ * Get full resolution image for a specific date (on-demand loading)\n+ */\n+export async function getDailyPictureFull(date: string): Promise<string> {\n+  const response = await fetch(`${API_BASE}/api/pictures/${date}/full`, {\n+    headers: getAuthHeaders()\n+  });\n+\n+  if (!response.ok) {\n+    const error = await response.json();\n+    throw new Error(error.detail || 'Get full picture failed');\n+  }\n+\n+  const data = await response.json();\n+  return data.image_base64;\n+}\n+\n /**\n  * Save user preferences\n  */"
    },
    {
      "sha": "2dea94179fa55bf4cd1fe13b9e3d619a15570748",
      "filename": "frontend/src/components/AnalysisView.tsx",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/8053a8a180c9b1fb8c60f5c436db476ce5111838/frontend%2Fsrc%2Fcomponents%2FAnalysisView.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/8053a8a180c9b1fb8c60f5c436db476ce5111838/frontend%2Fsrc%2Fcomponents%2FAnalysisView.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FAnalysisView.tsx?ref=8053a8a180c9b1fb8c60f5c436db476ce5111838",
      "patch": "@@ -101,6 +101,9 @@ export default function AnalysisView() {\n           // Group sessions by date\n           const grouped: Record<string, any[]> = {};\n           for (const session of sessions) {\n+            // @@@ Skip unnamed sessions (working drafts not saved yet)\n+            if (!session.name) continue;\n+\n             const fullSession = await getSession(session.id);\n \n             // @@@ BUGFIX: Extract date from timestamp (format: \"2025-11-02 10:42:17\" or \"2025-11-02T10:42:17\")\n@@ -120,7 +123,7 @@ export default function AnalysisView() {\n               id: session.id,\n               timestamp: new Date(session.created_at || Date.now()).getTime(),\n               state: fullSession.editor_state,\n-              firstLine: session.name || 'Untitled'\n+              firstLine: session.name\n             });\n           }\n           calendarData = grouped;"
    },
    {
      "sha": "f0f27186b570b47c071b4ef60d3b1ab638837669",
      "filename": "frontend/src/components/CalendarPopup.tsx",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/8053a8a180c9b1fb8c60f5c436db476ce5111838/frontend%2Fsrc%2Fcomponents%2FCalendarPopup.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/8053a8a180c9b1fb8c60f5c436db476ce5111838/frontend%2Fsrc%2Fcomponents%2FCalendarPopup.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FCalendarPopup.tsx?ref=8053a8a180c9b1fb8c60f5c436db476ce5111838",
      "patch": "@@ -32,6 +32,9 @@ export default function CalendarPopup({ onLoadEntry, onClose }: Props) {\n           const grouped: Record<string, CalendarEntry[]> = {};\n \n           for (const session of sessions) {\n+            // @@@ Skip unnamed sessions (working drafts not saved yet)\n+            if (!session.name) continue;\n+\n             const fullSession = await getSession(session.id);\n \n             // @@@ BUGFIX: Extract date from timestamp (format: \"2025-11-02 10:42:17\" or \"2025-11-02T10:42:17\")\n@@ -51,7 +54,7 @@ export default function CalendarPopup({ onLoadEntry, onClose }: Props) {\n               id: session.id,\n               timestamp: new Date(session.created_at || Date.now()).getTime(),\n               state: fullSession.editor_state,\n-              firstLine: session.name || 'Untitled'\n+              firstLine: session.name\n             });\n           }\n "
    },
    {
      "sha": "f7a08fb69805f89d3c1e90b146f754ce00b96803",
      "filename": "frontend/src/components/CollectionsView.tsx",
      "status": "modified",
      "additions": 212,
      "deletions": 41,
      "changes": 253,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/8053a8a180c9b1fb8c60f5c436db476ce5111838/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/8053a8a180c9b1fb8c60f5c436db476ce5111838/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx?ref=8053a8a180c9b1fb8c60f5c436db476ce5111838",
      "patch": "@@ -13,7 +13,7 @@ interface TimelineDay {\n   daysOffset: number;\n }\n \n-export default function CollectionsView({ isVisible }: { isVisible: boolean }) {\n+export default function CollectionsView({ isVisible, voiceConfigs }: { isVisible: boolean; voiceConfigs: Record<string, any> }) {\n   return (\n     <div style={{\n       width: '100%',\n@@ -23,7 +23,7 @@ export default function CollectionsView({ isVisible }: { isVisible: boolean }) {\n       background: '#f8f0e6',\n       overflow: 'hidden'\n     }}>\n-      <TimelinePage isVisible={isVisible} />\n+      <TimelinePage isVisible={isVisible} voiceConfigs={voiceConfigs} />\n     </div>\n   );\n }\n@@ -81,6 +81,16 @@ function getIconForVoice(icon: string): string {\n }\n \n // @@@ Helper to format dates consistently\n+// @@@ Helper to get date in local timezone as YYYY-MM-DD\n+// Prevents timezone issues where UTC date differs from user's local date\n+function getLocalDateString(date?: Date | string): string {\n+  const d = date ? new Date(date) : new Date();\n+  const year = d.getFullYear();\n+  const month = String(d.getMonth() + 1).padStart(2, '0');\n+  const day = String(d.getDate()).padStart(2, '0');\n+  return `${year}-${month}-${day}`;\n+}\n+\n function formatDate(date: Date | string): string {\n   return new Date(date).toLocaleDateString('en-US', {\n     year: 'numeric',\n@@ -90,17 +100,18 @@ function formatDate(date: Date | string): string {\n }\n \n // @@@ Generate timeline days (7 past + today + 7 future)\n+// Returns dates in YYYY-MM-DD format to match database storage\n function generateTimelineDays(): TimelineDay[] {\n   const today = new Date();\n-  const todayStr = formatDate(today);\n+  const todayStr = getLocalDateString(today);\n   const allTimelineDays: TimelineDay[] = [];\n \n   // Add past 7 days\n   for (let i = 7; i >= 1; i--) {\n     const pastDate = new Date(today);\n     pastDate.setDate(today.getDate() - i);\n     allTimelineDays.push({\n-      date: formatDate(pastDate),\n+      date: getLocalDateString(pastDate),\n       isPast: true,\n       isFuture: false,\n       isToday: false,\n@@ -122,7 +133,7 @@ function generateTimelineDays(): TimelineDay[] {\n     const futureDate = new Date(today);\n     futureDate.setDate(today.getDate() + i);\n     allTimelineDays.push({\n-      date: formatDate(futureDate),\n+      date: getLocalDateString(futureDate),\n       isPast: false,\n       isFuture: true,\n       isToday: false,\n@@ -212,38 +223,56 @@ async function getAllNotesFromSessions(isAuthenticated: boolean): Promise<string\n   return allText.join('\\n\\n---\\n\\n');\n }\n \n-// @@@ Timeline page - combines pictures and starred comments by date\n-function TimelinePage({ isVisible }: { isVisible: boolean }) {\n+// @@@ Timeline page - combines pictures and comments by date\n+function TimelinePage({ isVisible, voiceConfigs }: { isVisible: boolean; voiceConfigs: Record<string, any> }) {\n   const { isAuthenticated } = useAuth();\n   const [starredComments, setStarredComments] = useState<Commentor[]>([]);\n-  const [pictures, setPictures] = useState<Array<{ date: string; base64: string; prompt: string }>>([]);\n+  const [allCommentsByDate, setAllCommentsByDate] = useState<Map<string, Commentor[]>>(new Map());\n+  const [pictures, setPictures] = useState<Array<{ date: string; base64: string; full_base64?: string; prompt: string }>>([]);\n   const [generatingForDate, setGeneratingForDate] = useState<string | null>(null);\n-  const [viewingImage, setViewingImage] = useState<{ base64: string; prompt: string; date: string } | null>(null);\n+  const [viewingImage, setViewingImage] = useState<{ base64: string; full_base64?: string; prompt: string; date: string } | null>(null);\n   const [initialLoading, setInitialLoading] = useState(true);\n+  const [loadingCommentsForDate, setLoadingCommentsForDate] = useState<string | null>(null);\n   const scrollContainerRef = useRef<HTMLDivElement | null>(null);\n \n   useEffect(() => {\n     const loadData = async () => {\n-      // @@@ Load starred comments from database if authenticated, localStorage if guest\n+      // @@@ Load all comments grouped by date from database if authenticated, localStorage if guest\n       if (isAuthenticated) {\n         try {\n           const { listSessions, getSession } = await import('../api/voiceApi');\n           const sessions = await listSessions();\n           const allStarred: Commentor[] = [];\n+          const commentsByDate = new Map<string, Commentor[]>();\n \n           for (const session of sessions) {\n             try {\n               const fullSession = await getSession(session.id);\n-              const starred = fullSession.editor_state?.commentors?.filter((c: Commentor) => c.feedback === 'star') || [];\n+              const comments = fullSession.editor_state?.commentors || [];\n+\n+              // Collect starred comments for timeline cards\n+              const starred = comments.filter((c: Commentor) => c.feedback === 'star');\n               allStarred.push(...starred);\n+\n+              // Group ALL comments by date (for image modal display)\n+              // @@@ Use each comment's appliedAt timestamp (not session's created_at) to handle timezone properly\n+              comments.filter((c: Commentor) => c.appliedAt).forEach((comment: Commentor) => {\n+                const commentDate = new Date(comment.appliedAt || comment.computedAt);\n+                const date = getLocalDateString(commentDate);\n+                if (!commentsByDate.has(date)) {\n+                  commentsByDate.set(date, []);\n+                }\n+                commentsByDate.get(date)!.push(comment);\n+              });\n             } catch (err) {\n               console.error(`Failed to load session ${session.id}:`, err);\n             }\n           }\n \n           setStarredComments(allStarred);\n+          setAllCommentsByDate(commentsByDate);\n         } catch (error) {\n-          console.error('Failed to load starred comments from database:', error);\n+          console.error('Failed to load comments from database:', error);\n         }\n       } else {\n         // Guest mode: load from localStorage\n@@ -253,8 +282,17 @@ function TimelinePage({ isVisible }: { isVisible: boolean }) {\n             const state = JSON.parse(savedState);\n             const starred = state.commentors?.filter((c: Commentor) => c.feedback === 'star') || [];\n             setStarredComments(starred);\n+\n+            // For guest mode, all comments are from today\n+            const today = formatDate(new Date());\n+            const allComments = state.commentors?.filter((c: Commentor) => c.appliedAt) || [];\n+            const commentsByDate = new Map<string, Commentor[]>();\n+            if (allComments.length > 0) {\n+              commentsByDate.set(today, allComments);\n+            }\n+            setAllCommentsByDate(commentsByDate);\n           } catch (e) {\n-            console.error('Failed to load starred comments:', e);\n+            console.error('Failed to load comments:', e);\n           }\n         }\n       }\n@@ -264,10 +302,10 @@ function TimelinePage({ isVisible }: { isVisible: boolean }) {\n         try {\n           const { getDailyPictures } = await import('../api/voiceApi');\n           const dbPictures = await getDailyPictures(30);\n-          // Convert database format to app format\n+          // @@@ Backend returns ONLY thumbnails for fast loading (full images loaded on-demand)\n           const formattedPictures = dbPictures.map(p => ({\n             date: p.date,\n-            base64: p.image_base64,\n+            base64: p.base64,  // Thumbnail only\n             prompt: p.prompt || ''\n           }));\n           setPictures(formattedPictures);\n@@ -277,7 +315,14 @@ function TimelinePage({ isVisible }: { isVisible: boolean }) {\n           const savedPictures = localStorage.getItem(STORAGE_KEYS.DAILY_PICTURES);\n           if (savedPictures) {\n             try {\n-              setPictures(JSON.parse(savedPictures));\n+              const parsed = JSON.parse(savedPictures);\n+              // @@@ Strip full_base64 from old cached data (keep only thumbnails)\n+              const thumbnailsOnly = parsed.map((p: any) => ({\n+                date: p.date,\n+                base64: p.base64,\n+                prompt: p.prompt\n+              }));\n+              setPictures(thumbnailsOnly);\n             } catch (e) {\n               console.error('Failed to load pictures:', e);\n             }\n@@ -288,7 +333,14 @@ function TimelinePage({ isVisible }: { isVisible: boolean }) {\n         const savedPictures = localStorage.getItem(STORAGE_KEYS.DAILY_PICTURES);\n         if (savedPictures) {\n           try {\n-            setPictures(JSON.parse(savedPictures));\n+            const parsed = JSON.parse(savedPictures);\n+            // @@@ Strip full_base64 from old cached data (keep only thumbnails)\n+            const thumbnailsOnly = parsed.map((p: any) => ({\n+              date: p.date,\n+              base64: p.base64,\n+              prompt: p.prompt\n+            }));\n+            setPictures(thumbnailsOnly);\n           } catch (e) {\n             console.error('Failed to load pictures:', e);\n           }\n@@ -301,19 +353,20 @@ function TimelinePage({ isVisible }: { isVisible: boolean }) {\n     loadData();\n   }, [isAuthenticated]);\n \n-  // @@@ Group items by date\n+  // @@@ Group items by date (using YYYY-MM-DD format to match timeline days)\n   const timelineByDate = new Map<string, { picture?: any; comments: Commentor[] }>();\n \n   starredComments.forEach(comment => {\n-    const date = formatDate(new Date(comment.appliedAt || comment.computedAt));\n+    const commentDate = new Date(comment.appliedAt || comment.computedAt);\n+    const date = getLocalDateString(commentDate);  // Convert to YYYY-MM-DD\n     if (!timelineByDate.has(date)) {\n       timelineByDate.set(date, { comments: [] });\n     }\n     timelineByDate.get(date)!.comments.push(comment);\n   });\n \n   pictures.forEach(pic => {\n-    const date = formatDate(pic.date);\n+    const date = pic.date;  // Already in YYYY-MM-DD format from database\n     if (!timelineByDate.has(date)) {\n       timelineByDate.set(date, { comments: [] });\n     }\n@@ -346,6 +399,75 @@ function TimelinePage({ isVisible }: { isVisible: boolean }) {\n     });\n   }, [isVisible, initialLoading]);\n \n+  // @@@ Reload comments for a specific date from backend\n+  const reloadCommentsForDate = async (dateStr: string) => {\n+    // dateStr is in YYYY-MM-DD format\n+    setLoadingCommentsForDate(dateStr);\n+\n+    try {\n+      if (isAuthenticated) {\n+        const { listSessions, getSession } = await import('../api/voiceApi');\n+        const sessions = await listSessions();\n+        const commentsForDate: Commentor[] = [];\n+\n+        for (const session of sessions) {\n+          // @@@ Get all comments from session and group by their appliedAt timestamp\n+          try {\n+            const fullSession = await getSession(session.id);\n+            const comments = fullSession.editor_state?.commentors || [];\n+\n+            // Filter comments that belong to this date (using appliedAt timestamp, not session created_at)\n+            comments.filter((c: Commentor) => c.appliedAt).forEach((comment: Commentor) => {\n+              const commentDate = new Date(comment.appliedAt || comment.computedAt);\n+              const date = getLocalDateString(commentDate);\n+              if (date === dateStr) {\n+                commentsForDate.push(comment);\n+              }\n+            });\n+          } catch (err) {\n+            console.error(`Failed to load session ${session.id}:`, err);\n+          }\n+        }\n+\n+        // Update allCommentsByDate for this specific date (using YYYY-MM-DD as key)\n+        setAllCommentsByDate(prev => {\n+          const next = new Map(prev);\n+          next.set(dateStr, commentsForDate);\n+          return next;\n+        });\n+      }\n+    } catch (error) {\n+      console.error('Failed to reload comments for date:', error);\n+    } finally {\n+      setLoadingCommentsForDate(null);\n+    }\n+  };\n+\n+  const handleImageClick = async (picture: { base64: string; full_base64?: string; prompt: string; date: string }) => {\n+    setViewingImage(picture);\n+\n+    // Load full image on-demand if not already loaded\n+    if (!picture.full_base64 && isAuthenticated) {\n+      try {\n+        const { getDailyPictureFull } = await import('../api/voiceApi');\n+        const fullImage = await getDailyPictureFull(picture.date);\n+\n+        // Update the picture object with full image\n+        const updatedPicture = { ...picture, full_base64: fullImage };\n+        setViewingImage(updatedPicture);\n+\n+        // Also update pictures array so we don't reload next time\n+        setPictures(prev => prev.map(p =>\n+          p.date === picture.date ? updatedPicture : p\n+        ));\n+      } catch (error) {\n+        console.error('Failed to load full image:', error);\n+      }\n+    }\n+\n+    await reloadCommentsForDate(picture.date);\n+  };\n+\n   const handleGenerateForDate = async (dateStr: string) => {\n     // @@@ Block image generation for guests\n     if (!isAuthenticated) {\n@@ -363,21 +485,23 @@ function TimelinePage({ isVisible }: { isVisible: boolean }) {\n       }\n \n       const { generateDailyPicture, saveDailyPicture } = await import('../api/voiceApi');\n-      const { image_base64, prompt } = await generateDailyPicture(allNotes);\n+      const { image_base64, thumbnail_base64, prompt } = await generateDailyPicture(allNotes);\n+\n+      // @@@ Use the dateStr parameter passed from the clicked card (already in YYYY-MM-DD format)\n+      const pictureDate = dateStr;\n \n       const newPicture = {\n-        date: new Date().toISOString(),\n-        base64: image_base64,\n+        date: pictureDate,  // @@@ Use date from clicked card\n+        base64: thumbnail_base64 || image_base64,  // @@@ Only thumbnail for fast timeline\n         prompt: prompt\n+        // @@@ NO full_base64 - it will be loaded on-demand when clicking\n       };\n \n       // @@@ Save to database (requires auth)\n-      const pictureDate = new Date(newPicture.date).toISOString().split('T')[0]; // YYYY-MM-DD format\n-      await saveDailyPicture(pictureDate, image_base64, prompt);\n+      await saveDailyPicture(pictureDate, image_base64, prompt, thumbnail_base64);\n \n-      // @@@ Update local state\n-      const normalizedNewDate = formatDate(newPicture.date);\n-      const updated = pictures.filter(p => formatDate(p.date) !== normalizedNewDate);\n+      // @@@ Update local state - remove old picture for this date if exists\n+      const updated = pictures.filter(p => p.date !== pictureDate);\n \n       updated.unshift(newPicture);\n       setPictures(updated);\n@@ -484,7 +608,7 @@ function TimelinePage({ isVisible }: { isVisible: boolean }) {\n                 textAlign: 'center',\n                 marginBottom: '1.5rem'\n               }}>\n-                {day.isToday ? 'Today' : day.date}\n+                {day.isToday ? 'Today' : formatDate(day.date)}\n               </div>\n \n               {/* Card content */}\n@@ -506,7 +630,7 @@ function TimelinePage({ isVisible }: { isVisible: boolean }) {\n                       cursor: 'pointer',\n                       transition: 'all 0.2s'\n                     }}\n-                    onClick={() => setViewingImage(dayData.picture)}\n+                    onClick={() => handleImageClick(dayData.picture)}\n                     onMouseEnter={e => {\n                       e.currentTarget.style.transform = 'scale(1.02)';\n                       e.currentTarget.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';\n@@ -517,7 +641,7 @@ function TimelinePage({ isVisible }: { isVisible: boolean }) {\n                     }}\n                     >\n                       <img\n-                        src={`data:image/png;base64,${dayData.picture.base64}`}\n+                        src={`data:image/${dayData.picture.base64?.startsWith('iVBOR') ? 'png' : 'jpeg'};base64,${dayData.picture.base64}`}\n                         alt={dayData.picture.prompt}\n                         style={{\n                           width: '100%',\n@@ -676,7 +800,7 @@ function TimelinePage({ isVisible }: { isVisible: boolean }) {\n                 position: 'relative'\n               }}>\n                 <img\n-                  src={`data:image/png;base64,${viewingImage.base64}`}\n+                  src={`data:image/${(viewingImage.full_base64 || viewingImage.base64)?.startsWith('iVBOR') ? 'png' : 'jpeg'};base64,${viewingImage.full_base64 || viewingImage.base64}`}\n                   alt=\"Generated image\"\n                   style={{\n                     maxWidth: '100%',\n@@ -756,12 +880,54 @@ function TimelinePage({ isVisible }: { isVisible: boolean }) {\n                   boxSizing: 'border-box'\n                 }}>\n                   {(() => {\n-                    const dateData = Array.from(timelineByDate.entries()).find(([_, data]) =>\n-                      data.picture?.base64 === viewingImage.base64\n-                    );\n-                    const comments = dateData?.[1]?.comments || [];\n+                    // @@@ Priority filtering: starred ‚Üí chatted ‚Üí last ‚Üí none\n+                    // Use raw YYYY-MM-DD format to match Map keys\n+                    const imageDate = viewingImage.date;\n+\n+                    // Show loading state while fetching comments\n+                    if (loadingCommentsForDate === imageDate) {\n+                      return (\n+                        <div style={{\n+                          textAlign: 'center',\n+                          color: '#999',\n+                          fontSize: '14px',\n+                          fontStyle: 'italic',\n+                          padding: '2rem 1rem'\n+                        }}>\n+                          Loading comments...\n+                        </div>\n+                      );\n+                    }\n+\n+                    const allCommentsForDate = allCommentsByDate.get(imageDate) || [];\n+\n+                    let commentsToDisplay: Commentor[] = [];\n+\n+                    // Priority 1: Starred comments\n+                    const starredForDate = allCommentsForDate.filter(c => c.feedback === 'star');\n+                    if (starredForDate.length > 0) {\n+                      commentsToDisplay = starredForDate;\n+                    } else {\n+                      // Priority 2: One chatted comment (has chatHistory)\n+                      const chattedComments = allCommentsForDate.filter(c => c.chatHistory && c.chatHistory.length > 0);\n+                      if (chattedComments.length > 0) {\n+                        // Take the most recent chatted comment\n+                        const mostRecentChatted = chattedComments.sort((a, b) =>\n+                          (b.appliedAt || b.computedAt) - (a.appliedAt || a.computedAt)\n+                        )[0];\n+                        commentsToDisplay = [mostRecentChatted];\n+                      } else {\n+                        // Priority 3: Last comment (by timestamp)\n+                        if (allCommentsForDate.length > 0) {\n+                          const lastComment = allCommentsForDate.sort((a, b) =>\n+                            (b.appliedAt || b.computedAt) - (a.appliedAt || a.computedAt)\n+                          )[0];\n+                          commentsToDisplay = [lastComment];\n+                        }\n+                      }\n+                    }\n \n-                    if (comments.length === 0) {\n+                    if (commentsToDisplay.length === 0) {\n                       return (\n                         <div style={{\n                           textAlign: 'center',\n@@ -770,7 +936,7 @@ function TimelinePage({ isVisible }: { isVisible: boolean }) {\n                           fontStyle: 'italic',\n                           padding: '2rem 1rem'\n                         }}>\n-                          No starred comments for this day\n+                          No comments for this day\n                         </div>\n                       );\n                     }\n@@ -782,7 +948,7 @@ function TimelinePage({ isVisible }: { isVisible: boolean }) {\n                         gap: '1rem',\n                         minWidth: 0\n                       }}>\n-                        {comments.map((comment) => (\n+                        {commentsToDisplay.map((comment) => (\n                           <div\n                             key={comment.id}\n                             style={{\n@@ -802,8 +968,13 @@ function TimelinePage({ isVisible }: { isVisible: boolean }) {\n                               minWidth: 0\n                             }}>\n                               <span style={{ fontSize: '18px', flexShrink: 0 }}>{getIconForVoice(comment.icon)}</span>\n-                              <span style={{ fontWeight: 600, fontSize: '14px', color: '#333', flexShrink: 0 }}>{comment.voice}</span>\n-                              <span style={{ fontSize: '14px', marginLeft: 'auto', flexShrink: 0 }}>‚≠ê</span>\n+                              <span style={{ fontWeight: 600, fontSize: '14px', color: '#333', flexShrink: 0 }}>{voiceConfigs[comment.voice]?.name || comment.voice}</span>\n+                              {comment.feedback === 'star' && (\n+                                <span style={{ fontSize: '14px', marginLeft: 'auto', flexShrink: 0 }}>‚≠ê</span>\n+                              )}\n+                              {comment.chatHistory && comment.chatHistory.length > 0 && (\n+                                <span style={{ fontSize: '14px', marginLeft: comment.feedback === 'star' ? '0.5rem' : 'auto', flexShrink: 0 }}>üí¨</span>\n+                              )}\n                             </div>\n                             <div style={{\n                               fontSize: '12px',"
    },
    {
      "sha": "8361488b94b63c67a87e1c13ef2df44086fe52e5",
      "filename": "frontend/src/components/CommentCard.tsx",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/8053a8a180c9b1fb8c60f5c436db476ce5111838/frontend%2Fsrc%2Fcomponents%2FCommentCard.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/8053a8a180c9b1fb8c60f5c436db476ce5111838/frontend%2Fsrc%2Fcomponents%2FCommentCard.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FCommentCard.tsx?ref=8053a8a180c9b1fb8c60f5c436db476ce5111838",
      "patch": "@@ -55,7 +55,8 @@ export function CommentGroupCard({\n   onStar,\n   onKill,\n   onSendChatMessage,\n-  isChatProcessing\n+  isChatProcessing,\n+  voiceConfigs\n }: {\n   comments: Commentor[];\n   currentIndex: number;\n@@ -67,6 +68,7 @@ export function CommentGroupCard({\n   onKill: () => void;\n   onSendChatMessage: (message: string) => void;\n   isChatProcessing: boolean;\n+  voiceConfigs: Record<string, any>;\n }) {\n   const [isHovered, setIsHovered] = React.useState(false);\n   const [inputValue, setInputValue] = React.useState('');\n@@ -344,7 +346,7 @@ export function CommentGroupCard({\n               WebkitBoxOrient: 'vertical',\n               overflow: 'hidden'\n             }}>\n-              <strong style={{ fontWeight: 600 }}>{currentComment.voice}:</strong> {currentComment.comment}\n+              <strong style={{ fontWeight: 600 }}>{voiceConfigs[currentComment.voice]?.name || currentComment.voice}:</strong> {currentComment.comment}\n             </div>\n           </div>\n         </div>\n@@ -373,7 +375,7 @@ export function CommentGroupCard({\n                     marginBottom: '2px',\n                     fontWeight: 500,\n                   }}>\n-                    {msg.role === 'assistant' ? currentComment.voice : 'You'}\n+                    {msg.role === 'assistant' ? (voiceConfigs[currentComment.voice]?.name || currentComment.voice) : 'You'}\n                   </div>\n                   <div style={{\n                     fontSize: '13px',\n@@ -418,7 +420,7 @@ export function CommentGroupCard({\n                   }\n                 }}\n                 onClick={(e) => e.stopPropagation()}\n-                placeholder={`Reply to ${currentComment.voice}...`}\n+                placeholder={`Reply to ${voiceConfigs[currentComment.voice]?.name || currentComment.voice}...`}\n                 disabled={isChatProcessing}\n                 style={{\n                   flex: 1,"
    },
    {
      "sha": "efce87aba5a031439dd9ceefb1b4770562f6a156",
      "filename": "frontend/src/components/VoiceSettings.tsx",
      "status": "modified",
      "additions": 44,
      "deletions": 19,
      "changes": 63,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/8053a8a180c9b1fb8c60f5c436db476ce5111838/frontend%2Fsrc%2Fcomponents%2FVoiceSettings.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/8053a8a180c9b1fb8c60f5c436db476ce5111838/frontend%2Fsrc%2Fcomponents%2FVoiceSettings.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FVoiceSettings.tsx?ref=8053a8a180c9b1fb8c60f5c436db476ce5111838",
      "patch": "@@ -1,6 +1,6 @@\n import { useState, useEffect, useRef } from 'react';\n import type { VoiceConfig, StateConfig, UserState } from '../types/voice';\n-import { getVoices, saveVoices, clearVoices, getMetaPrompt, saveMetaPrompt, getStateConfig, saveStateConfig } from '../utils/voiceStorage';\n+import { saveVoices, clearVoices, getMetaPrompt, saveMetaPrompt, getStateConfig, saveStateConfig } from '../utils/voiceStorage';\n import {\n   FaBrain, FaHeart, FaQuestion, FaCloud, FaTheaterMasks, FaEye,\n   FaFistRaised, FaLightbulb, FaShieldAlt, FaWind, FaFire, FaCompass\n@@ -49,40 +49,65 @@ const ICON_LABELS = {\n \n interface Props {\n   defaultVoices: Record<string, VoiceConfig>;\n+  currentVoices: Record<string, VoiceConfig>;\n+  currentMetaPrompt: string;\n+  currentStateConfig: StateConfig | null;\n   onSave: (data: {\n     voices: Record<string, VoiceConfig>;\n     metaPrompt: string;\n     stateConfig: StateConfig;\n-  }) => void;\n+  }) => void | Promise<void>;\n }\n \n-export default function VoiceSettings({ defaultVoices, onSave }: Props) {\n+export default function VoiceSettings({ defaultVoices, currentVoices, currentMetaPrompt, currentStateConfig, onSave }: Props) {\n   const [voices, setVoices] = useState<Record<string, VoiceConfig>>({});\n   const [metaPrompt, setMetaPrompt] = useState<string>('');\n   const [stateConfig, setStateConfig] = useState<StateConfig>(getStateConfig());\n   const [saveStatus, setSaveStatus] = useState<'idle' | 'saved'>('idle');\n   const scrollContainerRef = useRef<HTMLDivElement>(null);\n \n-  // @@@ Sync with defaultVoices prop (handles async fetch + Use Default button)\n+  // @@@ Use currentVoices from database (for authenticated users) or defaultVoices fallback\n   useEffect(() => {\n-    if (Object.keys(defaultVoices).length > 0) {\n-      const stored = getVoices();\n-      setVoices(stored || defaultVoices);\n+    if (Object.keys(currentVoices).length > 0) {\n+      setVoices(currentVoices);\n+    } else if (Object.keys(defaultVoices).length > 0) {\n+      setVoices(defaultVoices);\n     }\n-  }, [defaultVoices]);\n+  }, [currentVoices, defaultVoices]);\n \n-  // @@@ Load meta prompt from localStorage\n+  // @@@ Use currentMetaPrompt from database or fallback to localStorage/default\n   useEffect(() => {\n-    setMetaPrompt(getMetaPrompt());\n-  }, []);\n-\n-  const handleSave = () => {\n-    saveVoices(voices);\n-    saveMetaPrompt(metaPrompt);\n-    saveStateConfig(stateConfig);\n-    onSave({ voices, metaPrompt, stateConfig });\n-    setSaveStatus('saved');\n-    setTimeout(() => setSaveStatus('idle'), 2000);\n+    if (currentMetaPrompt) {\n+      setMetaPrompt(currentMetaPrompt);\n+    } else {\n+      setMetaPrompt(getMetaPrompt());\n+    }\n+  }, [currentMetaPrompt]);\n+\n+  // @@@ Use currentStateConfig from database or fallback to localStorage/default\n+  useEffect(() => {\n+    if (currentStateConfig) {\n+      setStateConfig(currentStateConfig);\n+    } else {\n+      setStateConfig(getStateConfig());\n+    }\n+  }, [currentStateConfig]);\n+\n+  const handleSave = async () => {\n+    console.log('VoiceSettings: handleSave called');\n+    try {\n+      saveVoices(voices);\n+      saveMetaPrompt(metaPrompt);\n+      saveStateConfig(stateConfig);\n+      console.log('VoiceSettings: localStorage saved, calling onSave callback');\n+      await onSave({ voices, metaPrompt, stateConfig });\n+      console.log('VoiceSettings: onSave callback completed');\n+      setSaveStatus('saved');\n+      setTimeout(() => setSaveStatus('idle'), 2000);\n+    } catch (error) {\n+      console.error('VoiceSettings: Save failed:', error);\n+      alert('Failed to save settings. Check console for details.');\n+    }\n   };\n \n   const handleDefault = () => {"
    },
    {
      "sha": "47cbfe8f02e7e461353823f5f53ee36501cc14dd",
      "filename": "frontend/src/engine/EditorEngine.ts",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/8053a8a180c9b1fb8c60f5c436db476ce5111838/frontend%2Fsrc%2Fengine%2FEditorEngine.ts",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/8053a8a180c9b1fb8c60f5c436db476ce5111838/frontend%2Fsrc%2Fengine%2FEditorEngine.ts",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fengine%2FEditorEngine.ts?ref=8053a8a180c9b1fb8c60f5c436db476ce5111838",
      "patch": "@@ -42,7 +42,7 @@ export interface Commentor {\n   id: string;\n   phrase: string;       // Highlighted phrase\n   comment: string;      // The comment\n-  voice: string;        // Voice name\n+  voice: string;        // Voice key (for voiceConfigs[key] lookup)\n   icon: string;         // Icon identifier\n   color: string;        // Color identifier\n   appliedAt?: number;   // Timestamp when applied (if applied)\n@@ -129,13 +129,16 @@ export class EditorEngine {\n       tasks: [],\n       weightPath: [],\n       overlappedPhrases: [],\n-      sessionId\n+      sessionId,\n+      currentEntryId: sessionId  // @@@ Set currentEntryId synchronously to prevent duplicate UUIDs\n     };\n   }\n \n   // @@@ Update voice configurations from settings\n   setVoiceConfigs(configs: Record<string, any>) {\n     this.voiceConfigs = configs;\n+    console.log('üì¢ EditorEngine: voiceConfigs updated, enabled voices:',\n+      Object.entries(configs).filter(([_, v]) => v.enabled).map(([k]) => k));\n   }\n \n   // @@@ Update a specific text cell by ID\n@@ -371,6 +374,7 @@ export class EditorEngine {\n           };\n         }\n       }\n+      console.log('üîç EditorEngine: Sending to backend, enabled voices:', Object.keys(backendVoices));\n \n       // Send only APPLIED commentors to backend\n       const appliedCommentors = this.state.commentors.filter(c => c.appliedAt);"
    }
  ]
}