{
  "sha": "a1e1a0b7f8fa00b8fc5cfa1d2ed600a525c9dea1",
  "node_id": "C_kwDOP2Zrm9oAKGExZTFhMGI3ZjhmYTAwYjhmYzVjZmExZDJlZDYwMGE1MjVjOWRlYTE",
  "commit": {
    "author": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-11-30T14:39:35Z"
    },
    "committer": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-11-30T14:45:39Z"
    },
    "message": "removed proxy",
    "tree": {
      "sha": "ff56909610fd26d3cb4006d1cf77b273a402c571",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/trees/ff56909610fd26d3cb4006d1cf77b273a402c571"
    },
    "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/commits/a1e1a0b7f8fa00b8fc5cfa1d2ed600a525c9dea1",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null,
      "verified_at": null
    }
  },
  "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/a1e1a0b7f8fa00b8fc5cfa1d2ed600a525c9dea1",
  "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/a1e1a0b7f8fa00b8fc5cfa1d2ed600a525c9dea1",
  "comments_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/a1e1a0b7f8fa00b8fc5cfa1d2ed600a525c9dea1/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "e83c2ae47b99a2dd1d99ce6135d2492c5412f557",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/e83c2ae47b99a2dd1d99ce6135d2492c5412f557",
      "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/e83c2ae47b99a2dd1d99ce6135d2492c5412f557"
    }
  ],
  "stats": {
    "total": 774,
    "additions": 477,
    "deletions": 297
  },
  "files": [
    {
      "sha": "def0e8f27b7b9b175beda92b2c3e35164c1deb4d",
      "filename": "README.md",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/a1e1a0b7f8fa00b8fc5cfa1d2ed600a525c9dea1/README.md",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/a1e1a0b7f8fa00b8fc5cfa1d2ed600a525c9dea1/README.md",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/README.md?ref=a1e1a0b7f8fa00b8fc5cfa1d2ed600a525c9dea1",
      "patch": "@@ -93,6 +93,7 @@ Runs at `http://localhost:5173`.\n ## Roadmap\n - **Per-user timeline scheduling** ‚Äì Scheduler currently runs once per day using a single timezone; we now store `timezone` in preferences and will move to per-user cadence.\n - **Friend timezone awareness** ‚Äì Friend timelines will eventually display which timezone their entries use once per-user scheduling lands.\n+- **Visitor ‚Äúshadow accounts‚Äù** ‚Äì Reintroduce visitor mode by minting anonymous user records per browser session (UUID + JWT) so visitors hit the exact same backend paths with restricted quotas. No localStorage divergences.\n - **Open-source polish** ‚Äì Document control-plane endpoints, linting, and seed data for new deployments.\n \n ---"
    },
    {
      "sha": "bb6dc1a5a363d515231e5a846da664175a49e05a",
      "filename": "backend/server.py",
      "status": "modified",
      "additions": 476,
      "deletions": 297,
      "changes": 773,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/a1e1a0b7f8fa00b8fc5cfa1d2ed600a525c9dea1/backend%2Fserver.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/a1e1a0b7f8fa00b8fc5cfa1d2ed600a525c9dea1/backend%2Fserver.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fserver.py?ref=a1e1a0b7f8fa00b8fc5cfa1d2ed600a525c9dea1",
      "patch": "@@ -4,8 +4,8 @@\n import os\n import time\n \n-os.environ.setdefault('TZ', 'UTC')\n-if hasattr(time, 'tzset'):\n+os.environ.setdefault(\"TZ\", \"UTC\")\n+if hasattr(time, \"tzset\"):\n     time.tzset()\n \n import asyncio\n@@ -18,7 +18,6 @@\n from stateless_analyzer import analyze_stateless\n from speech_recognition import init_speech_recognition\n import config\n-from proxy_config import get_image_api_proxies\n from typing import Optional\n from pydantic import BaseModel\n \n@@ -29,6 +28,7 @@\n SUPPORTED_LANGUAGES = {\"en\", \"zh\"}\n DEFAULT_LANGUAGE = \"en\"\n \n+\n def normalize_language_code(language: Optional[str]) -> str:\n     if not language:\n         return DEFAULT_LANGUAGE\n@@ -37,6 +37,7 @@ def normalize_language_code(language: Optional[str]) -> str:\n         return \"zh\"\n     return \"en\"\n \n+\n def resolve_language(_user_id: int, requested_language: Optional[str] = None) -> str:\n     \"\"\"Return a supported language code, falling back to default.\"\"\"\n     if requested_language:\n@@ -45,6 +46,7 @@ def resolve_language(_user_id: int, requested_language: Optional[str] = None) ->\n             return code\n     return DEFAULT_LANGUAGE\n \n+\n def language_instruction(language_code: str, detail: str = \"\") -> str:\n     if language_code == \"zh\":\n         base = \"ËØ∑‰ΩøÁî®ÁÆÄ‰Ωì‰∏≠ÊñáËæìÂá∫ÊâÄÊúâÂÜÖÂÆπ„ÄÇ\"\n@@ -54,25 +56,29 @@ def language_instruction(language_code: str, detail: str = \"\") -> str:\n         return f\"{base} {detail}\".strip()\n     return base\n \n+\n # ========== Session Definitions (PolyCLI) ==========\n \n+\n @session_def(\n     name=\"Get Writing Suggestion\",\n     description=\"Get AI-powered writing inspiration from a voice persona\",\n     params={\n         \"text\": {\"type\": \"str\"},\n         \"user_id\": {\"type\": \"int\"},\n         \"meta_prompt\": {\"type\": \"str\"},\n-        \"state_prompt\": {\"type\": \"str\"}\n+        \"state_prompt\": {\"type\": \"str\"},\n     },\n-    category=\"Writing\"\n+    category=\"Writing\",\n )\n-def get_writing_suggestion(text: str, user_id: int, meta_prompt: str = \"\", state_prompt: str = \"\"):\n+def get_writing_suggestion(\n+    text: str, user_id: int, meta_prompt: str = \"\", state_prompt: str = \"\"\n+):\n     \"\"\"Generate writing inspiration from a random voice persona.\"\"\"\n-    print(f\"\\n{'='*60}\")\n+    print(f\"\\n{'=' * 60}\")\n     print(f\"‚úçÔ∏è  get_writing_suggestion() called\")\n     print(f\"   Text length: {len(text)} chars\")\n-    print(f\"{'='*60}\\n\")\n+    print(f\"{'=' * 60}\\n\")\n \n     if not text or len(text.strip()) < 10:\n         return {\"success\": False, \"error\": \"Text too short\"}\n@@ -95,8 +101,8 @@ def get_writing_suggestion(text: str, user_id: int, meta_prompt: str = \"\", state\n     agent = PolyAgent(id=\"writing-suggester\")\n \n     # Build system prompt - voice gives inspiration, not continuation\n-    system_prompt = f\"\"\"You are {voice_info['name']}, an inner voice persona.\n-Your role: {voice_info.get('systemPrompt', '')}\n+    system_prompt = f\"\"\"You are {voice_info[\"name\"]}, an inner voice persona.\n+Your role: {voice_info.get(\"systemPrompt\", \"\")}\n \n Read what the user just wrote and offer a VERY SHORT, gentle nudge about what to write next.\n \n@@ -120,7 +126,7 @@ def get_writing_suggestion(text: str, user_id: int, meta_prompt: str = \"\", state\n - \"I'm curious about the details...\"\n - \"How did that moment change things?\"\n \n-Speak in {voice_info['name']}'s characteristic style, but keep it brief and inspiring.\"\"\"\n+Speak in {voice_info[\"name\"]}'s characteristic style, but keep it brief and inspiring.\"\"\"\n \n     if state_prompt:\n         system_prompt += f\"\\n\\nEmotional context: {state_prompt}\"\n@@ -136,7 +142,13 @@ def get_writing_suggestion(text: str, user_id: int, meta_prompt: str = \"\", state\n \n     # Generate inspiration\n     print(f\"üì§ Calling agent.run() with model='claude-haiku-4.5'...\")\n-    result = agent.run(user_prompt, system_prompt=system_prompt, model='claude-haiku-4.5', cli=\"no-tools\", tracked=True)\n+    result = agent.run(\n+        user_prompt,\n+        system_prompt=system_prompt,\n+        model=\"claude-haiku-4.5\",\n+        cli=\"no-tools\",\n+        tracked=True,\n+    )\n \n     if not result.is_success or not result.content:\n         print(f\"‚ö†Ô∏è  Failed to generate inspiration\")\n@@ -150,12 +162,13 @@ def get_writing_suggestion(text: str, user_id: int, meta_prompt: str = \"\", state\n     return {\n         \"success\": True,\n         \"inspiration\": inspiration,\n-        \"voice\": voice_info['name'],\n+        \"voice\": voice_info[\"name\"],\n         \"voice_key\": voice_key,\n-        \"icon\": voice_info['icon'],\n-        \"color\": voice_info['color']\n+        \"icon\": voice_info[\"icon\"],\n+        \"color\": voice_info[\"color\"],\n     }\n \n+\n @session_def(\n     name=\"Chat with Voice\",\n     description=\"Have a conversation with a specific inner voice persona\",\n@@ -166,43 +179,51 @@ def get_writing_suggestion(text: str, user_id: int, meta_prompt: str = \"\", state\n         \"user_message\": {\"type\": \"str\"},\n         \"original_text\": {\"type\": \"str\"},\n         \"meta_prompt\": {\"type\": \"str\"},\n-        \"state_prompt\": {\"type\": \"str\"}\n+        \"state_prompt\": {\"type\": \"str\"},\n     },\n-    category=\"Chat\"\n+    category=\"Chat\",\n )\n-def chat_with_voice(voice_id: str, user_id: int, conversation_history: list, user_message: str, original_text: str = \"\", meta_prompt: str = \"\", state_prompt: str = \"\"):\n+def chat_with_voice(\n+    voice_id: str,\n+    user_id: int,\n+    conversation_history: list,\n+    user_message: str,\n+    original_text: str = \"\",\n+    meta_prompt: str = \"\",\n+    state_prompt: str = \"\",\n+):\n     \"\"\"Chat with a specific voice persona.\"\"\"\n-    print(f\"\\n{'='*60}\")\n+    print(f\"\\n{'=' * 60}\")\n     print(f\"üí¨ chat_with_voice() called\")\n     print(f\"   Voice ID: {voice_id}\")\n     print(f\"   User ID: {user_id}\")\n     print(f\"   User message: {user_message}\")\n     print(f\"   History length: {len(conversation_history)}\")\n     print(f\"   Meta prompt: {repr(meta_prompt)[:100]}\")\n     print(f\"   State prompt: {repr(state_prompt)[:100]}\")\n-    print(f\"{'='*60}\\n\")\n+    print(f\"{'=' * 60}\\n\")\n \n     # @@@ Load voices from user's enabled decks (deck system)\n     voices = database.load_voices_from_user_decks(user_id)\n \n     # @@@ Get voice config for this specific voice\n     if voice_id in voices:\n         voice_config = voices[voice_id]\n-        voice_name = voice_config.get('name', voice_id)\n+        voice_name = voice_config.get(\"name\", voice_id)\n         print(f\"üìö Loaded voice from deck system: {voice_id} ({voice_name})\")\n     else:\n         # Fallback: voice might be disabled or not in user's decks\n         return {\n             \"success\": False,\n-            \"error\": f\"Voice {voice_id} not found in your enabled decks. Please enable it in the Decks tab.\"\n+            \"error\": f\"Voice {voice_id} not found in your enabled decks. Please enable it in the Decks tab.\",\n         }\n \n     agent = PolyAgent(id=f\"voice-chat-{voice_name.lower()}\")\n \n     # Build system prompt for this voice\n     system_prompt = f\"\"\"You are {voice_name}, an inner voice archetype from Disco Elysium.\n \n-Your character: {voice_config.get('systemPrompt', '')}\n+Your character: {voice_config.get(\"systemPrompt\", \"\")}\n \n Respond in character as {voice_name}. Be concise (1-3 sentences). Stay true to your archetype.\n Use the conversation context but focus on your unique perspective.\"\"\"\n@@ -253,10 +274,8 @@ def chat_with_voice(voice_id: str, user_id: int, conversation_history: list, use\n \n     print(f\"‚úÖ Got response: {response[:100]}...\")\n \n-    return {\n-        \"response\": response,\n-        \"voice_name\": voice_name\n-    }\n+    return {\"response\": response, \"voice_name\": voice_name}\n+\n \n @session_def(\n     name=\"Analyze Voices\",\n@@ -268,57 +287,76 @@ def chat_with_voice(voice_id: str, user_id: int, conversation_history: list, use\n         \"applied_comments\": {\"type\": \"list\"},\n         \"meta_prompt\": {\"type\": \"str\"},\n         \"state_prompt\": {\"type\": \"str\"},\n-        \"overlapped_phrases\": {\"type\": \"list\"}\n+        \"overlapped_phrases\": {\"type\": \"list\"},\n     },\n-    category=\"Analysis\"\n+    category=\"Analysis\",\n )\n-def analyze_text(text: str, editor_session_id: str, user_id: int, applied_comments: list = None, meta_prompt: str = \"\", state_prompt: str = \"\", overlapped_phrases: list = None):\n+def analyze_text(\n+    text: str,\n+    editor_session_id: str,\n+    user_id: int,\n+    applied_comments: list = None,\n+    meta_prompt: str = \"\",\n+    state_prompt: str = \"\",\n+    overlapped_phrases: list = None,\n+):\n     \"\"\"Stateless analysis - returns ONE new comment based on text and applied comments.\"\"\"\n-    print(f\"\\n{'='*60}\")\n+    print(f\"\\n{'=' * 60}\")\n     print(f\"üéØ Stateless analyze_text() called\")\n     print(f\"   User ID: {user_id}\")\n     print(f\"   Text: {text[:100]}...\")\n     print(f\"   Applied comments: {len(applied_comments or [])}\")\n     print(f\"   Overlapped phrases: {len(overlapped_phrases or [])}\")\n     print(f\"   Meta prompt: {repr(meta_prompt)[:100]}\")\n     print(f\"   State prompt: {repr(state_prompt)[:100]}\")\n-    print(f\"{'='*60}\\n\")\n+    print(f\"{'=' * 60}\\n\")\n \n     # @@@ Load voices from user's enabled decks (deck system)\n     voices = database.load_voices_from_user_decks(user_id)\n-    print(f\"üìö Loaded {len(voices)} enabled voices from deck system: {list(voices.keys()) if voices else 'None (will use defaults)'}\")\n+    print(\n+        f\"üìö Loaded {len(voices)} enabled voices from deck system: {list(voices.keys()) if voices else 'None (will use defaults)'}\"\n+    )\n \n     agent = PolyAgent(id=\"voice-analyzer\")\n \n     # Get voices from stateless analyzer\n-    result = analyze_stateless(agent, text, applied_comments or [], voices, meta_prompt, state_prompt, overlapped_phrases or [])\n+    result = analyze_stateless(\n+        agent,\n+        text,\n+        applied_comments or [],\n+        voices,\n+        meta_prompt,\n+        state_prompt,\n+        overlapped_phrases or [],\n+    )\n \n     print(f\"‚úÖ Returning {result['new_voices_added']} new voice(s)\")\n \n     return {\n         \"voices\": result[\"voices\"],\n         \"new_voices_added\": result[\"new_voices_added\"],\n-        \"status\": \"completed\"\n+        \"status\": \"completed\",\n     }\n \n+\n @session_def(\n     name=\"Analyze Echoes\",\n     description=\"Find recurring themes and topics in all user notes\",\n     params={\n         \"all_notes\": {\"type\": \"str\"},\n         \"user_id\": {\"type\": \"int\"},\n-        \"language\": {\"type\": \"str\"}\n+        \"language\": {\"type\": \"str\"},\n     },\n-    category=\"Analysis\"\n+    category=\"Analysis\",\n )\n def analyze_echoes(all_notes: str, user_id: int, language: str = \"en\"):\n     \"\"\"Analyze recurring themes and topics across all notes.\"\"\"\n-    print(f\"\\n{'='*60}\")\n+    print(f\"\\n{'=' * 60}\")\n     print(f\"üîÑ analyze_echoes() called\")\n     print(f\"   Notes length: {len(all_notes)} chars\")\n     language_code = normalize_language_code(language)\n     print(f\"   Language: {language_code}\")\n-    print(f\"{'='*60}\\n\")\n+    print(f\"{'=' * 60}\\n\")\n \n     agent = PolyAgent(id=\"echoes-analyzer\")\n \n@@ -350,29 +388,31 @@ def analyze_echoes(all_notes: str, user_id: int, language: str = \"en\"):\n \n     try:\n         import json\n+\n         echoes = json.loads(result.content.strip())\n         return {\"echoes\": echoes}\n     except:\n         return {\"echoes\": []}\n \n+\n @session_def(\n     name=\"Analyze Traits\",\n     description=\"Identify personality traits and characteristics from user notes\",\n     params={\n         \"all_notes\": {\"type\": \"str\"},\n         \"user_id\": {\"type\": \"int\"},\n-        \"language\": {\"type\": \"str\"}\n+        \"language\": {\"type\": \"str\"},\n     },\n-    category=\"Analysis\"\n+    category=\"Analysis\",\n )\n def analyze_traits(all_notes: str, user_id: int, language: str = \"en\"):\n     \"\"\"Analyze personality traits from all notes.\"\"\"\n-    print(f\"\\n{'='*60}\")\n+    print(f\"\\n{'=' * 60}\")\n     print(f\"üë§ analyze_traits() called\")\n     print(f\"   Notes length: {len(all_notes)} chars\")\n     language_code = normalize_language_code(language)\n     print(f\"   Language: {language_code}\")\n-    print(f\"{'='*60}\\n\")\n+    print(f\"{'=' * 60}\\n\")\n \n     agent = PolyAgent(id=\"traits-analyzer\")\n \n@@ -404,29 +444,31 @@ def analyze_traits(all_notes: str, user_id: int, language: str = \"en\"):\n \n     try:\n         import json\n+\n         traits = json.loads(result.content.strip())\n         return {\"traits\": traits}\n     except:\n         return {\"traits\": []}\n \n+\n @session_def(\n     name=\"Analyze Patterns\",\n     description=\"Identify behavioral patterns and habits from user notes\",\n     params={\n         \"all_notes\": {\"type\": \"str\"},\n         \"user_id\": {\"type\": \"int\"},\n-        \"language\": {\"type\": \"str\"}\n+        \"language\": {\"type\": \"str\"},\n     },\n-    category=\"Analysis\"\n+    category=\"Analysis\",\n )\n def analyze_patterns(all_notes: str, user_id: int, language: str = \"en\"):\n     \"\"\"Analyze behavioral patterns from all notes.\"\"\"\n-    print(f\"\\n{'='*60}\")\n+    print(f\"\\n{'=' * 60}\")\n     print(f\"üîç analyze_patterns() called\")\n     print(f\"   Notes length: {len(all_notes)} chars\")\n     language_code = normalize_language_code(language)\n     print(f\"   Language: {language_code}\")\n-    print(f\"{'='*60}\\n\")\n+    print(f\"{'=' * 60}\\n\")\n \n     agent = PolyAgent(id=\"patterns-analyzer\")\n \n@@ -458,20 +500,22 @@ def analyze_patterns(all_notes: str, user_id: int, language: str = \"en\"):\n \n     try:\n         import json\n+\n         patterns = json.loads(result.content.strip())\n         return {\"patterns\": patterns}\n     except:\n         return {\"patterns\": []}\n \n+\n @session_def(\n     name=\"Generate Daily Picture\",\n     description=\"Generate an artistic image based on user's daily notes\",\n     params={\n         \"all_notes\": {\"type\": \"str\"},\n         \"user_id\": {\"type\": \"int\"},\n-        \"target_date\": {\"type\": \"str\"}  # Optional: YYYY-MM-DD format\n+        \"target_date\": {\"type\": \"str\"},  # Optional: YYYY-MM-DD format\n     },\n-    category=\"Creative\"\n+    category=\"Creative\",\n )\n def generate_daily_picture(all_notes: str, user_id: int, target_date: str = None):\n     \"\"\"Generate an image based on the essence of user's daily notes.\n@@ -484,13 +528,13 @@ def generate_daily_picture(all_notes: str, user_id: int, target_date: str = None\n     from datetime import datetime\n \n     if target_date is None:\n-        target_date = datetime.now().strftime('%Y-%m-%d')\n+        target_date = datetime.now().strftime(\"%Y-%m-%d\")\n \n-    print(f\"\\n{'='*60}\")\n+    print(f\"\\n{'=' * 60}\")\n     print(f\"üé® generate_daily_picture() called\")\n     print(f\"   Notes length: {len(all_notes)} chars\")\n     print(f\"   Target date: {target_date}\")\n-    print(f\"{'='*60}\\n\")\n+    print(f\"{'=' * 60}\\n\")\n \n     import requests\n \n@@ -500,7 +544,7 @@ def generate_daily_picture(all_notes: str, user_id: int, target_date: str = None\n         db = database.get_db()\n         recent_prompts = db.execute(\n             \"SELECT prompt FROM daily_pictures WHERE user_id = ? ORDER BY date DESC LIMIT 5\",\n-            (user_id,)\n+            (user_id,),\n         ).fetchall()\n         db.close()\n \n@@ -513,7 +557,9 @@ def generate_daily_picture(all_notes: str, user_id: int, target_date: str = None\n                 recent_prompts_text += \"\\n‚ö†Ô∏è IMPORTANT: Create something COMPLETELY DIFFERENT from all previous descriptions above!\\n\"\n                 recent_prompts_text += \"‚ö†Ô∏è Use different: setting, objects, style, mood, time of day, colors, composition.\\n\"\n                 recent_prompts_text += \"‚ö†Ô∏è Be creative and avoid repetition!\\n\"\n-                print(f\"üìã Found {len(recent_prompts_list)} recent prompts to avoid duplication\")\n+                print(\n+                    f\"üìã Found {len(recent_prompts_list)} recent prompts to avoid duplication\"\n+                )\n     except Exception as e:\n         print(f\"‚ö†Ô∏è Could not fetch recent prompts: {e}\")\n \n@@ -553,29 +599,30 @@ def generate_daily_picture(all_notes: str, user_id: int, target_date: str = None\n \n     print(\"üß† Creating image description from notes with Claude Haiku...\")\n \n-    # Use proxy for GFW bypass (if configured)\n-    proxies = get_image_api_proxies()\n-\n     claude_response = requests.post(\n         f\"{config.IMAGE_API_ENDPOINT}/chat/completions\",\n         headers={\n             \"Authorization\": f\"Bearer {config.IMAGE_API_KEY}\",\n-            \"Content-Type\": \"application/json\"\n+            \"Content-Type\": \"application/json\",\n         },\n         json={\n             \"model\": config.IMAGE_DESCRIPTION_MODEL,\n             \"messages\": [{\"role\": \"user\", \"content\": description_prompt}],\n-            \"max_tokens\": config.IMAGE_DESCRIPTION_MAX_TOKENS\n+            \"max_tokens\": config.IMAGE_DESCRIPTION_MAX_TOKENS,\n         },\n-        proxies=proxies,\n-        timeout=config.IMAGE_DESCRIPTION_TIMEOUT\n+        timeout=config.IMAGE_DESCRIPTION_TIMEOUT,\n     )\n \n     if claude_response.status_code != 200:\n         return {\"image_base64\": None, \"error\": \"Failed to create image description\"}\n \n     claude_data = claude_response.json()\n-    image_description = claude_data.get('choices', [{}])[0].get('message', {}).get('content', '').strip()\n+    image_description = (\n+        claude_data.get(\"choices\", [{}])[0]\n+        .get(\"message\", {})\n+        .get(\"content\", \"\")\n+        .strip()\n+    )\n \n     if not image_description:\n         return {\"image_base64\": None, \"error\": \"Failed to create image description\"}\n@@ -586,49 +633,55 @@ def generate_daily_picture(all_notes: str, user_id: int, target_date: str = None\n     url = f\"{config.IMAGE_API_ENDPOINT}/chat/completions\"\n     headers = {\n         \"Authorization\": f\"Bearer {config.IMAGE_API_KEY}\",\n-        \"Content-Type\": \"application/json\"\n+        \"Content-Type\": \"application/json\",\n     }\n \n     payload = {\n         \"model\": config.IMAGE_GENERATION_MODEL,\n-        \"messages\": [\n-            {\n-                \"role\": \"user\",\n-                \"content\": image_description\n-            }\n-        ],\n-        \"max_tokens\": config.IMAGE_MAX_TOKENS\n+        \"messages\": [{\"role\": \"user\", \"content\": image_description}],\n+        \"max_tokens\": config.IMAGE_MAX_TOKENS,\n     }\n \n     # Retry logic with increasing timeouts\n     for attempt in range(1, config.IMAGE_RETRY_MAX_ATTEMPTS + 1):\n         try:\n-            timeout_seconds = config.IMAGE_RETRY_BASE_TIMEOUT + (attempt - 1) * config.IMAGE_RETRY_TIMEOUT_INCREMENT\n-            print(f\"üé® Generating image (attempt {attempt}/{config.IMAGE_RETRY_MAX_ATTEMPTS}, timeout={timeout_seconds}s)...\")\n-            response = requests.post(url, headers=headers, json=payload, proxies=proxies, timeout=timeout_seconds)\n+            timeout_seconds = (\n+                config.IMAGE_RETRY_BASE_TIMEOUT\n+                + (attempt - 1) * config.IMAGE_RETRY_TIMEOUT_INCREMENT\n+            )\n+            print(\n+                f\"üé® Generating image (attempt {attempt}/{config.IMAGE_RETRY_MAX_ATTEMPTS}, timeout={timeout_seconds}s)...\"\n+            )\n+            response = requests.post(\n+                url,\n+                headers=headers,\n+                json=payload,\n+                timeout=timeout_seconds,\n+            )\n \n             if response.status_code != 200:\n                 print(f\"‚ùå Error: {response.status_code}\")\n                 if attempt < config.IMAGE_RETRY_MAX_ATTEMPTS:\n                     print(f\"‚è≥ Retrying in 2 seconds...\")\n                     import time\n+\n                     time.sleep(2)\n                     continue\n                 return {\"image_base64\": None, \"error\": \"Image generation failed\"}\n \n             data = response.json()\n \n             # Extract image from response\n-            if 'choices' in data and len(data['choices']) > 0:\n-                message = data['choices'][0].get('message', {})\n-                images = message.get('images', [])\n+            if \"choices\" in data and len(data[\"choices\"]) > 0:\n+                message = data[\"choices\"][0].get(\"message\", {})\n+                images = message.get(\"images\", [])\n \n                 if images:\n-                    image_data = images[0].get('image_url', {}).get('url', '')\n+                    image_data = images[0].get(\"image_url\", {}).get(\"url\", \"\")\n \n-                    if image_data.startswith('data:image/png;base64,'):\n+                    if image_data.startswith(\"data:image/png;base64,\"):\n                         # Extract base64 data (without the data URI prefix)\n-                        base64_data = image_data.split(',', 1)[1]\n+                        base64_data = image_data.split(\",\", 1)[1]\n \n                         # @@@ Convert to JPEG and create thumbnail\n                         try:\n@@ -641,49 +694,64 @@ def generate_daily_picture(all_notes: str, user_id: int, target_date: str = None\n                             img = Image.open(BytesIO(img_bytes))\n \n                             # Convert to RGB (JPEG doesn't support transparency)\n-                            if img.mode in ('RGBA', 'LA', 'P'):\n-                                rgb_img = Image.new('RGB', img.size, (255, 255, 255))\n-                                if img.mode == 'RGBA':\n+                            if img.mode in (\"RGBA\", \"LA\", \"P\"):\n+                                rgb_img = Image.new(\"RGB\", img.size, (255, 255, 255))\n+                                if img.mode == \"RGBA\":\n                                     rgb_img.paste(img, mask=img.split()[-1])\n                                 else:\n                                     rgb_img.paste(img)\n                                 img = rgb_img\n \n                             # Full JPEG (quality 85)\n                             full_output = BytesIO()\n-                            img.save(full_output, format='JPEG', quality=85, optimize=True)\n-                            full_jpeg = base64.b64encode(full_output.getvalue()).decode('utf-8')\n+                            img.save(\n+                                full_output, format=\"JPEG\", quality=85, optimize=True\n+                            )\n+                            full_jpeg = base64.b64encode(full_output.getvalue()).decode(\n+                                \"utf-8\"\n+                            )\n \n                             # Thumbnail JPEG (400px width, quality 60)\n                             thumb_width = 400\n                             thumb_height = int(img.height * (thumb_width / img.width))\n-                            thumb_img = img.resize((thumb_width, thumb_height), Image.Resampling.LANCZOS)\n+                            thumb_img = img.resize(\n+                                (thumb_width, thumb_height), Image.Resampling.LANCZOS\n+                            )\n \n                             thumb_output = BytesIO()\n-                            thumb_img.save(thumb_output, format='JPEG', quality=60, optimize=True)\n-                            thumb_jpeg = base64.b64encode(thumb_output.getvalue()).decode('utf-8')\n+                            thumb_img.save(\n+                                thumb_output, format=\"JPEG\", quality=60, optimize=True\n+                            )\n+                            thumb_jpeg = base64.b64encode(\n+                                thumb_output.getvalue()\n+                            ).decode(\"utf-8\")\n \n                             print(f\"‚úÖ Image generated successfully\")\n                             print(f\"   Original PNG: {len(base64_data)} chars\")\n-                            print(f\"   Full JPEG: {len(full_jpeg)} chars ({100 * len(full_jpeg) / len(base64_data):.1f}%)\")\n-                            print(f\"   Thumbnail: {len(thumb_jpeg)} chars ({100 * len(thumb_jpeg) / len(base64_data):.1f}%)\")\n+                            print(\n+                                f\"   Full JPEG: {len(full_jpeg)} chars ({100 * len(full_jpeg) / len(base64_data):.1f}%)\"\n+                            )\n+                            print(\n+                                f\"   Thumbnail: {len(thumb_jpeg)} chars ({100 * len(thumb_jpeg) / len(base64_data):.1f}%)\"\n+                            )\n \n                             return {\n                                 \"image_base64\": full_jpeg,\n                                 \"thumbnail_base64\": thumb_jpeg,\n-                                \"prompt\": image_description\n+                                \"prompt\": image_description,\n                             }\n                         except Exception as e:\n                             print(f\"‚ö†Ô∏è JPEG conversion failed: {e}, using original PNG\")\n                             return {\n                                 \"image_base64\": base64_data,\n                                 \"thumbnail_base64\": base64_data,  # Fallback to full image\n-                                \"prompt\": image_description\n+                                \"prompt\": image_description,\n                             }\n \n             if attempt < config.IMAGE_RETRY_MAX_ATTEMPTS:\n                 print(f\"‚ö†Ô∏è No image in response, retrying...\")\n                 import time\n+\n                 time.sleep(2)\n                 continue\n             return {\"image_base64\": None, \"error\": \"No image in response\"}\n@@ -693,18 +761,20 @@ def generate_daily_picture(all_notes: str, user_id: int, target_date: str = None\n             if attempt < config.IMAGE_RETRY_MAX_ATTEMPTS:\n                 print(f\"‚è≥ Retrying in 2 seconds...\")\n                 import time\n+\n                 time.sleep(2)\n                 continue\n             return {\"image_base64\": None, \"error\": str(e)}\n \n     return {\"image_base64\": None, \"error\": \"All retry attempts failed\"}\n \n+\n # ========== FastAPI Application ==========\n \n app = FastAPI(\n     title=\"Ink & Memory API\",\n     description=\"Voice analysis and creative generation API\",\n-    version=\"2.0.0\"\n+    version=\"2.0.0\",\n )\n \n # Add CORS middleware\n@@ -724,52 +794,59 @@ def generate_daily_picture(all_notes: str, user_id: int, target_date: str = None\n # Create scheduler instance\n timeline_gen_scheduler = AsyncIOScheduler()\n \n+\n @app.on_event(\"startup\")\n async def startup_scheduler():\n     \"\"\"Start the timeline auto-generation scheduler on app startup.\"\"\"\n-    print(\"\\n\" + \"=\"*60)\n+    print(\"\\n\" + \"=\" * 60)\n     print(\"üìÖ Starting Timeline Auto-Generation Scheduler\")\n     print(\"   Schedule: Daily at 00:00 (midnight, Asia/Shanghai timezone)\")\n     print(\"   Generates timeline images for previous day\")\n-    print(\"=\"*60 + \"\\n\")\n+    print(\"=\" * 60 + \"\\n\")\n \n     # @@@ asyncio.run() creates new event loop for scheduler thread\n     timeline_gen_scheduler.add_job(\n         lambda: asyncio.run(timeline_scheduler.daily_generation_job()),\n-        'cron',\n+        \"cron\",\n         hour=0,\n         minute=0,\n-        timezone='Asia/Shanghai',\n-        id='daily_timeline_generation',\n-        name='Generate timeline images for yesterday',\n-        replace_existing=True\n+        timezone=\"Asia/Shanghai\",\n+        id=\"daily_timeline_generation\",\n+        name=\"Generate timeline images for yesterday\",\n+        replace_existing=True,\n     )\n \n     timeline_gen_scheduler.start()\n     print(\"‚úÖ Scheduler started - next run at midnight (00:00 Asia/Shanghai)\\n\")\n \n+\n @app.on_event(\"shutdown\")\n async def shutdown_scheduler():\n     \"\"\"Shutdown the scheduler gracefully.\"\"\"\n     print(\"\\nüìÖ Shutting down timeline scheduler...\")\n     timeline_gen_scheduler.shutdown(wait=False)\n     print(\"‚úÖ Scheduler shutdown complete\\n\")\n \n+\n # ========== Request/Response Models ==========\n \n+\n class RegisterRequest(BaseModel):\n     email: str\n     password: str\n     display_name: Optional[str] = None\n \n+\n class LoginRequest(BaseModel):\n     email: str\n     password: str\n \n+\n class TokenResponse(BaseModel):\n     token: str\n     user: dict\n \n+\n class ImportDataRequest(BaseModel):\n     currentSession: Optional[str] = None\n     calendarEntries: Optional[str] = None\n@@ -781,8 +858,10 @@ class ImportDataRequest(BaseModel):\n     analysisReports: Optional[str] = None\n     oldDocument: Optional[str] = None\n \n+\n # ========== Auth Dependency ==========\n \n+\n def get_current_user(authorization: Optional[str] = Header(None)) -> dict:\n     \"\"\"\n     Dependency to extract and verify JWT token from Authorization header.\n@@ -800,20 +879,24 @@ def get_current_user(authorization: Optional[str] = Header(None)) -> dict:\n \n     return user_data\n \n+\n # ========== Custom API Endpoints (Clean Interface) ==========\n \n+\n @app.get(\"/\")\n def root():\n     \"\"\"Root endpoint\"\"\"\n     return {\n         \"service\": \"Ink & Memory API\",\n         \"version\": \"2.0.0\",\n         \"docs\": \"/docs\",\n-        \"control_panel\": \"/polycli\"\n+        \"control_panel\": \"/polycli\",\n     }\n \n+\n # ========== Auth Endpoints ==========\n \n+\n @app.post(\"/api/register\", response_model=TokenResponse)\n def register(request: RegisterRequest):\n     \"\"\"\n@@ -826,14 +909,18 @@ def register(request: RegisterRequest):\n         raise HTTPException(status_code=400, detail=\"Email and password required\")\n \n     if len(request.password) < 6:\n-        raise HTTPException(status_code=400, detail=\"Password must be at least 6 characters\")\n+        raise HTTPException(\n+            status_code=400, detail=\"Password must be at least 6 characters\"\n+        )\n \n     # Hash password\n     password_hash = auth.hash_password(request.password)\n \n     # Create user\n     try:\n-        user_id = database.create_user(request.email, password_hash, request.display_name)\n+        user_id = database.create_user(\n+            request.email, password_hash, request.display_name\n+        )\n     except ValueError as e:\n         raise HTTPException(status_code=400, detail=str(e))\n \n@@ -848,10 +935,11 @@ def register(request: RegisterRequest):\n         \"user\": {\n             \"id\": user_id,\n             \"email\": request.email,\n-            \"display_name\": request.display_name\n-        }\n+            \"display_name\": request.display_name,\n+        },\n     }\n \n+\n @app.post(\"/api/login\", response_model=TokenResponse)\n def login(request: LoginRequest):\n     \"\"\"\n@@ -865,60 +953,72 @@ def login(request: LoginRequest):\n         raise HTTPException(status_code=401, detail=\"Invalid email or password\")\n \n     # Verify password\n-    if not auth.verify_password(request.password, user['password_hash']):\n+    if not auth.verify_password(request.password, user[\"password_hash\"]):\n         raise HTTPException(status_code=401, detail=\"Invalid email or password\")\n \n     # @@@ Auto-fork system decks if user has no decks yet (handles existing users)\n-    user_decks = database.get_user_decks(user['id'])\n+    user_decks = database.get_user_decks(user[\"id\"])\n     if len(user_decks) == 0:\n-        database.auto_fork_system_decks(user['id'])\n+        database.auto_fork_system_decks(user[\"id\"])\n \n     # Generate token\n-    token = auth.create_access_token(user['id'], user['email'])\n+    token = auth.create_access_token(user[\"id\"], user[\"email\"])\n \n     return {\n         \"token\": token,\n         \"user\": {\n-            \"id\": user['id'],\n-            \"email\": user['email'],\n-            \"display_name\": user['display_name']\n-        }\n+            \"id\": user[\"id\"],\n+            \"email\": user[\"email\"],\n+            \"display_name\": user[\"display_name\"],\n+        },\n     }\n \n+\n @app.get(\"/api/me\")\n def get_current_user_info(current_user: dict = Depends(get_current_user)):\n     \"\"\"\n     Get current user info from token.\n \n     Requires Authorization header with Bearer token.\n     \"\"\"\n-    user = database.get_user_by_id(current_user['user_id'])\n+    user = database.get_user_by_id(current_user[\"user_id\"])\n     if not user:\n         raise HTTPException(status_code=404, detail=\"User not found\")\n \n     return {\n-        \"id\": user['id'],\n-        \"email\": user['email'],\n-        \"display_name\": user['display_name'],\n-        \"created_at\": user['created_at']\n+        \"id\": user[\"id\"],\n+        \"email\": user[\"email\"],\n+        \"display_name\": user[\"display_name\"],\n+        \"created_at\": user[\"created_at\"],\n     }\n \n+\n @app.post(\"/api/import-local-data\")\n-def import_local_data(request: ImportDataRequest, current_user: dict = Depends(get_current_user)):\n+def import_local_data(\n+    request: ImportDataRequest, current_user: dict = Depends(get_current_user)\n+):\n     \"\"\"\n     Import localStorage data to database on first login.\n \n     Extracts sessions, pictures, preferences, and reports from localStorage export.\n     \"\"\"\n     import json\n \n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n \n     print(f\"\\nüîç Migration request for user {user_id}:\")\n-    print(f\"  - currentSession: {len(request.currentSession) if request.currentSession else 0} chars\")\n-    print(f\"  - calendarEntries: {len(request.calendarEntries) if request.calendarEntries else 0} chars\")\n-    print(f\"  - dailyPictures: {len(request.dailyPictures) if request.dailyPictures else 0} chars\")\n-    print(f\"  - oldDocument: {len(request.oldDocument) if request.oldDocument else 0} chars\")\n+    print(\n+        f\"  - currentSession: {len(request.currentSession) if request.currentSession else 0} chars\"\n+    )\n+    print(\n+        f\"  - calendarEntries: {len(request.calendarEntries) if request.calendarEntries else 0} chars\"\n+    )\n+    print(\n+        f\"  - dailyPictures: {len(request.dailyPictures) if request.dailyPictures else 0} chars\"\n+    )\n+    print(\n+        f\"  - oldDocument: {len(request.oldDocument) if request.oldDocument else 0} chars\"\n+    )\n \n     # Extract sessions\n     sessions = []\n@@ -927,11 +1027,13 @@ def import_local_data(request: ImportDataRequest, current_user: dict = Depends(g\n     if request.currentSession:\n         try:\n             current = json.loads(request.currentSession)\n-            sessions.append({\n-                'id': 'current-session',\n-                'name': 'Current Session',\n-                'editor_state': current\n-            })\n+            sessions.append(\n+                {\n+                    \"id\": \"current-session\",\n+                    \"name\": \"Current Session\",\n+                    \"editor_state\": current,\n+                }\n+            )\n             print(f\"‚úÖ Imported current session ({len(str(current))} chars)\")\n         except Exception as e:\n             print(f\"‚ùå Failed to parse current session: {e}\")\n@@ -945,26 +1047,33 @@ def import_local_data(request: ImportDataRequest, current_user: dict = Depends(g\n             for date, entries in calendar.items():\n                 print(f\"  - {date}: {len(entries)} entries\")\n                 for entry in entries:\n-                    sessions.append({\n-                        'id': entry['id'],\n-                        'name': f\"{date} - {entry.get('firstLine', 'Untitled')}\",\n-                        'editor_state': entry['state']\n-                    })\n+                    sessions.append(\n+                        {\n+                            \"id\": entry[\"id\"],\n+                            \"name\": f\"{date} - {entry.get('firstLine', 'Untitled')}\",\n+                            \"editor_state\": entry[\"state\"],\n+                        }\n+                    )\n         except Exception as e:\n             print(f\"‚ùå Failed to parse calendar entries: {e}\")\n             import traceback\n+\n             traceback.print_exc()\n \n     # 3. Old document (if exists)\n     if request.oldDocument:\n         try:\n             old_doc = json.loads(request.oldDocument)\n-            if old_doc and old_doc.get('document'):\n-                sessions.append({\n-                    'id': 'old-document',\n-                    'name': 'Old Document (migrated)',\n-                    'editor_state': {'cells': [{'type': 'text', 'content': str(old_doc)}]}\n-                })\n+            if old_doc and old_doc.get(\"document\"):\n+                sessions.append(\n+                    {\n+                        \"id\": \"old-document\",\n+                        \"name\": \"Old Document (migrated)\",\n+                        \"editor_state\": {\n+                            \"cells\": [{\"type\": \"text\", \"content\": str(old_doc)}]\n+                        },\n+                    }\n+                )\n         except:\n             pass\n \n@@ -974,46 +1083,50 @@ def import_local_data(request: ImportDataRequest, current_user: dict = Depends(g\n         try:\n             pics = json.loads(request.dailyPictures)\n             for pic in pics:\n-                pictures.append({\n-                    'date': pic['date'],\n-                    'image_base64': pic['base64'],\n-                    'prompt': pic.get('prompt', '')\n-                })\n+                pictures.append(\n+                    {\n+                        \"date\": pic[\"date\"],\n+                        \"image_base64\": pic[\"base64\"],\n+                        \"prompt\": pic.get(\"prompt\", \"\"),\n+                    }\n+                )\n         except:\n             pass\n \n     # Extract preferences\n     preferences = {}\n     if request.voiceCustomizations:\n         try:\n-            preferences['voice_configs'] = json.loads(request.voiceCustomizations)\n+            preferences[\"voice_configs\"] = json.loads(request.voiceCustomizations)\n         except:\n             pass\n \n     if request.metaPrompt:\n-        preferences['meta_prompt'] = request.metaPrompt\n+        preferences[\"meta_prompt\"] = request.metaPrompt\n \n     if request.stateConfig:\n         try:\n-            preferences['state_config'] = json.loads(request.stateConfig)\n+            preferences[\"state_config\"] = json.loads(request.stateConfig)\n         except:\n             pass\n \n     if request.selectedState:\n-        preferences['selected_state'] = request.selectedState\n+        preferences[\"selected_state\"] = request.selectedState\n \n     # Extract reports\n     reports = []\n     if request.analysisReports:\n         try:\n             report_list = json.loads(request.analysisReports)\n             for report in report_list:\n-                reports.append({\n-                    'type': report.get('type', 'unknown'),\n-                    'data': report.get('data', {}),\n-                    'allNotes': report.get('allNotes', ''),\n-                    'timestamp': report.get('timestamp', '')\n-                })\n+                reports.append(\n+                    {\n+                        \"type\": report.get(\"type\", \"unknown\"),\n+                        \"data\": report.get(\"data\", {}),\n+                        \"allNotes\": report.get(\"allNotes\", \"\"),\n+                        \"timestamp\": report.get(\"timestamp\", \"\"),\n+                    }\n+                )\n         except:\n             pass\n \n@@ -1026,17 +1139,16 @@ def import_local_data(request: ImportDataRequest, current_user: dict = Depends(g\n             \"sessions\": len(sessions),\n             \"pictures\": len(pictures),\n             \"preferences\": len([k for k, v in preferences.items() if v]),\n-            \"reports\": len(reports)\n-        }\n+            \"reports\": len(reports),\n+        },\n     }\n \n+\n # ========== Session Storage Endpoints ==========\n \n+\n @app.post(\"/api/sessions\")\n-def save_session(\n-    request: dict,\n-    current_user: dict = Depends(get_current_user)\n-):\n+def save_session(request: dict, current_user: dict = Depends(get_current_user)):\n     \"\"\"\n     Save or update a session.\n \n@@ -1047,22 +1159,24 @@ def save_session(\n         \"editor_state\": {...}\n     }\n     \"\"\"\n-    user_id = current_user['user_id']\n-    session_id = request.get('session_id')\n-    editor_state = request.get('editor_state')\n-    name = request.get('name')\n+    user_id = current_user[\"user_id\"]\n+    session_id = request.get(\"session_id\")\n+    editor_state = request.get(\"editor_state\")\n+    name = request.get(\"name\")\n \n     if not session_id or not editor_state:\n-        raise HTTPException(status_code=400, detail=\"session_id and editor_state required\")\n+        raise HTTPException(\n+            status_code=400, detail=\"session_id and editor_state required\"\n+        )\n \n     database.save_session(user_id, session_id, editor_state, name)\n \n     return {\"success\": True}\n \n+\n @app.post(\"/api/import-calendar-recovery\")\n def import_calendar_recovery(\n-    request: dict,\n-    current_user: dict = Depends(get_current_user)\n+    request: dict, current_user: dict = Depends(get_current_user)\n ):\n     \"\"\"\n     Recovery endpoint to import calendar entries that were missed in initial migration.\n@@ -1074,8 +1188,8 @@ def import_calendar_recovery(\n     \"\"\"\n     import json\n \n-    user_id = current_user['user_id']\n-    calendar_json = request.get('calendarEntries')\n+    user_id = current_user[\"user_id\"]\n+    calendar_json = request.get(\"calendarEntries\")\n \n     if not calendar_json:\n         raise HTTPException(status_code=400, detail=\"calendarEntries required\")\n@@ -1087,26 +1201,27 @@ def import_calendar_recovery(\n         for date, entries in calendar.items():\n             print(f\"  - {date}: {len(entries)} entries\")\n             for entry in entries:\n-                sessions.append({\n-                    'id': entry['id'],\n-                    'name': f\"{date} - {entry.get('firstLine', 'Untitled')}\",\n-                    'editor_state': entry['state']\n-                })\n+                sessions.append(\n+                    {\n+                        \"id\": entry[\"id\"],\n+                        \"name\": f\"{date} - {entry.get('firstLine', 'Untitled')}\",\n+                        \"editor_state\": entry[\"state\"],\n+                    }\n+                )\n     except Exception as e:\n         print(f\"‚ùå Failed to parse calendar: {e}\")\n         import traceback\n+\n         traceback.print_exc()\n-        raise HTTPException(status_code=400, detail=f\"Failed to parse calendar: {str(e)}\")\n+        raise HTTPException(\n+            status_code=400, detail=f\"Failed to parse calendar: {str(e)}\"\n+        )\n \n     # Import to database\n     database.import_user_data(user_id, sessions, [], {}, [])\n \n-    return {\n-        \"success\": True,\n-        \"imported\": {\n-            \"sessions\": len(sessions)\n-        }\n-    }\n+    return {\"success\": True, \"imported\": {\"sessions\": len(sessions)}}\n+\n \n @app.get(\"/api/sessions\")\n def list_sessions(current_user: dict = Depends(get_current_user)):\n@@ -1115,61 +1230,62 @@ def list_sessions(current_user: dict = Depends(get_current_user)):\n \n     Returns: Array of session metadata (without full editor state)\n     \"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     sessions = database.list_sessions(user_id)\n     return {\"sessions\": sessions}\n \n+\n @app.get(\"/api/sessions/{session_id}\")\n def get_session(session_id: str, current_user: dict = Depends(get_current_user)):\n     \"\"\"\n     Get a specific session by ID.\n \n     Returns: Full session including editor_state\n     \"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     session = database.get_session(user_id, session_id)\n \n     if not session:\n         raise HTTPException(status_code=404, detail=\"Session not found\")\n \n     return session\n \n+\n @app.delete(\"/api/sessions/{session_id}\")\n-def delete_session_endpoint(session_id: str, current_user: dict = Depends(get_current_user)):\n+def delete_session_endpoint(\n+    session_id: str, current_user: dict = Depends(get_current_user)\n+):\n     \"\"\"Delete a session.\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     database.delete_session(user_id, session_id)\n     return {\"success\": True}\n \n+\n # ========== Pictures Endpoints ==========\n \n+\n @app.get(\"/api/pictures\")\n-def get_pictures(\n-    limit: int = 30,\n-    current_user: dict = Depends(get_current_user)\n-):\n+def get_pictures(limit: int = 30, current_user: dict = Depends(get_current_user)):\n     \"\"\"\n     Get recent daily pictures for current user (thumbnails only for fast loading).\n \n     Query params:\n     - limit: Max number of pictures to return (default 30)\n     \"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     pictures = database.get_daily_pictures(user_id, limit)\n     return {\"pictures\": pictures}\n \n+\n @app.get(\"/api/pictures/{date}/full\")\n-def get_picture_full(\n-    date: str,\n-    current_user: dict = Depends(get_current_user)\n-):\n+def get_picture_full(date: str, current_user: dict = Depends(get_current_user)):\n     \"\"\"\n     Get full resolution image for a specific date (on-demand loading).\n \n     Path params:\n     - date: Date in YYYY-MM-DD format\n     \"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     full_image = database.get_daily_picture_full(user_id, date)\n \n     if not full_image:\n@@ -1180,24 +1296,22 @@ def get_picture_full(\n \n @app.get(\"/api/friends/{friend_id}/pictures/{date}/full\")\n def get_friend_picture_full_endpoint(\n-    friend_id: int,\n-    date: str,\n-    current_user: dict = Depends(get_current_user)\n+    friend_id: int, date: str, current_user: dict = Depends(get_current_user)\n ):\n     \"\"\"Get full resolution image for a friend's specific date (only if users are friends).\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     full_image = database.get_friend_picture_full(user_id, friend_id, date)\n \n     if not full_image:\n-        raise HTTPException(status_code=404, detail=\"Picture not found or not accessible\")\n+        raise HTTPException(\n+            status_code=404, detail=\"Picture not found or not accessible\"\n+        )\n \n     return {\"image_base64\": full_image}\n \n+\n @app.post(\"/api/pictures\")\n-def save_picture(\n-    request: dict,\n-    current_user: dict = Depends(get_current_user)\n-):\n+def save_picture(request: dict, current_user: dict = Depends(get_current_user)):\n     \"\"\"\n     Save a daily picture.\n \n@@ -1208,31 +1322,33 @@ def save_picture(\n         \"prompt\": \"optional prompt\"\n     }\n     \"\"\"\n-    user_id = current_user['user_id']\n-    date = request.get('date')\n-    image_base64 = request.get('image_base64')\n-    thumbnail_base64 = request.get('thumbnail_base64')\n-    prompt = request.get('prompt', '')\n+    user_id = current_user[\"user_id\"]\n+    date = request.get(\"date\")\n+    image_base64 = request.get(\"image_base64\")\n+    thumbnail_base64 = request.get(\"thumbnail_base64\")\n+    prompt = request.get(\"prompt\", \"\")\n \n     if not date or not image_base64:\n         raise HTTPException(status_code=400, detail=\"date and image_base64 required\")\n \n     database.save_daily_picture(user_id, date, image_base64, prompt, thumbnail_base64)\n     return {\"success\": True}\n \n+\n # ========== Preferences Endpoints ==========\n \n+\n @app.get(\"/api/preferences\")\n def get_preferences(current_user: dict = Depends(get_current_user)):\n     \"\"\"Get user preferences.\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     preferences = database.get_preferences(user_id)\n     return preferences or {}\n \n+\n @app.post(\"/api/preferences\")\n def save_preferences_endpoint(\n-    request: dict,\n-    current_user: dict = Depends(get_current_user)\n+    request: dict, current_user: dict = Depends(get_current_user)\n ):\n     \"\"\"\n     Save user preferences.\n@@ -1243,48 +1359,47 @@ def save_preferences_endpoint(\n     - state_config: dict\n     - selected_state: str\n     \"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n \n     database.save_preferences(\n         user_id,\n-        voice_configs=request.get('voice_configs'),\n-        meta_prompt=request.get('meta_prompt'),\n-        state_config=request.get('state_config'),\n-        selected_state=request.get('selected_state'),\n-        timezone=request.get('timezone')\n+        voice_configs=request.get(\"voice_configs\"),\n+        meta_prompt=request.get(\"meta_prompt\"),\n+        state_config=request.get(\"state_config\"),\n+        selected_state=request.get(\"selected_state\"),\n+        timezone=request.get(\"timezone\"),\n     )\n \n     return {\"success\": True}\n \n+\n # @@@ Removed /api/suggest wrapper - frontend now calls /polycli/api/trigger-sync directly\n \n+\n @app.post(\"/api/mark-first-login-completed\")\n def mark_first_login_completed(current_user: dict = Depends(get_current_user)):\n     \"\"\"\n     Mark user's first login as completed.\n     Called after migration dialog is shown (migrate or skip).\n     \"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     database.set_first_login_completed(user_id)\n     return {\"success\": True}\n \n+\n # ========== Analysis Reports Endpoints ==========\n \n+\n @app.get(\"/api/reports\")\n-def get_reports(\n-    limit: int = 10,\n-    current_user: dict = Depends(get_current_user)\n-):\n+def get_reports(limit: int = 10, current_user: dict = Depends(get_current_user)):\n     \"\"\"Get recent analysis reports.\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     reports = database.get_analysis_reports(user_id, limit)\n     return {\"reports\": reports}\n \n+\n @app.post(\"/api/reports\")\n-def save_report(\n-    request: dict,\n-    current_user: dict = Depends(get_current_user)\n-):\n+def save_report(request: dict, current_user: dict = Depends(get_current_user)):\n     \"\"\"\n     Save an analysis report.\n \n@@ -1295,24 +1410,30 @@ def save_report(\n         \"all_notes_text\": \"optional text\"\n     }\n     \"\"\"\n-    user_id = current_user['user_id']\n-    report_type = request.get('report_type')\n-    report_data = request.get('report_data')\n-    all_notes_text = request.get('all_notes_text', '')\n+    user_id = current_user[\"user_id\"]\n+    report_type = request.get(\"report_type\")\n+    report_data = request.get(\"report_data\")\n+    all_notes_text = request.get(\"all_notes_text\", \"\")\n \n     if not report_type or not report_data:\n-        raise HTTPException(status_code=400, detail=\"report_type and report_data required\")\n+        raise HTTPException(\n+            status_code=400, detail=\"report_type and report_data required\"\n+        )\n \n     database.save_analysis_report(user_id, report_type, report_data, all_notes_text)\n     return {\"success\": True}\n \n+\n @app.get(\"/api/default-voices\")\n def get_default_voices():\n     \"\"\"Get default voice configurations\"\"\"\n     return config.VOICE_ARCHETYPES\n \n+\n @app.post(\"/api/admin/trigger-timeline-generation\")\n-async def trigger_timeline_generation(date: str = None, timezone: str = 'Asia/Shanghai'):\n+async def trigger_timeline_generation(\n+    date: str = None, timezone: str = \"Asia/Shanghai\"\n+):\n     \"\"\"\n     Manually trigger timeline image generation for a specific date (testing/admin).\n \n@@ -1329,25 +1450,20 @@ async def trigger_timeline_generation(date: str = None, timezone: str = 'Asia/Sh\n     print(f\"üîß Manual trigger: Generating timeline images for {date}\")\n \n     try:\n-        result = await timeline_scheduler.generate_timeline_images_for_date(date, timezone)\n-        return {\n-            \"success\": True,\n-            \"date\": date,\n-            \"timezone\": timezone,\n-            **result\n-        }\n+        result = await timeline_scheduler.generate_timeline_images_for_date(\n+            date, timezone\n+        )\n+        return {\"success\": True, \"date\": date, \"timezone\": timezone, **result}\n     except Exception as e:\n         import traceback\n+\n         traceback.print_exc()\n-        return {\n-            \"success\": False,\n-            \"error\": str(e),\n-            \"date\": date,\n-            \"timezone\": timezone\n-        }\n+        return {\"success\": False, \"error\": str(e), \"date\": date, \"timezone\": timezone}\n+\n \n # ========== Deck & Voice Management ==========\n \n+\n class DeckCreateRequest(BaseModel):\n     name: str\n     description: str = None\n@@ -1358,6 +1474,7 @@ class DeckCreateRequest(BaseModel):\n     icon: str = None\n     color: str = None\n \n+\n class DeckUpdateRequest(BaseModel):\n     name: str = None\n     description: str = None\n@@ -1370,6 +1487,7 @@ class DeckUpdateRequest(BaseModel):\n     enabled: bool = None\n     order_index: int = None\n \n+\n class VoiceCreateRequest(BaseModel):\n     deck_id: str\n     name: str\n@@ -1379,6 +1497,7 @@ class VoiceCreateRequest(BaseModel):\n     icon: str = None\n     color: str = None\n \n+\n class VoiceUpdateRequest(BaseModel):\n     name: str = None\n     system_prompt: str = None\n@@ -1389,17 +1508,22 @@ class VoiceUpdateRequest(BaseModel):\n     enabled: bool = None\n     order_index: int = None\n \n+\n class VoiceForkRequest(BaseModel):\n     target_deck_id: str\n \n+\n # ========== Friend System Models ==========\n \n+\n class UseInviteCodeRequest(BaseModel):\n     code: str\n \n+\n class FriendRequestActionRequest(BaseModel):\n     pass  # No body needed, just request_id in URL\n \n+\n @app.get(\"/api/decks\")\n def list_decks(published: bool = False, current_user: dict = Depends(get_current_user)):\n     \"\"\"Get decks - either user's own or published community decks\"\"\"\n@@ -1408,23 +1532,27 @@ def list_decks(published: bool = False, current_user: dict = Depends(get_current\n         decks = database.get_published_decks()\n     else:\n         # Get user's own decks\n-        user_id = current_user['user_id']\n+        user_id = current_user[\"user_id\"]\n         decks = database.get_user_decks(user_id)\n     return {\"decks\": decks}\n \n+\n @app.get(\"/api/decks/{deck_id}\")\n def get_deck(deck_id: str, current_user: dict = Depends(get_current_user)):\n     \"\"\"Get deck with all voices\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     deck = database.get_deck_with_voices(user_id, deck_id)\n     if not deck:\n         raise HTTPException(status_code=404, detail=\"Deck not found\")\n     return deck\n \n+\n @app.post(\"/api/decks\")\n-def create_deck(request: DeckCreateRequest, current_user: dict = Depends(get_current_user)):\n+def create_deck(\n+    request: DeckCreateRequest, current_user: dict = Depends(get_current_user)\n+):\n     \"\"\"Create a new user deck\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     deck_id = database.create_deck(\n         user_id,\n         name=request.name,\n@@ -1434,36 +1562,47 @@ def create_deck(request: DeckCreateRequest, current_user: dict = Depends(get_cur\n         description_zh=request.description_zh,\n         description_en=request.description_en,\n         icon=request.icon,\n-        color=request.color\n+        color=request.color,\n     )\n     return {\"deck_id\": deck_id}\n \n+\n @app.put(\"/api/decks/{deck_id}\")\n-def update_deck(deck_id: str, request: DeckUpdateRequest, current_user: dict = Depends(get_current_user)):\n+def update_deck(\n+    deck_id: str,\n+    request: DeckUpdateRequest,\n+    current_user: dict = Depends(get_current_user),\n+):\n     \"\"\"Update a user deck\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n \n     # Convert request to dict, exclude None values\n     updates = {k: v for k, v in request.dict().items() if v is not None}\n \n     success = database.update_deck(user_id, deck_id, updates)\n     if not success:\n-        raise HTTPException(status_code=404, detail=\"Deck not found or permission denied\")\n+        raise HTTPException(\n+            status_code=404, detail=\"Deck not found or permission denied\"\n+        )\n     return {\"success\": True}\n \n+\n @app.delete(\"/api/decks/{deck_id}\")\n def delete_deck(deck_id: str, current_user: dict = Depends(get_current_user)):\n     \"\"\"Delete a user deck (cascades to voices)\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     success = database.delete_deck(user_id, deck_id)\n     if not success:\n-        raise HTTPException(status_code=404, detail=\"Deck not found or permission denied\")\n+        raise HTTPException(\n+            status_code=404, detail=\"Deck not found or permission denied\"\n+        )\n     return {\"success\": True}\n \n+\n @app.post(\"/api/decks/{deck_id}/fork\")\n def fork_deck(deck_id: str, current_user: dict = Depends(get_current_user)):\n     \"\"\"Fork a deck (system or published community deck) to create user's own copy\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     try:\n         new_deck_id = database.fork_deck(user_id, deck_id)\n         # @@@ Increment install count if forking from published deck\n@@ -1472,21 +1611,24 @@ def fork_deck(deck_id: str, current_user: dict = Depends(get_current_user)):\n     except ValueError as e:\n         raise HTTPException(status_code=404, detail=str(e))\n \n+\n @app.post(\"/api/decks/{deck_id}/publish\")\n def publish_deck(deck_id: str, current_user: dict = Depends(get_current_user)):\n     \"\"\"\n     Publish/unpublish a deck to community store.\n     @@@ Warning: Publishing breaks parent_id chain (deck becomes standalone)\n     \"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     try:\n         # Check if deck is currently published\n         deck = database.get_deck_with_voices(user_id, deck_id)\n         if not deck:\n-            raise HTTPException(status_code=404, detail=\"Deck not found or not owned by user\")\n+            raise HTTPException(\n+                status_code=404, detail=\"Deck not found or not owned by user\"\n+            )\n \n         # Toggle published status\n-        if deck.get('published'):\n+        if deck.get(\"published\"):\n             database.unpublish_deck(deck_id, user_id)\n             return {\"success\": True, \"published\": False}\n         else:\n@@ -1495,20 +1637,24 @@ def publish_deck(deck_id: str, current_user: dict = Depends(get_current_user)):\n     except Exception as e:\n         raise HTTPException(status_code=500, detail=str(e))\n \n+\n @app.post(\"/api/decks/{deck_id}/sync\")\n def sync_deck(deck_id: str, current_user: dict = Depends(get_current_user)):\n     \"\"\"Sync user's forked deck with parent template (force overwrites local changes)\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     try:\n         result = database.sync_deck_with_parent(user_id, deck_id, force=True)\n         return result\n     except ValueError as e:\n         raise HTTPException(status_code=400, detail=str(e))\n \n+\n @app.post(\"/api/voices\")\n-def create_voice(request: VoiceCreateRequest, current_user: dict = Depends(get_current_user)):\n+def create_voice(\n+    request: VoiceCreateRequest, current_user: dict = Depends(get_current_user)\n+):\n     \"\"\"Create a new voice in a user deck\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     try:\n         voice_id = database.create_voice(\n             user_id,\n@@ -1518,107 +1664,139 @@ def create_voice(request: VoiceCreateRequest, current_user: dict = Depends(get_c\n             name_zh=request.name_zh,\n             name_en=request.name_en,\n             icon=request.icon,\n-            color=request.color\n+            color=request.color,\n         )\n         return {\"voice_id\": voice_id}\n     except ValueError as e:\n         raise HTTPException(status_code=400, detail=str(e))\n \n+\n @app.put(\"/api/voices/{voice_id}\")\n-def update_voice(voice_id: str, request: VoiceUpdateRequest, current_user: dict = Depends(get_current_user)):\n+def update_voice(\n+    voice_id: str,\n+    request: VoiceUpdateRequest,\n+    current_user: dict = Depends(get_current_user),\n+):\n     \"\"\"Update a user voice\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n \n     # Convert request to dict, exclude None values\n     updates = {k: v for k, v in request.dict().items() if v is not None}\n \n     success = database.update_voice(user_id, voice_id, updates)\n     if not success:\n-        raise HTTPException(status_code=404, detail=\"Voice not found or permission denied\")\n+        raise HTTPException(\n+            status_code=404, detail=\"Voice not found or permission denied\"\n+        )\n     return {\"success\": True}\n \n+\n @app.delete(\"/api/voices/{voice_id}\")\n def delete_voice(voice_id: str, current_user: dict = Depends(get_current_user)):\n     \"\"\"Delete a user voice\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     success = database.delete_voice(user_id, voice_id)\n     if not success:\n-        raise HTTPException(status_code=404, detail=\"Voice not found or permission denied\")\n+        raise HTTPException(\n+            status_code=404, detail=\"Voice not found or permission denied\"\n+        )\n     return {\"success\": True}\n \n+\n @app.post(\"/api/voices/{voice_id}/fork\")\n-def fork_voice(voice_id: str, request: VoiceForkRequest, current_user: dict = Depends(get_current_user)):\n+def fork_voice(\n+    voice_id: str,\n+    request: VoiceForkRequest,\n+    current_user: dict = Depends(get_current_user),\n+):\n     \"\"\"Fork a voice to a user deck\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     try:\n         new_voice_id = database.fork_voice(user_id, voice_id, request.target_deck_id)\n         return {\"voice_id\": new_voice_id}\n     except ValueError as e:\n         raise HTTPException(status_code=400, detail=str(e))\n \n+\n # ========== Friend System Endpoints ==========\n \n+\n @app.post(\"/api/friends/invite/generate\")\n def generate_friend_invite(current_user: dict = Depends(get_current_user)):\n     \"\"\"Generate a new friend invite code (6 chars, 7 days validity)\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     result = database.generate_invite_code(user_id)\n     return result\n \n+\n @app.post(\"/api/friends/invite/use\")\n-def use_friend_invite(request: UseInviteCodeRequest, current_user: dict = Depends(get_current_user)):\n+def use_friend_invite(\n+    request: UseInviteCodeRequest, current_user: dict = Depends(get_current_user)\n+):\n     \"\"\"Use an invite code to send a friend request\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     result = database.use_invite_code(request.code, user_id)\n-    if not result.get('success'):\n-        raise HTTPException(status_code=400, detail=result.get('error'))\n+    if not result.get(\"success\"):\n+        raise HTTPException(status_code=400, detail=result.get(\"error\"))\n     return result\n \n+\n @app.get(\"/api/friends/requests\")\n def get_friend_requests(current_user: dict = Depends(get_current_user)):\n     \"\"\"Get all pending friend requests for current user\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     requests = database.get_friend_requests(user_id)\n     return {\"requests\": requests}\n \n+\n @app.post(\"/api/friends/requests/{request_id}/accept\")\n-def accept_friend_request(request_id: int, current_user: dict = Depends(get_current_user)):\n+def accept_friend_request(\n+    request_id: int, current_user: dict = Depends(get_current_user)\n+):\n     \"\"\"Accept a friend request\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     result = database.accept_friend_request(request_id, user_id)\n-    if not result.get('success'):\n-        raise HTTPException(status_code=400, detail=result.get('error'))\n+    if not result.get(\"success\"):\n+        raise HTTPException(status_code=400, detail=result.get(\"error\"))\n     return result\n \n+\n @app.post(\"/api/friends/requests/{request_id}/reject\")\n-def reject_friend_request(request_id: int, current_user: dict = Depends(get_current_user)):\n+def reject_friend_request(\n+    request_id: int, current_user: dict = Depends(get_current_user)\n+):\n     \"\"\"Reject a friend request\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     result = database.reject_friend_request(request_id, user_id)\n-    if not result.get('success'):\n-        raise HTTPException(status_code=400, detail=result.get('error'))\n+    if not result.get(\"success\"):\n+        raise HTTPException(status_code=400, detail=result.get(\"error\"))\n     return result\n \n+\n @app.get(\"/api/friends\")\n def get_friends(current_user: dict = Depends(get_current_user)):\n     \"\"\"Get all accepted friends for current user\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     friends = database.get_friends(user_id)\n     return {\"friends\": friends}\n \n+\n @app.delete(\"/api/friends/{friend_id}\")\n def remove_friend(friend_id: int, current_user: dict = Depends(get_current_user)):\n     \"\"\"Remove a friend\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     result = database.remove_friend(user_id, friend_id)\n-    if not result.get('success'):\n-        raise HTTPException(status_code=400, detail=result.get('error'))\n+    if not result.get(\"success\"):\n+        raise HTTPException(status_code=400, detail=result.get(\"error\"))\n     return result\n \n+\n @app.get(\"/api/friends/{friend_id}/timeline\")\n-def get_friend_timeline(friend_id: int, limit: int = 30, current_user: dict = Depends(get_current_user)):\n+def get_friend_timeline(\n+    friend_id: int, limit: int = 30, current_user: dict = Depends(get_current_user)\n+):\n     \"\"\"Get a friend's timeline pictures (only if friends)\"\"\"\n-    user_id = current_user['user_id']\n+    user_id = current_user[\"user_id\"]\n     timeline = database.get_friend_timeline(user_id, friend_id, limit)\n     if timeline is None:\n         raise HTTPException(status_code=403, detail=\"Not friends or friend not found\")\n@@ -1630,7 +1808,6 @@ async def speech_recognition(websocket: WebSocket):\n     await websocket.accept()\n     await init_speech_recognition(websocket)\n \n-\n # @@@ Removed /api/analyze wrapper - frontend now calls /polycli/api/trigger-sync directly\n \n # @@@ Removed /api/chat wrapper - frontend now calls /polycli/api/trigger-sync directly\n@@ -1644,16 +1821,18 @@ async def speech_recognition(websocket: WebSocket):\n \n registry = get_registry()\n # @@@ Pass auth_callback to enable authentication for /polycli/api/trigger-sync\n-mount_control_panel(app, registry, prefix=\"/polycli\", auth_callback=auth.verify_access_token)\n+mount_control_panel(\n+    app, registry, prefix=\"/polycli\", auth_callback=auth.verify_access_token\n+)\n \n # ========== Main ==========\n \n if __name__ == \"__main__\":\n     import uvicorn\n \n-    print(\"\\n\" + \"=\"*60)\n+    print(\"\\n\" + \"=\" * 60)\n     print(\"üé≠ Ink & Memory FastAPI Server\")\n-    print(\"=\"*60)\n+    print(\"=\" * 60)\n     print(\"\\nüìö API Endpoints:\")\n     print(\"  Auth & User:\")\n     print(\"    POST /api/register        - Register new user\")\n@@ -1703,6 +1882,6 @@ async def speech_recognition(websocket: WebSocket):\n     print(\"                 generate_daily_picture\")\n     print(\"\\n  Documentation:\")\n     print(\"    /docs                     - Auto-generated API docs\")\n-    print(\"=\"*60 + \"\\n\")\n+    print(\"=\" * 60 + \"\\n\")\n \n     uvicorn.run(app, host=\"127.0.0.1\", port=8765)"
    }
  ]
}