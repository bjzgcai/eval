{
  "sha": "a4eb52998c60b0de1bbf875423f681091b5eb39a",
  "node_id": "C_kwDOP2Zrm9oAKGE0ZWI1Mjk5OGM2MGIwZGUxYmJmODc1NDIzZjY4MTA5MWI1ZWIzOWE",
  "commit": {
    "author": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-10-26T10:14:48Z"
    },
    "committer": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-10-26T10:14:48Z"
    },
    "message": "Add chat widget feature and cleanup backend\n\n- Add chat widget feature: users can now chat 1-to-1 with voice agents\n  - New ChatWidget engine class for managing conversation state\n  - AgentDropdown component for selecting agents\n  - ChatWidgetUI component with auto-scroll and delete functionality\n  - @ trigger to insert chat widgets inline with writing\n\n- Update voice settings: hide internal keys, show only display names\n  - Voice names now used in prompts instead of keys\n  - Simplified UX for voice configuration\n\n- Add custom warning dialog for \"Start Fresh\" action\n  - Replace browser confirm with styled modal\n  - Better alignment and visual consistency\n\n- Backend cleanup: consolidate to single server implementation\n  - Rename server_stateless.py to server.py\n  - Remove old unused backend files (server_simple, stateful_analyzer, etc.)\n  - Keep only: server.py, stateless_analyzer.py, config.py\n\nðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude <noreply@anthropic.com>",
    "tree": {
      "sha": "b85b7a3ca858a33d2c09bb53a9c82d4a5264d865",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/trees/b85b7a3ca858a33d2c09bb53a9c82d4a5264d865"
    },
    "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/commits/a4eb52998c60b0de1bbf875423f681091b5eb39a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null,
      "verified_at": null
    }
  },
  "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/a4eb52998c60b0de1bbf875423f681091b5eb39a",
  "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/a4eb52998c60b0de1bbf875423f681091b5eb39a",
  "comments_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/a4eb52998c60b0de1bbf875423f681091b5eb39a/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "2d3d70520cee9077fdc27b77ccff340a7e14093a",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/2d3d70520cee9077fdc27b77ccff340a7e14093a",
      "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/2d3d70520cee9077fdc27b77ccff340a7e14093a"
    }
  ],
  "stats": {
    "total": 3048,
    "additions": 1607,
    "deletions": 1441
  },
  "files": [
    {
      "sha": "114849289c316b7d922d6a15b8d7bdb9421b4115",
      "filename": "backend/server.py",
      "status": "modified",
      "additions": 32,
      "deletions": 43,
      "changes": 75,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/a4eb52998c60b0de1bbf875423f681091b5eb39a/backend%2Fserver.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/a4eb52998c60b0de1bbf875423f681091b5eb39a/backend%2Fserver.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fserver.py?ref=a4eb52998c60b0de1bbf875423f681091b5eb39a",
      "patch": "@@ -1,10 +1,10 @@\n #!/usr/bin/env python3\n-\"\"\"Voice analysis server using PolyCLI Session Registry.\"\"\"\n+\"\"\"Stateless voice analysis server - no state tracking, just returns new comments.\"\"\"\n \n import time\n from polycli.orchestration.session_registry import session_def, get_registry\n from polycli import PolyAgent\n-from stateful_analyzer import analyze_stateful\n+from stateless_analyzer import analyze_stateless\n import config\n \n @session_def(\n@@ -28,6 +28,7 @@ def chat_with_voice(voice_name: str, voice_config: dict, conversation_history: l\n         voice_config: Voice configuration with tagline, icon, color\n         conversation_history: Previous messages in the conversation\n         user_message: The user's new message\n+        original_text: The user's original writing text\n \n     Returns:\n         Dictionary with assistant's response\n@@ -41,7 +42,7 @@ def chat_with_voice(voice_name: str, voice_config: dict, conversation_history: l\n \n     agent = PolyAgent(id=f\"voice-chat-{voice_name.lower()}\")\n \n-    # @@@ Ensure voice_config is a dict (defensive check)\n+    # Ensure voice_config is a dict\n     if not isinstance(voice_config, dict):\n         print(f\"âš ï¸  voice_config is not a dict: {type(voice_config)}, using default\")\n         voice_config = {\"tagline\": f\"{voice_name} voice from Disco Elysium\"}\n@@ -54,7 +55,7 @@ def chat_with_voice(voice_name: str, voice_config: dict, conversation_history: l\n Respond in character as {voice_name}. Be concise (1-3 sentences). Stay true to your archetype.\n Use the conversation context but focus on your unique perspective.\"\"\"\n \n-    # @@@ Add original writing area text if available\n+    # Add original writing area text if available\n     if original_text and original_text.strip():\n         system_prompt += f\"\"\"\n \n@@ -93,68 +94,57 @@ def chat_with_voice(voice_name: str, voice_config: dict, conversation_history: l\n \n @session_def(\n     name=\"Analyze Voices\",\n-    description=\"Detect inner voices in text using Disco Elysium archetypes\",\n+    description=\"Get one new voice comment for text\",\n     params={\n         \"text\": {\"type\": \"str\"},\n         \"session_id\": {\"type\": \"str\"},\n-        \"voices\": {\"type\": \"dict\"}\n+        \"voices\": {\"type\": \"dict\"},\n+        \"applied_comments\": {\"type\": \"list\"}\n     },\n     category=\"Analysis\"\n )\n-def analyze_text(text: str, session_id: str, voices: dict = None):\n+def analyze_text(text: str, session_id: str, voices: dict = None, applied_comments: list = None):\n     \"\"\"\n-    Analyze text and detect inner voice triggers.\n+    Stateless analysis - returns ONE new comment based on text and applied comments.\n \n     Args:\n-        text: Text to analyze\n+        text: Text to analyze (should be complete sentences only)\n+        session_id: Session ID (for future use)\n+        voices: Voice configuration\n+        applied_comments: List of already applied comments (to avoid duplicates)\n \n     Returns:\n-        Dictionary with voices array and status\n+        Dictionary with single new voice (or empty list)\n     \"\"\"\n     print(f\"\\n{'='*60}\")\n-    print(f\"ðŸŽ¯ analyze_text() called\")\n-    print(f\"   Session ID: {session_id}\")\n-    print(f\"   Text length: {len(text)}\")\n-    print(f\"   Text preview: {text[:100]}...\")\n+    print(f\"ðŸŽ¯ Stateless analyze_text() called\")\n+    print(f\"   Text: {text[:100]}...\")\n+    print(f\"   Applied comments: {len(applied_comments or [])}\")\n     print(f\"{'='*60}\\n\")\n \n-    print(\"Creating PolyAgent...\")\n     agent = PolyAgent(id=\"voice-analyzer\")\n \n-    print(\"Calling analyze_stateful pattern...\")\n-    custom_voices = voices or config.VOICE_ARCHETYPES\n-    analysis_result = analyze_stateful(agent, text, session_id, custom_voices)\n+    # Get voices from stateless analyzer\n+    result = analyze_stateless(agent, text, applied_comments or [], voices)\n \n-    # @@@ analyze_stateful now returns dict with 'voices' and 'new_voices_added'\n-    result_voices = analysis_result[\"voices\"]\n-    new_voices_added = analysis_result[\"new_voices_added\"]\n+    print(f\"âœ… Returning {result['new_voices_added']} new voice(s)\")\n \n-    print(f\"âœ… Got {len(result_voices)} total voices ({new_voices_added} new from this LLM call)\")\n-    for i, v in enumerate(result_voices):\n-        print(f\"   {i+1}. {v.get('voice', 'unknown')}: {v.get('comment', '')[:50]}...\")\n-\n-    result = {\n-        \"voices\": result_voices,\n-        \"new_voices_added\": new_voices_added,  # Frontend uses this for energy refund\n-        \"status\": \"completed\",\n-        \"text_length\": len(text)\n+    return {\n+        \"voices\": result[\"voices\"],\n+        \"new_voices_added\": result[\"new_voices_added\"],\n+        \"status\": \"completed\"\n     }\n \n-    print(f\"Returning result: {result}\")\n-    print(f\"{'='*60}\\n\")\n-\n-    return result\n-\n if __name__ == \"__main__\":\n-    # Get the global registry (session auto-registered via decorator)\n+    # Get the global registry\n     registry = get_registry()\n \n     # Start the control panel\n     print(\"\\n\" + \"=\"*60)\n-    print(\"ðŸŽ­ Voice Analysis Server\")\n+    print(\"ðŸŽ­ Stateless Voice Analysis Server\")\n     print(\"=\"*60)\n \n-    # Monkey-patch the handler to add /api/default-voices endpoint\n+    # Monkey-patch to add /api/default-voices endpoint\n     server, thread = registry.serve_control_panel(port=8765)\n \n     original_do_get = server.RequestHandlerClass.do_GET\n@@ -174,15 +164,14 @@ def patched_do_get(handler_self):\n \n     print(\"\\nðŸ“š Available endpoints:\")\n     print(\"  - POST /api/trigger\")\n-    print(\"    Body: {\\\"session_id\\\": \\\"analyze_text\\\", \\\"params\\\": {\\\"text\\\": \\\"...\\\"}}\")\n-    print(\"  - GET /api/sessions (list all sessions)\")\n-    print(\"  - GET /api/running (list running sessions)\")\n-    print(\"  - GET /api/status/{exec_id} (get session status)\")\n+    print(\"    Body: {\\\"session_id\\\": \\\"analyze_text\\\", \\\"params\\\": {\\\"text\\\": \\\"...\\\", \\\"applied_comments\\\": [...]}}\")\n+    print(\"    Body: {\\\"session_id\\\": \\\"chat_with_voice\\\", \\\"params\\\": {\\\"voice_name\\\": \\\"...\\\", \\\"user_message\\\": \\\"...\\\", ...}}\")\n+    print(\"  - GET /api/default-voices\")\n     print(\"\\n\" + \"=\"*60 + \"\\n\")\n \n     # Keep server running\n     try:\n         while True:\n             time.sleep(1)\n     except KeyboardInterrupt:\n-        print(\"\\n\\nðŸ‘‹ Shutting down...\")\n+        print(\"\\n\\nðŸ‘‹ Shutting down...\")\n\\ No newline at end of file"
    },
    {
      "sha": "99d4000689a17dc9b4f187633b0d06057a7474e0",
      "filename": "backend/server_simple.py",
      "status": "removed",
      "additions": 0,
      "deletions": 146,
      "changes": 146,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/2d3d70520cee9077fdc27b77ccff340a7e14093a/backend%2Fserver_simple.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/2d3d70520cee9077fdc27b77ccff340a7e14093a/backend%2Fserver_simple.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fserver_simple.py?ref=2d3d70520cee9077fdc27b77ccff340a7e14093a",
      "patch": "@@ -1,146 +0,0 @@\n-#!/usr/bin/env python3\n-\"\"\"\n-Simplified voice analysis server - stateless, clean API\n-\"\"\"\n-\n-import time\n-from polycli.orchestration.session_registry import session_def, get_registry\n-from polycli import PolyAgent\n-from simple_analyzer import analyze_simple\n-import config\n-\n-@session_def(\n-    name=\"Analyze Text Simple\",\n-    description=\"Simple stateless voice analysis\",\n-    params={\n-        \"text\": {\"type\": \"str\"},\n-        \"session_id\": {\"type\": \"str\"},\n-        \"voices\": {\"type\": \"dict\"}\n-    },\n-    category=\"Analysis\"\n-)\n-def analyze_text(text: str, session_id: str, voices: dict = None):\n-    \"\"\"\n-    Simple stateless analysis - returns voices for given text\n-\n-    Args:\n-        text: Text to analyze (should be complete sentences only)\n-        session_id: Session ID (for future use)\n-        voices: Voice configuration\n-\n-    Returns:\n-        Dictionary with voices array\n-    \"\"\"\n-    print(f\"\\n{'='*60}\")\n-    print(f\"ðŸ“ Simple analysis called\")\n-    print(f\"   Text length: {len(text)}\")\n-    print(f\"   Text: {text[:100]}...\")\n-    print(f\"{'='*60}\\n\")\n-\n-    agent = PolyAgent(id=\"voice-analyzer\")\n-\n-    # Get voices from simple analyzer\n-    result_voices = analyze_simple(agent, text, voices)\n-\n-    print(f\"âœ… Found {len(result_voices)} voices\")\n-\n-    return {\n-        \"voices\": result_voices,\n-        \"new_voices_added\": len(result_voices),  # All are new in stateless mode\n-        \"status\": \"completed\"\n-    }\n-\n-@session_def(\n-    name=\"Chat with Voice\",\n-    description=\"Have a conversation with a voice persona\",\n-    params={\n-        \"voice_name\": {\"type\": \"str\"},\n-        \"voice_config\": {\"type\": \"dict\"},\n-        \"conversation_history\": {\"type\": \"list\"},\n-        \"user_message\": {\"type\": \"str\"},\n-        \"original_text\": {\"type\": \"str\"}\n-    },\n-    category=\"Chat\"\n-)\n-def chat_with_voice(voice_name: str, voice_config: dict, conversation_history: list, user_message: str, original_text: str = \"\"):\n-    \"\"\"\n-    Chat with a specific voice persona (unchanged from original)\n-    \"\"\"\n-    agent = PolyAgent(id=f\"voice-chat-{voice_name.lower()}\")\n-\n-    # Build system prompt for this voice\n-    system_prompt = f\"\"\"You are {voice_name}, an inner voice archetype.\n-\n-Your character: {voice_config.get('tagline', '')}\n-\n-Respond in character as {voice_name}. Be concise (1-3 sentences). Stay true to your archetype.\"\"\"\n-\n-    if original_text and original_text.strip():\n-        system_prompt += f\"\"\"\n-\n-Context: The user is writing this text:\n----\n-{original_text.strip()}\n----\"\"\"\n-\n-    # Build full prompt with conversation history\n-    prompt = system_prompt + \"\\n\\nConversation history:\\n\"\n-\n-    for msg in conversation_history:\n-        role_label = \"User\" if msg[\"role\"] == \"user\" else voice_name\n-        prompt += f\"\\n{role_label}: {msg['content']}\"\n-\n-    prompt += f\"\\n\\nUser: {user_message}\\n\\n{voice_name}:\"\n-\n-    # Get response from LLM\n-    result = agent.run(prompt, model=\"gpt-4o-dou\", cli=\"no-tools\", tracked=True)\n-\n-    if not result.is_success or not result.content:\n-        response = \"...\"\n-    else:\n-        response = result.content\n-\n-    return {\n-        \"response\": response,\n-        \"voice_name\": voice_name\n-    }\n-\n-if __name__ == \"__main__\":\n-    # Get the global registry\n-    registry = get_registry()\n-\n-    # Start the control panel\n-    print(\"\\n\" + \"=\"*60)\n-    print(\"ðŸŽ­ Simple Voice Analysis Server\")\n-    print(\"=\"*60)\n-\n-    # Monkey-patch to add /api/default-voices endpoint\n-    server, thread = registry.serve_control_panel(port=8765)\n-\n-    original_do_get = server.RequestHandlerClass.do_GET\n-    def patched_do_get(handler_self):\n-        if handler_self.path == \"/api/default-voices\":\n-            import json\n-            body = json.dumps(config.VOICE_ARCHETYPES).encode(\"utf-8\")\n-            handler_self.send_response(200)\n-            handler_self.send_header(\"Content-Type\", \"application/json\")\n-            handler_self.send_header(\"Access-Control-Allow-Origin\", \"*\")\n-            handler_self.end_headers()\n-            handler_self.wfile.write(body)\n-        else:\n-            original_do_get(handler_self)\n-\n-    server.RequestHandlerClass.do_GET = patched_do_get\n-\n-    print(\"\\nðŸ“š Available endpoints:\")\n-    print(\"  - POST /api/trigger\")\n-    print(\"    Body: {\\\"session_id\\\": \\\"analyze_text\\\", \\\"params\\\": {\\\"text\\\": \\\"...\\\"}}\")\n-    print(\"  - GET /api/default-voices\")\n-    print(\"\\n\" + \"=\"*60 + \"\\n\")\n-\n-    # Keep server running\n-    try:\n-        while True:\n-            time.sleep(1)\n-    except KeyboardInterrupt:\n-        print(\"\\n\\nðŸ‘‹ Shutting down...\")\n\\ No newline at end of file"
    },
    {
      "sha": "a947f991fc51a1be777a4878e9a2432e8b0c18b5",
      "filename": "backend/server_simpler.py",
      "status": "removed",
      "additions": 0,
      "deletions": 100,
      "changes": 100,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/2d3d70520cee9077fdc27b77ccff340a7e14093a/backend%2Fserver_simpler.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/2d3d70520cee9077fdc27b77ccff340a7e14093a/backend%2Fserver_simpler.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fserver_simpler.py?ref=2d3d70520cee9077fdc27b77ccff340a7e14093a",
      "patch": "@@ -1,100 +0,0 @@\n-#!/usr/bin/env python3\n-\"\"\"Voice analysis server using PolyCLI Session Registry - simplified version.\"\"\"\n-\n-import time\n-from polycli.orchestration.session_registry import session_def, get_registry\n-from polycli import PolyAgent\n-from stateful_analyzer_simple import analyze_stateful\n-import config\n-\n-@session_def(\n-    name=\"Analyze Voices\",\n-    description=\"Detect inner voices in text using Disco Elysium archetypes\",\n-    params={\n-        \"text\": {\"type\": \"str\"},\n-        \"session_id\": {\"type\": \"str\"},\n-        \"voices\": {\"type\": \"dict\"}\n-    },\n-    category=\"Analysis\"\n-)\n-def analyze_text(text: str, session_id: str, voices: dict = None):\n-    \"\"\"\n-    Analyze text and detect inner voice triggers.\n-    Uses stateful analyzer but with SINGLE_COMMENT_MODE.\n-    \"\"\"\n-    print(f\"\\n{'='*60}\")\n-    print(f\"ðŸŽ¯ analyze_text() called\")\n-    print(f\"   Session ID: {session_id}\")\n-    print(f\"   Text length: {len(text)}\")\n-    print(f\"   Text preview: {text[:100]}...\")\n-    print(f\"{'='*60}\\n\")\n-\n-    print(\"Creating PolyAgent...\")\n-    agent = PolyAgent(id=\"voice-analyzer\")\n-\n-    print(\"Calling analyze_stateful pattern...\")\n-    custom_voices = voices or config.VOICE_ARCHETYPES\n-\n-    # Simplified analyzer returns only one comment at a time\n-    analysis_result = analyze_stateful(agent, text, session_id, custom_voices)\n-\n-    # analyze_stateful returns dict with 'voices' and 'new_voices_added'\n-    result_voices = analysis_result[\"voices\"]\n-    new_voices_added = analysis_result[\"new_voices_added\"]\n-\n-    print(f\"âœ… Got {len(result_voices)} total voices ({new_voices_added} new from this LLM call)\")\n-    for i, v in enumerate(result_voices):\n-        print(f\"   {i+1}. {v.get('voice', 'unknown')}: {v.get('comment', '')[:50]}...\")\n-\n-    result = {\n-        \"voices\": result_voices,\n-        \"new_voices_added\": new_voices_added,\n-        \"status\": \"completed\",\n-        \"text_length\": len(text)\n-    }\n-\n-    print(f\"Returning result: {result}\")\n-    print(f\"{'='*60}\\n\")\n-\n-    return result\n-\n-if __name__ == \"__main__\":\n-    # Get the global registry (session auto-registered via decorator)\n-    registry = get_registry()\n-\n-    # Start the control panel\n-    print(\"\\n\" + \"=\"*60)\n-    print(\"ðŸŽ­ Voice Analysis Server (Simplified)\")\n-    print(\"=\"*60)\n-\n-    # Monkey-patch the handler to add /api/default-voices endpoint\n-    server, thread = registry.serve_control_panel(port=8765)\n-\n-    original_do_get = server.RequestHandlerClass.do_GET\n-    def patched_do_get(handler_self):\n-        if handler_self.path == \"/api/default-voices\":\n-            import json\n-            body = json.dumps(config.VOICE_ARCHETYPES).encode(\"utf-8\")\n-            handler_self.send_response(200)\n-            handler_self.send_header(\"Content-Type\", \"application/json\")\n-            handler_self.send_header(\"Access-Control-Allow-Origin\", \"*\")\n-            handler_self.end_headers()\n-            handler_self.wfile.write(body)\n-        else:\n-            original_do_get(handler_self)\n-\n-    server.RequestHandlerClass.do_GET = patched_do_get\n-\n-    print(\"\\nðŸ“š Available endpoints:\")\n-    print(\"  - POST /api/trigger\")\n-    print(\"    Body: {\\\"session_id\\\": \\\"analyze_text\\\", \\\"params\\\": {\\\"text\\\": \\\"...\\\"}}\")\n-    print(\"  - GET /api/sessions (list all sessions)\")\n-    print(\"  - GET /api/default-voices\")\n-    print(\"\\n\" + \"=\"*60 + \"\\n\")\n-\n-    # Keep server running\n-    try:\n-        while True:\n-            time.sleep(1)\n-    except KeyboardInterrupt:\n-        print(\"\\n\\nðŸ‘‹ Shutting down...\")\n\\ No newline at end of file"
    },
    {
      "sha": "07f16aaa646839fe02ee46d5e78083b981a40aa1",
      "filename": "backend/server_stateless.py",
      "status": "removed",
      "additions": 0,
      "deletions": 91,
      "changes": 91,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/2d3d70520cee9077fdc27b77ccff340a7e14093a/backend%2Fserver_stateless.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/2d3d70520cee9077fdc27b77ccff340a7e14093a/backend%2Fserver_stateless.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fserver_stateless.py?ref=2d3d70520cee9077fdc27b77ccff340a7e14093a",
      "patch": "@@ -1,91 +0,0 @@\n-#!/usr/bin/env python3\n-\"\"\"Stateless voice analysis server - no state tracking, just returns new comments.\"\"\"\n-\n-import time\n-from polycli.orchestration.session_registry import session_def, get_registry\n-from polycli import PolyAgent\n-from stateless_analyzer import analyze_stateless\n-import config\n-\n-@session_def(\n-    name=\"Analyze Voices\",\n-    description=\"Get one new voice comment for text\",\n-    params={\n-        \"text\": {\"type\": \"str\"},\n-        \"session_id\": {\"type\": \"str\"},\n-        \"voices\": {\"type\": \"dict\"},\n-        \"applied_comments\": {\"type\": \"list\"}\n-    },\n-    category=\"Analysis\"\n-)\n-def analyze_text(text: str, session_id: str, voices: dict = None, applied_comments: list = None):\n-    \"\"\"\n-    Stateless analysis - returns ONE new comment based on text and applied comments.\n-\n-    Args:\n-        text: Text to analyze (should be complete sentences only)\n-        session_id: Session ID (for future use)\n-        voices: Voice configuration\n-        applied_comments: List of already applied comments (to avoid duplicates)\n-\n-    Returns:\n-        Dictionary with single new voice (or empty list)\n-    \"\"\"\n-    print(f\"\\n{'='*60}\")\n-    print(f\"ðŸŽ¯ Stateless analyze_text() called\")\n-    print(f\"   Text: {text[:100]}...\")\n-    print(f\"   Applied comments: {len(applied_comments or [])}\")\n-    print(f\"{'='*60}\\n\")\n-\n-    agent = PolyAgent(id=\"voice-analyzer\")\n-\n-    # Get voices from stateless analyzer\n-    result = analyze_stateless(agent, text, applied_comments or [], voices)\n-\n-    print(f\"âœ… Returning {result['new_voices_added']} new voice(s)\")\n-\n-    return {\n-        \"voices\": result[\"voices\"],\n-        \"new_voices_added\": result[\"new_voices_added\"],\n-        \"status\": \"completed\"\n-    }\n-\n-if __name__ == \"__main__\":\n-    # Get the global registry\n-    registry = get_registry()\n-\n-    # Start the control panel\n-    print(\"\\n\" + \"=\"*60)\n-    print(\"ðŸŽ­ Stateless Voice Analysis Server\")\n-    print(\"=\"*60)\n-\n-    # Monkey-patch to add /api/default-voices endpoint\n-    server, thread = registry.serve_control_panel(port=8765)\n-\n-    original_do_get = server.RequestHandlerClass.do_GET\n-    def patched_do_get(handler_self):\n-        if handler_self.path == \"/api/default-voices\":\n-            import json\n-            body = json.dumps(config.VOICE_ARCHETYPES).encode(\"utf-8\")\n-            handler_self.send_response(200)\n-            handler_self.send_header(\"Content-Type\", \"application/json\")\n-            handler_self.send_header(\"Access-Control-Allow-Origin\", \"*\")\n-            handler_self.end_headers()\n-            handler_self.wfile.write(body)\n-        else:\n-            original_do_get(handler_self)\n-\n-    server.RequestHandlerClass.do_GET = patched_do_get\n-\n-    print(\"\\nðŸ“š Available endpoints:\")\n-    print(\"  - POST /api/trigger\")\n-    print(\"    Body: {\\\"session_id\\\": \\\"analyze_text\\\", \\\"params\\\": {\\\"text\\\": \\\"...\\\", \\\"applied_comments\\\": [...]}}\")\n-    print(\"  - GET /api/default-voices\")\n-    print(\"\\n\" + \"=\"*60 + \"\\n\")\n-\n-    # Keep server running\n-    try:\n-        while True:\n-            time.sleep(1)\n-    except KeyboardInterrupt:\n-        print(\"\\n\\nðŸ‘‹ Shutting down...\")\n\\ No newline at end of file"
    },
    {
      "sha": "3df88732aefc45df506c430657c846f9e0817c8c",
      "filename": "backend/simple_analyzer.py",
      "status": "removed",
      "additions": 0,
      "deletions": 101,
      "changes": 101,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/2d3d70520cee9077fdc27b77ccff340a7e14093a/backend%2Fsimple_analyzer.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/2d3d70520cee9077fdc27b77ccff340a7e14093a/backend%2Fsimple_analyzer.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fsimple_analyzer.py?ref=2d3d70520cee9077fdc27b77ccff340a7e14093a",
      "patch": "@@ -1,101 +0,0 @@\n-#!/usr/bin/env python3\n-\"\"\"\n-Simplified voice analyzer - stateless, no density enforcement\n-Just returns voices for given text\n-\"\"\"\n-\n-from typing import List, Optional\n-from pydantic import BaseModel, Field\n-from polycli import PolyAgent\n-import config\n-\n-class VoiceTrigger(BaseModel):\n-    phrase: str = Field(description=\"Exact trigger phrase from text (verbatim, 2-6 words ideal)\")\n-    voice: str = Field(description=\"Voice archetype name from the available list\")\n-    comment: str = Field(description=\"What this voice is saying (as if speaking)\")\n-    icon: str = Field(description=\"Icon identifier\")\n-    color: str = Field(description=\"Color identifier\")\n-\n-class SingleVoice(BaseModel):\n-    voice: Optional[VoiceTrigger] = Field(description=\"Single voice trigger, or None if nothing to comment\")\n-\n-def analyze_simple(agent: PolyAgent, text: str, voices: dict = None) -> List[dict]:\n-    \"\"\"\n-    Simple stateless analysis - just return voices for the given text\n-\n-    Args:\n-        agent: PolyAgent instance\n-        text: Text to analyze\n-        voices: Voice configuration\n-\n-    Returns:\n-        List of voice dictionaries\n-    \"\"\"\n-    # Skip if text too short\n-    if len(text.strip()) < 20:\n-        return []\n-\n-    # Use provided voices or defaults\n-    voice_archetypes = voices or config.VOICE_ARCHETYPES\n-\n-    # Build voice list for prompt\n-    voice_list = \"\\n\".join([\n-        f\"- {v.get('name', name)} ({v['icon']}, {v['color']}): {v['tagline']}\"\n-        for name, v in voice_archetypes.items()\n-    ])\n-\n-    prompt = f\"\"\"You are analyzing internal dialogue as distinct inner voice personas.\n-\n-Analyze this text and identify ONE voice that wants to comment:\n-\n-\"{text}\"\n-\n-Available voice personas (ONLY use these):\n-{voice_list}\n-\n-Find ONE voice to comment:\n-1. Extract a SHORT phrase (2-6 words) that triggered it - MUST be EXACT text from above\n-2. Choose the matching voice persona from the list\n-3. Write what this voice is saying (1-2 sentences)\n-4. Use the voice's designated icon and color\n-\n-Rules:\n-- Return ONLY ONE voice comment (the most interesting/relevant one)\n-- Quality over quantity - be selective\n-- Phrase MUST be exact substring from text\n-- Only comment on complete sentences (ending with .!?ã€‚ï¼ï¼Ÿ)\n-- Return null if nothing is worth commenting on\n-- Respond in the SAME LANGUAGE as the text\"\"\"\n-\n-    # Get analysis from LLM\n-    result = agent.run(\n-        prompt,\n-        model=config.MODEL,\n-        cli=\"no-tools\",\n-        schema_cls=SingleVoice,\n-        tracked=True\n-    )\n-\n-    if not result.is_success or not result.has_data():\n-        return []\n-\n-    voice = result.data.get(\"voice\")\n-    voices = [voice] if voice else []\n-\n-    # Map user-defined names back to get correct icon/color\n-    name_to_key = {}\n-    for key, v in voice_archetypes.items():\n-        user_name = v.get(\"name\", key)\n-        name_to_key[user_name] = key\n-\n-    # Update icon/color from config\n-    for v in voices:\n-        if v:\n-            llm_voice_name = v.get(\"voice\")\n-            archetype_key = name_to_key.get(llm_voice_name)\n-            if archetype_key and archetype_key in voice_archetypes:\n-                v[\"icon\"] = voice_archetypes[archetype_key][\"icon\"]\n-                v[\"color\"] = voice_archetypes[archetype_key][\"color\"]\n-                v[\"voice\"] = llm_voice_name  # Keep user-defined name\n-\n-    return voices\n\\ No newline at end of file"
    },
    {
      "sha": "4e25921bb38fe816f4f938e0df903d7ad9fb3405",
      "filename": "backend/stateful_analyzer.py",
      "status": "removed",
      "additions": 0,
      "deletions": 374,
      "changes": 374,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/2d3d70520cee9077fdc27b77ccff340a7e14093a/backend%2Fstateful_analyzer.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/2d3d70520cee9077fdc27b77ccff340a7e14093a/backend%2Fstateful_analyzer.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fstateful_analyzer.py?ref=2d3d70520cee9077fdc27b77ccff340a7e14093a",
      "patch": "@@ -1,374 +0,0 @@\n-#!/usr/bin/env python3\n-\"\"\"Stateful voice analyzer that tracks comments across continuous writing.\"\"\"\n-\n-from pathlib import Path\n-from typing import Optional\n-from pydantic import BaseModel, Field\n-from polycli import PolyAgent\n-from polycli.orchestration import pattern\n-import config\n-import re\n-import time\n-\n-class VoiceTrigger(BaseModel):\n-    phrase: str = Field(description=\"Exact trigger phrase from text (verbatim)\")\n-    voice: str = Field(description=\"Voice archetype name from the available list\")\n-    comment: str = Field(description=\"What this voice is saying (as if speaking)\")\n-    icon: str = Field(description=\"Icon: brain, heart, question, cloud, masks, eye, fist, lightbulb, shield, wind, fire, compass\")\n-    color: str = Field(description=\"Color: blue, pink, yellow, green, purple\")\n-\n-class VoiceAnalysis(BaseModel):\n-    voices: list[VoiceTrigger] = Field(description=\"Detected voice triggers\")\n-\n-class SingleVoiceAnalysis(BaseModel):\n-    voice: Optional[VoiceTrigger] = Field(description=\"Single voice trigger\", default=None)\n-\n-class StatefulVoiceAnalyzer:\n-    \"\"\"\n-    Stateful analyzer that:\n-    1. Tracks existing comments\n-    2. Prunes comments when trigger text is deleted\n-    3. Only asks LLM for new comments\n-    4. Enforces density rules (1 per persona, 1 per sentence)\n-    \"\"\"\n-\n-    def __init__(self):\n-        self.comments = []  # List of dicts: {phrase, voice, comment, icon, color}\n-        self.last_text = \"\"\n-\n-    def _prune_deleted_comments(self, text: str):\n-        \"\"\"Remove comments whose trigger phrases no longer exist in text.\"\"\"\n-        self.comments = [\n-            c for c in self.comments\n-            if c[\"phrase\"].lower() in text.lower()\n-        ]\n-\n-    def _get_sentences(self, text: str) -> list[str]:\n-        \"\"\"Split text into sentences (supports English and Chinese).\"\"\"\n-        # @@@ multilingual-sentence-split - English: .!? Chinese: ã€‚ï¼ï¼Ÿï¼Œ\n-        # Also treat newlines as sentence boundaries\n-        sentences = re.split(r'[.!?ã€‚ï¼ï¼Ÿï¼Œ]+|\\n+', text)\n-        return [s.strip() for s in sentences if s.strip()]\n-\n-    def _get_commented_regions(self, text: str) -> list[tuple[int, int]]:\n-        \"\"\"Get character ranges that already have comments.\"\"\"\n-        regions = []\n-        for comment in self.comments:\n-            phrase = comment[\"phrase\"]\n-            # Find all occurrences (case-insensitive)\n-            text_lower = text.lower()\n-            phrase_lower = phrase.lower()\n-            start = 0\n-            while True:\n-                pos = text_lower.find(phrase_lower, start)\n-                if pos == -1:\n-                    break\n-                regions.append((pos, pos + len(phrase)))\n-                start = pos + 1\n-        return regions\n-\n-    def _enforce_density(self, new_comments: list[dict], text: str) -> list[dict]:\n-        \"\"\"\n-        Enforce density rules:\n-        1. Max 1 persona per sentence\n-        \"\"\"\n-        # Get sentence boundaries\n-        sentences = self._get_sentences(text)\n-        sentence_positions = []\n-        pos = 0\n-        for sent in sentences:\n-            start = text.lower().find(sent.lower(), pos)\n-            if start != -1:\n-                sentence_positions.append((start, start + len(sent), sent))\n-                pos = start + len(sent)\n-\n-        # Track which sentences have comments\n-        sentence_has_comment = [False] * len(sentence_positions)\n-        for comment in self.comments:\n-            phrase_pos = text.lower().find(comment[\"phrase\"].lower())\n-            if phrase_pos != -1:\n-                for i, (start, end, _) in enumerate(sentence_positions):\n-                    if start <= phrase_pos < end:\n-                        sentence_has_comment[i] = True\n-                        break\n-\n-        # Filter new comments\n-        filtered = []\n-        for comment in new_comments:\n-            voice = comment[\"voice\"]\n-            phrase = comment[\"phrase\"]\n-\n-            # Rule: Only 1 comment per sentence\n-            phrase_pos = text.lower().find(phrase.lower())\n-            if phrase_pos == -1:\n-                continue\n-\n-            # Find which sentence this belongs to\n-            comment_sentence_idx = None\n-            for i, (start, end, _) in enumerate(sentence_positions):\n-                if start <= phrase_pos < end:\n-                    comment_sentence_idx = i\n-                    break\n-\n-            if comment_sentence_idx is not None and sentence_has_comment[comment_sentence_idx]:\n-                continue\n-\n-            # Accept this comment\n-            filtered.append(comment)\n-            if comment_sentence_idx is not None:\n-                sentence_has_comment[comment_sentence_idx] = True\n-\n-        return filtered\n-\n-    @pattern\n-    def analyze(self, agent: PolyAgent, text: str, voices: dict = None) -> dict:\n-        \"\"\"\n-        Analyze text and return ALL comments (existing + new) plus metadata.\n-\n-        Args:\n-            agent: PolyAgent instance\n-            text: Current text\n-\n-        Returns:\n-            Dict with 'voices' (complete list) and 'new_voices_added' (count of new voices from this LLM call)\n-        \"\"\"\n-        print(f\"\\n{'='*60}\")\n-        print(f\"ðŸ“Š Stateful Analysis\")\n-        print(f\"   Text length: {len(text)}\")\n-        print(f\"   Existing comments: {len(self.comments)}\")\n-        print(f\"{'='*60}\\n\")\n-\n-        # Step 1: Prune deleted comments\n-        old_count = len(self.comments)\n-        self._prune_deleted_comments(text)\n-        if len(self.comments) < old_count:\n-            print(f\"ðŸ—‘ï¸  Pruned {old_count - len(self.comments)} deleted comments\")\n-\n-        # Step 2: Check if we need new analysis\n-        if len(text.strip()) < config.MIN_TEXT_LENGTH:\n-            print(\"â­ï¸  Text too short, returning existing comments\")\n-            return {\"voices\": self.comments, \"new_voices_added\": 0}\n-\n-        # @@@ Removed debouncing - allow multiple LLM calls on same text\n-        # This enables energy pool to trigger multiple times and get different comments\n-        # The LLM prompt includes existing comments, so it will return new ones\n-\n-        # Step 3: Build prompt with existing comments\n-        voice_archetypes = voices or config.VOICE_ARCHETYPES\n-        # @@@ Use user-defined 'name' (e.g., \"å•å¸ƒ\") instead of key (e.g., \"Composure\")\n-        # This prevents LLM from hallucinating Disco Elysium characters\n-        voice_list = \"\\n\".join([\n-            f\"- {v.get('name', name)} ({v['icon']}, {v['color']}): {v['tagline']}\"\n-            for name, v in voice_archetypes.items()\n-        ])\n-\n-        # @@@ Build list of occupied sentences AND used personas to guide LLM\n-        existing_summary = \"\"\n-        if self.comments:\n-            # Get sentence boundaries\n-            sentences = self._get_sentences(text)\n-            sentence_positions = []\n-            pos = 0\n-            for sent in sentences:\n-                start = text.lower().find(sent.lower(), pos)\n-                if start != -1:\n-                    sentence_positions.append((start, start + len(sent), sent))\n-                    pos = start + len(sent)\n-\n-            # Find which sentences are occupied\n-            occupied_sentences = set()\n-            for comment in self.comments:\n-                phrase_pos = text.lower().find(comment[\"phrase\"].lower())\n-                if phrase_pos != -1:\n-                    for i, (start, end, sent) in enumerate(sentence_positions):\n-                        if start <= phrase_pos < end:\n-                            occupied_sentences.add(i)\n-                            break\n-\n-            # Build summary with occupied sentences\n-            existing_summary = \"\\n\\nEXISTING COMMENTS:\\n\"\n-            for c in self.comments:\n-                existing_summary += f\"- {c['voice']} commented on phrase \\\"{c['phrase']}\\\": {c['comment']}\\n\"\n-\n-            if occupied_sentences:\n-                # @@@ phrase-vs-sentence - LLM must understand that even though only a phrase is highlighted,\n-                # the ENTIRE sentence containing that phrase is off-limits for new comments\n-                existing_summary += f\"\\nâš ï¸  OCCUPIED SENTENCES (already have comments, CANNOT comment anywhere in these sentences):\\n\"\n-                existing_summary += \"NOTE: Even though only a PHRASE is highlighted/commented, the rule is that the ENTIRE SENTENCE containing that phrase is now occupied.\\n\"\n-                existing_summary += \"You cannot add any new comment to any part of these full sentences:\\n\\n\"\n-                for i in sorted(occupied_sentences):\n-                    if i < len(sentence_positions):\n-                        full_sentence = sentence_positions[i][2]  # Show FULL sentence, no truncation\n-                        # Find which comment triggered this sentence\n-                        trigger_phrase = None\n-                        for c in self.comments:\n-                            phrase_pos = text.lower().find(c[\"phrase\"].lower())\n-                            if phrase_pos != -1:\n-                                start, end, _ = sentence_positions[i]\n-                                if start <= phrase_pos < end:\n-                                    trigger_phrase = c[\"phrase\"]\n-                                    break\n-\n-                        existing_summary += f\"  Sentence {i+1} (triggered by phrase \\\"{trigger_phrase}\\\"):\\n\"\n-                        existing_summary += f\"  \\\"{full_sentence}\\\"\\n\\n\"\n-                existing_summary += \"ðŸ‘‰ Focus your analysis on NEW/UNCOMMENTED sentences only!\\n\"\n-\n-        prompt = f\"\"\"You are analyzing internal dialogue as distinct inner voice personas.\n-\n-Analyze this text and identify NEW voices that want to comment:\n-\n-\"{text}\"\n-\n-Available voice personas (THESE ARE THE ONLY VOICES YOU CAN USE - DO NOT CREATE NEW ONES):\n-{voice_list}\n-{existing_summary}\n-\n-For each NEW voice you detect:\n-1. Extract a SHORT phrase that triggered it (**MUST be EXACT verbatim text from the user's writing, character-by-character match**)\n-   - The phrase should be SMALL - typically 2-6 words, the most essential/striking part\n-   - This phrase will be HIGHLIGHTED in the UI - keep it concise!\n-   - âœ… Good examples: \"contemplative walk\", \"thinking about meaning\", \"life and death\"\n-   - âŒ Bad examples: (whole sentences, too long, not focused)\n-   - **CRITICAL: The phrase MUST exist EXACTLY as written in the text. Do not paraphrase, rearrange, or modify ANY characters.**\n-2. Choose the matching voice persona **FROM THE AVAILABLE LIST ABOVE ONLY**\n-3. Write what this voice is saying (as if the voice itself is speaking)\n-4. Use the voice's designated icon and color\n-\n-CRITICAL DISTINCTION:\n-- **Phrase** = SHORT essential words you return (what gets highlighted, 2-6 words ideal)\n-- **Sentence** = The occupation boundary (you can't comment anywhere else in that sentence)\n-- Even though your phrase is short, it occupies the ENTIRE sentence it appears in\n-\n-STRICT RULES:\n-- Maximum {config.MAX_VOICES} NEW voices\n-- **DO NOT CREATE OR INVENT NEW VOICE NAMES** - Only use the exact voice names from the available list above\n-- **It's perfectly fine to return NO comment (null) if nothing is worth commenting on**\n-- Only identify clearly present voices - quality over quantity\n-- **Phrase MUST be EXACT verbatim substring from text** (character-by-character match, no changes allowed)\n-- Each voice should be distinct\n-- DO NOT comment on parts that already have comments\n-- Avoid commenting too close to existing comments\n-- DO NOT comment on the last sentence if it appears incomplete (no ending punctuation like .!?ã€‚ï¼ï¼Ÿ)\n-- **If all available sentences are already occupied or incomplete, return null**\n-- Write comments in the SAME LANGUAGE as the text being analyzed (if text is Chinese, respond in Chinese; if English, respond in English)\n-\"\"\"\n-\n-        print(\"ðŸ¤– Calling LLM for new comments...\")\n-\n-        # Choose schema based on config\n-        if config.SINGLE_COMMENT_MODE:\n-            schema_cls = SingleVoiceAnalysis\n-            max_voices_for_prompt = 1\n-        else:\n-            schema_cls = VoiceAnalysis\n-            max_voices_for_prompt = config.MAX_VOICES\n-\n-        # Update prompt with correct max_voices\n-        prompt = prompt.replace(f\"Maximum {config.MAX_VOICES} NEW voices\", f\"Maximum {max_voices_for_prompt} NEW voices\")\n-\n-        result = agent.run(\n-            prompt,\n-            model=config.MODEL,\n-            cli=\"no-tools\",\n-            schema_cls=schema_cls,\n-            tracked=True\n-        )\n-\n-        if not result.is_success or not result.has_data():\n-            print(\"âŒ LLM failed, returning existing comments\")\n-            return {\"voices\": self.comments, \"new_voices_added\": 0}\n-\n-        # Extract voices based on schema type\n-        if config.SINGLE_COMMENT_MODE:\n-            voice = result.data.get(\"voice\")\n-            new_voices = [voice] if voice else []\n-        else:\n-            new_voices = result.data.get(\"voices\", [])\n-\n-        print(f\"âœ… LLM returned {len(new_voices)} new comments\")\n-\n-        # @@@ Build name â†’ key mapping (e.g., \"å•å¸ƒ\" â†’ \"Composure\")\n-        # LLM now returns user-defined names, we need to find the corresponding key\n-        name_to_key = {}\n-        for key, v in voice_archetypes.items():\n-            user_name = v.get(\"name\", key)\n-            name_to_key[user_name] = key\n-\n-        # @@@ Override LLM's icon/color with actual config values\n-        # LLM returns user-defined name (e.g., \"å•å¸ƒ\"), we map back to key (e.g., \"Composure\")\n-        for v in new_voices:\n-            if v:\n-                llm_voice_name = v.get(\"voice\")\n-                # Find the key for this name\n-                archetype_key = name_to_key.get(llm_voice_name)\n-                if archetype_key and archetype_key in voice_archetypes:\n-                    v[\"icon\"] = voice_archetypes[archetype_key][\"icon\"]\n-                    v[\"color\"] = voice_archetypes[archetype_key][\"color\"]\n-                    # Keep the user-defined name (already correct from LLM)\n-                    v[\"voice\"] = llm_voice_name\n-\n-        # Step 4: Enforce density rules\n-        filtered_voices = self._enforce_density(new_voices, text)\n-        print(f\"ðŸ“ After density filter: {len(filtered_voices)} comments\")\n-\n-        # Step 5: Merge with existing comments\n-        self.comments.extend(filtered_voices)\n-        self.last_text = text\n-\n-        print(f\"ðŸ“ Total comments: {len(self.comments)}\")\n-        for i, c in enumerate(self.comments):\n-            print(f\"   {i+1}. {c['voice']}: \\\"{c['phrase'][:30]}...\\\"\")\n-        print(f\"{'='*60}\\n\")\n-\n-        # @@@ Return both voices and metadata about new voices added\n-        return {\n-            \"voices\": self.comments,\n-            \"new_voices_added\": len(filtered_voices)\n-        }\n-\n-# @@@ Multi-user support - Session-based storage\n-# Each user gets their own analyzer instance, keyed by session_id\n-_user_analyzers = {}  # session_id -> StatefulVoiceAnalyzer\n-_last_access = {}     # session_id -> timestamp\n-\n-# @@@ Session cleanup config\n-SESSION_TTL = 3600  # 1 hour - sessions inactive for this long will be cleaned up\n-\n-def cleanup_stale_sessions():\n-    \"\"\"Remove sessions that haven't been accessed in SESSION_TTL seconds.\"\"\"\n-    now = time.time()\n-    stale_sessions = [\n-        sid for sid, last_time in _last_access.items()\n-        if now - last_time > SESSION_TTL\n-    ]\n-\n-    for sid in stale_sessions:\n-        print(f\"ðŸ—‘ï¸  Cleaning up stale session: {sid} (inactive for {SESSION_TTL}s)\")\n-        del _user_analyzers[sid]\n-        del _last_access[sid]\n-\n-    if stale_sessions:\n-        print(f\"ðŸ“Š Active sessions: {len(_user_analyzers)}\")\n-\n-def get_analyzer(session_id: str) -> StatefulVoiceAnalyzer:\n-    \"\"\"Get or create analyzer for this user session.\"\"\"\n-    if session_id not in _user_analyzers:\n-        print(f\"ðŸ†• Creating new analyzer for session: {session_id}\")\n-        _user_analyzers[session_id] = StatefulVoiceAnalyzer()\n-\n-    # Update last access time\n-    _last_access[session_id] = time.time()\n-\n-    return _user_analyzers[session_id]\n-\n-def analyze_stateful(agent: PolyAgent, text: str, session_id: str, voices: dict = None) -> dict:\n-    \"\"\"Analyze text using session-isolated analyzer.\n-\n-    Returns:\n-        Dict with 'voices' (list of all comments) and 'new_voices_added' (count of new voices from this LLM call)\n-    \"\"\"\n-    # Cleanup stale sessions before processing\n-    cleanup_stale_sessions()\n-\n-    analyzer = get_analyzer(session_id)\n-    return analyzer.analyze(agent, text, voices)"
    },
    {
      "sha": "c17c0d1d30e7e03e75742c6faed0c036fc77195d",
      "filename": "backend/stateful_analyzer_simple.py",
      "status": "removed",
      "additions": 0,
      "deletions": 200,
      "changes": 200,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/2d3d70520cee9077fdc27b77ccff340a7e14093a/backend%2Fstateful_analyzer_simple.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/2d3d70520cee9077fdc27b77ccff340a7e14093a/backend%2Fstateful_analyzer_simple.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fstateful_analyzer_simple.py?ref=2d3d70520cee9077fdc27b77ccff340a7e14093a",
      "patch": "@@ -1,200 +0,0 @@\n-#!/usr/bin/env python3\n-\"\"\"Simplified stateful voice analyzer - tracks comments but with fewer constraints.\"\"\"\n-\n-from pathlib import Path\n-from typing import Optional\n-from pydantic import BaseModel, Field\n-from polycli import PolyAgent\n-from polycli.orchestration import pattern\n-import config\n-import re\n-import time\n-\n-class VoiceTrigger(BaseModel):\n-    phrase: str = Field(description=\"Exact trigger phrase from text (verbatim)\")\n-    voice: str = Field(description=\"Voice archetype name from the available list\")\n-    comment: str = Field(description=\"What this voice is saying (as if speaking)\")\n-    icon: str = Field(description=\"Icon: brain, heart, question, cloud, masks, eye, fist, lightbulb, shield, wind, fire, compass\")\n-    color: str = Field(description=\"Color: blue, pink, yellow, green, purple\")\n-\n-class SingleVoiceAnalysis(BaseModel):\n-    voice: Optional[VoiceTrigger] = Field(description=\"Single voice trigger\", default=None)\n-\n-class StatefulVoiceAnalyzer:\n-    \"\"\"\n-    Simplified stateful analyzer that:\n-    1. Tracks APPLIED comments only\n-    2. Only asks LLM for new comments\n-    3. Returns ONE comment at a time\n-    \"\"\"\n-\n-    def __init__(self):\n-        self.applied_comments = []  # List of APPLIED comments only\n-        self.last_text = \"\"\n-\n-    def _prune_deleted_comments(self, text: str):\n-        \"\"\"Remove comments whose trigger phrases no longer exist in text.\"\"\"\n-        self.comments = [\n-            c for c in self.comments\n-            if c[\"phrase\"].lower() in text.lower()\n-        ]\n-\n-    @pattern\n-    def analyze(self, agent: PolyAgent, text: str, voices: dict = None) -> dict:\n-        \"\"\"\n-        Analyze text and return ALL comments (existing + new) plus metadata.\n-        Simplified version - just returns ONE new comment at a time.\n-        \"\"\"\n-        print(f\"\\n{'='*60}\")\n-        print(f\"ðŸ“Š Simplified Stateful Analysis\")\n-        print(f\"   Text length: {len(text)}\")\n-        print(f\"   Existing comments: {len(self.comments)}\")\n-        print(f\"{'='*60}\\n\")\n-\n-        # Step 1: Prune deleted comments\n-        old_count = len(self.comments)\n-        self._prune_deleted_comments(text)\n-        if len(self.comments) < old_count:\n-            print(f\"ðŸ—‘ï¸  Pruned {old_count - len(self.comments)} deleted comments\")\n-\n-        # Step 2: Build prompt with existing comments\n-        voice_archetypes = voices or config.VOICE_ARCHETYPES\n-        # Use user-defined 'name' (e.g., \"å•å¸ƒ\") instead of key (e.g., \"Composure\")\n-        voice_list = \"\\n\".join([\n-            f\"- {v.get('name', name)} ({v['icon']}, {v['color']}): {v['tagline']}\"\n-            for name, v in voice_archetypes.items()\n-        ])\n-\n-        # Build list of existing comments\n-        existing_summary = \"\"\n-        if self.comments:\n-            existing_summary = \"\\n\\nEXISTING COMMENTS (do not repeat these):\\n\"\n-            for c in self.comments:\n-                existing_summary += f\"- {c['voice']} commented on \\\"{c['phrase']}\\\": {c['comment']}\\n\"\n-            existing_summary += \"\\nðŸ‘‰ Find something NEW to comment on!\\n\"\n-\n-        prompt = f\"\"\"You are analyzing internal dialogue as distinct inner voice personas.\n-\n-Analyze this text and identify ONE NEW voice that wants to comment:\n-\n-\"{text}\"\n-\n-Available voice personas (THESE ARE THE ONLY VOICES YOU CAN USE):\n-{voice_list}\n-{existing_summary}\n-\n-Find ONE NEW voice to comment:\n-1. Extract a SHORT phrase (2-6 words ideal) that triggered it - MUST be EXACT text from above\n-2. Choose the matching voice persona from the list\n-3. Write what this voice is saying (1-2 sentences)\n-4. Use the voice's designated icon and color\n-\n-RULES:\n-- Return ONLY ONE comment (the most interesting/relevant one)\n-- DO NOT repeat existing comments\n-- DO NOT CREATE NEW VOICE NAMES - Only use the exact voice names from the available list\n-- It's perfectly fine to return null if nothing new is worth commenting on\n-- Phrase MUST be EXACT verbatim substring from text\n-- Only comment on complete sentences (ending with .!?ã€‚ï¼ï¼Ÿ)\n-- Write comments in the SAME LANGUAGE as the text\"\"\"\n-\n-        print(\"ðŸ¤– Calling LLM for ONE new comment...\")\n-\n-        result = agent.run(\n-            prompt,\n-            model=config.MODEL,\n-            cli=\"no-tools\",\n-            schema_cls=SingleVoiceAnalysis,\n-            tracked=True\n-        )\n-\n-        if not result.is_success or not result.has_data():\n-            print(\"âŒ LLM failed, returning existing comments\")\n-            return {\"voices\": self.comments, \"new_voices_added\": 0}\n-\n-        # Extract single voice\n-        voice = result.data.get(\"voice\")\n-        new_voices = [voice] if voice else []\n-\n-        print(f\"âœ… LLM returned {'1 new comment' if voice else 'no new comment'}\")\n-\n-        if new_voices:\n-            # Build name â†’ key mapping (e.g., \"å•å¸ƒ\" â†’ \"Composure\")\n-            name_to_key = {}\n-            for key, v in voice_archetypes.items():\n-                user_name = v.get(\"name\", key)\n-                name_to_key[user_name] = key\n-\n-            # Override LLM's icon/color with actual config values\n-            for v in new_voices:\n-                if v:\n-                    llm_voice_name = v.get(\"voice\")\n-                    # Find the key for this name\n-                    archetype_key = name_to_key.get(llm_voice_name)\n-                    if archetype_key and archetype_key in voice_archetypes:\n-                        v[\"icon\"] = voice_archetypes[archetype_key][\"icon\"]\n-                        v[\"color\"] = voice_archetypes[archetype_key][\"color\"]\n-                        # Keep the user-defined name (already correct from LLM)\n-                        v[\"voice\"] = llm_voice_name\n-\n-            # Add to our comments\n-            self.comments.extend(new_voices)\n-\n-        self.last_text = text\n-\n-        print(f\"ðŸ“ Total comments: {len(self.comments)}\")\n-        for i, c in enumerate(self.comments):\n-            print(f\"   {i+1}. {c['voice']}: \\\"{c['phrase'][:30]}...\\\"\")\n-        print(f\"{'='*60}\\n\")\n-\n-        # Return both voices and metadata about new voices added\n-        return {\n-            \"voices\": self.comments,\n-            \"new_voices_added\": len(new_voices)\n-        }\n-\n-# Multi-user support - Session-based storage\n-_user_analyzers = {}  # session_id -> StatefulVoiceAnalyzer\n-_last_access = {}     # session_id -> timestamp\n-\n-# Session cleanup config\n-SESSION_TTL = 3600  # 1 hour - sessions inactive for this long will be cleaned up\n-\n-def cleanup_stale_sessions():\n-    \"\"\"Remove sessions that haven't been accessed in SESSION_TTL seconds.\"\"\"\n-    now = time.time()\n-    stale_sessions = [\n-        sid for sid, last_time in _last_access.items()\n-        if now - last_time > SESSION_TTL\n-    ]\n-\n-    for sid in stale_sessions:\n-        print(f\"ðŸ—‘ï¸  Cleaning up stale session: {sid} (inactive for {SESSION_TTL}s)\")\n-        del _user_analyzers[sid]\n-        del _last_access[sid]\n-\n-    if stale_sessions:\n-        print(f\"ðŸ“Š Active sessions: {len(_user_analyzers)}\")\n-\n-def get_analyzer(session_id: str) -> StatefulVoiceAnalyzer:\n-    \"\"\"Get or create analyzer for this user session.\"\"\"\n-    if session_id not in _user_analyzers:\n-        print(f\"ðŸ†• Creating new analyzer for session: {session_id}\")\n-        _user_analyzers[session_id] = StatefulVoiceAnalyzer()\n-\n-    # Update last access time\n-    _last_access[session_id] = time.time()\n-\n-    return _user_analyzers[session_id]\n-\n-def analyze_stateful(agent: PolyAgent, text: str, session_id: str, voices: dict = None) -> dict:\n-    \"\"\"Analyze text using session-isolated analyzer.\n-\n-    Returns:\n-        Dict with 'voices' (list of all comments) and 'new_voices_added' (count of new voices from this LLM call)\n-    \"\"\"\n-    # Cleanup stale sessions before processing\n-    cleanup_stale_sessions()\n-\n-    analyzer = get_analyzer(session_id)\n-    return analyzer.analyze(agent, text, voices)\n\\ No newline at end of file"
    },
    {
      "sha": "6d8d3d7e85778c04c7098d0af1050a451bb03020",
      "filename": "frontend/src/App.tsx",
      "status": "modified",
      "additions": 852,
      "deletions": 369,
      "changes": 1221,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/a4eb52998c60b0de1bbf875423f681091b5eb39a/frontend%2Fsrc%2FApp.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/a4eb52998c60b0de1bbf875423f681091b5eb39a/frontend%2Fsrc%2FApp.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2FApp.tsx?ref=a4eb52998c60b0de1bbf875423f681091b5eb39a",
      "patch": "@@ -1,91 +1,102 @@\n import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\n import { EditorEngine } from './engine/EditorEngine';\n import type { EditorState, Commentor, TextCell } from './engine/EditorEngine';\n+import { ChatWidget } from './engine/ChatWidget';\n+import type { ChatWidgetData } from './engine/ChatWidget';\n import './App.css';\n import {\n   FaSync, FaBold, FaItalic, FaUnderline, FaAlignLeft, FaAlignCenter,\n   FaAlignRight, FaListUl, FaListOl, FaQuoteRight, FaTable, FaLink, FaImage,\n   FaBrain, FaHeart, FaQuestion, FaCloud, FaTheaterMasks, FaEye,\n   FaFistRaised, FaLightbulb, FaShieldAlt, FaWind, FaFire, FaCompass\n } from 'react-icons/fa';\n-\n-// @@@ Left Toolbar Component\n-function LeftToolbar({ onStartFresh }: { onStartFresh: () => void }) {\n-  const tools = [\n-    { icon: FaSync, tooltip: 'Start Fresh', action: onStartFresh, functional: true, separator: true },\n-    { icon: FaBold, tooltip: 'Bold', functional: false, separator: false },\n-    { icon: FaItalic, tooltip: 'Italic', functional: false, separator: false },\n-    { icon: FaUnderline, tooltip: 'Underline', functional: false, separator: true },\n-    { icon: FaAlignLeft, tooltip: 'Align Left', functional: false, separator: false },\n-    { icon: FaAlignCenter, tooltip: 'Align Center', functional: false, separator: false },\n-    { icon: FaAlignRight, tooltip: 'Align Right', functional: false, separator: true },\n-    { icon: FaListUl, tooltip: 'Bullet List', functional: false, separator: false },\n-    { icon: FaListOl, tooltip: 'Numbered List', functional: false, separator: true },\n-    { icon: FaQuoteRight, tooltip: 'Quote', functional: false, separator: false },\n-    { icon: FaTable, tooltip: 'Insert Table', functional: false, separator: false },\n-    { icon: FaLink, tooltip: 'Insert Link', functional: false, separator: false },\n-    { icon: FaImage, tooltip: 'Insert Image', functional: false, separator: false },\n-  ];\n-\n+import LeftSidebar from './components/LeftSidebar';\n+import VoiceSettings from './components/VoiceSettings';\n+import CalendarView from './components/CalendarView';\n+import AnalysisView from './components/AnalysisView';\n+import AboutView from './components/AboutView';\n+import AgentDropdown from './components/AgentDropdown';\n+import ChatWidgetUI from './components/ChatWidgetUI';\n+import type { VoiceConfig } from './types/voice';\n+import { getVoices } from './utils/voiceStorage';\n+import { getDefaultVoices, chatWithVoice } from './api/voiceApi';\n+\n+// @@@ Left Toolbar Component - floating toolbelt within left margin\n+function LeftToolbar({ onStartFresh, onInsertAgent }: { onStartFresh: () => void; onInsertAgent: () => void }) {\n   return (\n     <div style={{\n-      width: '48px',\n-      borderRight: '1px solid #e0e0e0',\n-      backgroundColor: '#fafafa',\n+      position: 'sticky',\n+      top: '80px',\n+      width: '40px',\n+      margin: '30px auto 0',\n+      backgroundColor: '#fff',\n+      border: '1px solid #e0e0e0',\n+      borderRadius: '8px',\n+      boxShadow: '0 2px 8px rgba(0,0,0,0.1)',\n       display: 'flex',\n       flexDirection: 'column',\n       alignItems: 'center',\n-      paddingTop: '10px',\n+      padding: '10px 0',\n       gap: '4px'\n     }}>\n-      {tools.map((tool, idx) => (\n-        <React.Fragment key={idx}>\n-          <button\n-            onClick={tool.functional ? tool.action : undefined}\n-            disabled={!tool.functional}\n-            title={tool.tooltip}\n-            style={{\n-              width: '36px',\n-              height: '36px',\n-              border: 'none',\n-              borderRadius: '4px',\n-              backgroundColor: tool.functional ? '#fff' : 'transparent',\n-              cursor: tool.functional ? 'pointer' : 'not-allowed',\n-              display: 'flex',\n-              alignItems: 'center',\n-              justifyContent: 'center',\n-              opacity: tool.functional ? 1 : 0.3,\n-              transition: 'all 0.2s ease',\n-              ...(tool.functional && {\n-                ':hover': {\n-                  backgroundColor: '#f0f0f0'\n-                }\n-              })\n-            }}\n-            onMouseEnter={tool.functional ? (e) => {\n-              e.currentTarget.style.backgroundColor = '#f0f0f0';\n-            } : undefined}\n-            onMouseLeave={tool.functional ? (e) => {\n-              e.currentTarget.style.backgroundColor = '#fff';\n-            } : undefined}\n-          >\n-            <tool.icon size={18} color={tool.functional ? '#333' : '#999'} />\n-          </button>\n-          {tool.separator && idx < tools.length - 1 && (\n-            <div style={{\n-              width: '30px',\n-              height: '1px',\n-              backgroundColor: '#e0e0e0',\n-              margin: '4px 0'\n-            }} />\n-          )}\n-        </React.Fragment>\n-      ))}\n+      <button\n+        onClick={onStartFresh}\n+        title=\"Start Fresh\"\n+        style={{\n+          width: '36px',\n+          height: '36px',\n+          border: 'none',\n+          borderRadius: '4px',\n+          backgroundColor: '#fff',\n+          cursor: 'pointer',\n+          display: 'flex',\n+          alignItems: 'center',\n+          justifyContent: 'center',\n+          transition: 'all 0.2s ease'\n+        }}\n+        onMouseEnter={(e) => {\n+          e.currentTarget.style.backgroundColor = '#f0f0f0';\n+        }}\n+        onMouseLeave={(e) => {\n+          e.currentTarget.style.backgroundColor = '#fff';\n+        }}\n+      >\n+        <FaSync size={18} color=\"#333\" />\n+      </button>\n+\n+      <button\n+        onClick={onInsertAgent}\n+        title=\"Insert Agent Chat\"\n+        style={{\n+          width: '36px',\n+          height: '36px',\n+          border: 'none',\n+          borderRadius: '4px',\n+          backgroundColor: '#fff',\n+          cursor: 'pointer',\n+          display: 'flex',\n+          alignItems: 'center',\n+          justifyContent: 'center',\n+          transition: 'all 0.2s ease',\n+          fontSize: '20px',\n+          fontWeight: 600,\n+          color: '#333',\n+          fontFamily: 'monospace'\n+        }}\n+        onMouseEnter={(e) => {\n+          e.currentTarget.style.backgroundColor = '#f0f0f0';\n+        }}\n+        onMouseLeave={(e) => {\n+          e.currentTarget.style.backgroundColor = '#fff';\n+        }}\n+      >\n+        @\n+      </button>\n     </div>\n   );\n }\n \n-// @@@ Icon map with React Icons (matching original)\n+// @@@ Icon map with React Icons\n const iconMap = {\n   brain: FaBrain,\n   heart: FaHeart,\n@@ -101,7 +112,7 @@ const iconMap = {\n   compass: FaCompass,\n };\n \n-// @@@ Color map with gradient colors for watercolor effect (right to left fade)\n+// @@@ Color map with gradient colors for watercolor effect\n const colorMap: Record<string, { gradient: string; text: string; glow: string }> = {\n   blue: {\n     gradient: 'linear-gradient(90deg, rgba(77,159,255,0) 0%, rgba(77,159,255,0.05) 30%, rgba(77,159,255,0.12) 60%, rgba(77,159,255,0.25) 100%)',\n@@ -130,7 +141,7 @@ const colorMap: Record<string, { gradient: string; text: string; glow: string }>\n   },\n };\n \n-// @@@ Group Comment Card Component - elegant gradient watercolor style\n+// @@@ Group Comment Card Component\n function CommentGroupCard({\n   comments,\n   currentIndex,\n@@ -146,7 +157,6 @@ function CommentGroupCard({\n \n   if (comments.length === 0) return null;\n \n-  // @@@ Bounds check - ensure currentIndex is valid\n   const safeIndex = Math.min(Math.max(0, currentIndex), comments.length - 1);\n   const currentComment = comments[safeIndex];\n \n@@ -164,7 +174,7 @@ function CommentGroupCard({\n         transform: `translateY(-50%) ${isHovered ? 'scale(1.02)' : 'scale(1)'}`,\n         minWidth: '200px',\n         maxWidth: '400px',\n-        height: '54px', // Fixed 3 rows: ~18px per row\n+        height: '54px',\n         padding: '8px 12px',\n         background: colors.gradient,\n         borderLeft: `2px solid ${colors.glow}`,\n@@ -174,12 +184,11 @@ function CommentGroupCard({\n         zIndex: 10,\n         cursor: comments.length > 1 ? 'pointer' : 'default',\n         transition: 'all 0.2s ease',\n-        fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif',\n+        fontFamily: \"'Excalifont', 'Xiaolai', 'Georgia', serif\",\n         boxShadow: isHovered ? '0 4px 12px rgba(0,0,0,0.15)' : 'none',\n         animation: 'slideInFromRight 0.3s ease-out',\n       }}\n       onClick={() => {\n-        // Click to cycle through comments (only if multiple)\n         if (comments.length > 1) {\n           onNavigate((safeIndex + 1) % comments.length);\n         }\n@@ -193,7 +202,6 @@ function CommentGroupCard({\n         height: '100%',\n         alignItems: 'center'\n       }}>\n-        {/* Icon with pagination counter below */}\n         <div style={{\n           display: 'flex',\n           flexDirection: 'column',\n@@ -216,7 +224,6 @@ function CommentGroupCard({\n           )}\n         </div>\n \n-        {/* Voice name inline with comment */}\n         <div style={{\n           flex: 1,\n           overflow: 'hidden',\n@@ -236,48 +243,113 @@ function CommentGroupCard({\n \n // @@@ Main App Component\n export default function App() {\n+  const [currentView, setCurrentView] = useState<'writing' | 'settings' | 'calendar' | 'analysis' | 'about'>('writing');\n+  const [voiceConfigs, setVoiceConfigs] = useState<Record<string, VoiceConfig>>({});\n+  const [defaultVoiceConfigs, setDefaultVoiceConfigs] = useState<Record<string, VoiceConfig>>({});\n+\n   const engineRef = useRef<EditorEngine | null>(null);\n   const [state, setState] = useState<EditorState | null>(null);\n-  const [localText, setLocalText] = useState(''); // Local text for textarea\n-  const [isComposing, setIsComposing] = useState(false);\n-  const [groupPages, setGroupPages] = useState<Map<number, number>>(new Map());\n+  // @@@ Track local text per cell ID for IME composition\n+  const [localTexts, setLocalTexts] = useState<Map<string, string>>(new Map());\n+  const [composingCells, setComposingCells] = useState<Set<string>>(new Set());\n+  const [groupPages, setGroupPages] = useState<Map<string, number>>(new Map());\n   const [cursorPosition, setCursorPosition] = useState<number>(0);\n+  const [cursorCellId, setCursorCellId] = useState<string | null>(null);\n+\n+  // @@@ Chat widget state\n+  const [dropdownVisible, setDropdownVisible] = useState(false);\n+  const [dropdownPosition, setDropdownPosition] = useState({ x: 0, y: 0 });\n+  const [dropdownTriggerCellId, setDropdownTriggerCellId] = useState<string | null>(null);\n+  const [chatProcessing, setChatProcessing] = useState<Set<string>>(new Set());\n+\n+  // @@@ Warning dialog state\n+  const [showWarning, setShowWarning] = useState(false);\n \n-  const textareaRef = useRef<HTMLTextAreaElement>(null);\n+  // @@@ Per-cell textarea refs for positioning and style calculations\n+  const textareaRefs = useRef<Map<string, HTMLTextAreaElement>>(new Map());\n   const containerRef = useRef<HTMLDivElement>(null);\n+  // @@@ Force re-render when refs are ready\n+  const [refsReady, setRefsReady] = useState(0);\n+  const refsReadyTriggered = useRef(false);\n+\n+  // @@@ Reset refs ready flag when returning to writing view and focus last text cell\n+  useEffect(() => {\n+    if (currentView === 'writing') {\n+      refsReadyTriggered.current = false;\n+\n+      // Auto-focus last text cell after a short delay to ensure DOM is ready\n+      setTimeout(() => {\n+        if (!state) return;\n+        const lastTextCell = [...state.cells].reverse().find(c => c.type === 'text');\n+        if (!lastTextCell) return;\n+\n+        const textarea = textareaRefs.current.get(lastTextCell.id);\n+        if (textarea) {\n+          textarea.focus();\n+          // Move cursor to end\n+          textarea.selectionStart = textarea.value.length;\n+          textarea.selectionEnd = textarea.value.length;\n+        }\n+      }, 100);\n+    }\n+  }, [currentView, state]);\n+\n+  // @@@ Fetch default voices from backend\n+  useEffect(() => {\n+    getDefaultVoices().then(backendVoices => {\n+      const converted: Record<string, VoiceConfig> = {};\n+      for (const [name, data] of Object.entries(backendVoices)) {\n+        const v = data as any;\n+        converted[name] = {\n+          name,\n+          systemPrompt: v.tagline,\n+          enabled: true,\n+          icon: v.icon,\n+          color: v.color\n+        };\n+      }\n+      setDefaultVoiceConfigs(converted);\n+      const configs = getVoices() || converted;\n+      setVoiceConfigs(configs);\n+\n+      // Update engine with voice configs\n+      if (engineRef.current) {\n+        engineRef.current.setVoiceConfigs(configs);\n+      }\n+    });\n+  }, []);\n+\n+  // @@@ Update engine when voice configs change\n+  useEffect(() => {\n+    if (engineRef.current && Object.keys(voiceConfigs).length > 0) {\n+      engineRef.current.setVoiceConfigs(voiceConfigs);\n+    }\n+  }, [voiceConfigs]);\n \n   // Initialize engine\n   useEffect(() => {\n     const sessionId = crypto.randomUUID ? crypto.randomUUID() : Date.now().toString();\n     const engine = new EditorEngine(sessionId);\n     engineRef.current = engine;\n \n-    // Subscribe to state changes\n     engine.subscribe((newState) => {\n       setState({ ...newState });\n-      // Save to localStorage\n       localStorage.setItem('ink_memory_state', JSON.stringify(newState));\n     });\n \n-    // Load saved state if exists\n     const saved = localStorage.getItem('ink_memory_state');\n     if (saved) {\n       try {\n         const parsed = JSON.parse(saved);\n         engine.loadState(parsed);\n-\n-        // Load initial text and state together\n-        const textCell = parsed.cells?.find((c: any) => c.type === 'text');\n-        const initialText = textCell?.content || '';\n-\n-        setLocalText(initialText);\n         setState(engine.getState());\n \n-        // Double-check: force re-render after a tick to ensure everything is initialized\n-        setTimeout(() => {\n-          setLocalText(initialText);\n-          setState({ ...engine.getState() });\n-        }, 10);\n+        // Initialize localTexts from loaded state\n+        const texts = new Map<string, string>();\n+        parsed.cells?.filter((c: any) => c.type === 'text').forEach((c: any) => {\n+          texts.set(c.id, c.content || '');\n+        });\n+        setLocalTexts(texts);\n       } catch (e) {\n         console.error('Failed to load saved state:', e);\n       }\n@@ -286,190 +358,197 @@ export default function App() {\n     }\n   }, []);\n \n-  // Sync local text with state (when not composing)\n+  // @@@ Sync localTexts from state when not composing\n   useEffect(() => {\n-    if (!isComposing && state) {\n-      const textCell = state.cells.find(c => c.type === 'text') as TextCell;\n-      if (textCell) {\n-        setLocalText(textCell.content || '');\n-      }\n+    if (state) {\n+      setLocalTexts(prev => {\n+        const next = new Map(prev);\n+        state.cells.filter(c => c.type === 'text').forEach(cell => {\n+          const textCell = cell as TextCell;\n+          // Only update if not composing in this cell\n+          if (!composingCells.has(cell.id)) {\n+            next.set(cell.id, textCell.content || '');\n+          }\n+        });\n+        return next;\n+      });\n     }\n-  }, [state, isComposing]);\n+  }, [state, composingCells]);\n \n-  // @@@ Group comments by 2-row blocks using visual lines (accounting for wrapping)\n+  // @@@ Group comments by 2-row blocks, accounting for widgets between cells\n   const commentGroups = useMemo(() => {\n-    const groups = new Map<number, {\n+    const groups = new Map<string, {\n       comments: Commentor[];\n+      cellId: string;\n       blockIndex: number;\n       visualLineStart: number;\n       visualLineEnd: number;\n       maxLineWidth: number;\n       centerY: number;\n     }>();\n \n-    if (!textareaRef.current || !state) return groups;\n+    if (!state) return groups;\n+\n+    // Get any available textarea ref for style calculations\n+    const anyTextarea = Array.from(textareaRefs.current.values())[0];\n+    if (!anyTextarea) return groups;\n \n-    const text = localText;\n     const maxTextareaWidth = 600;\n \n-    // Get actual line height from computed styles\n-    const computedStyle = window.getComputedStyle(textareaRef.current);\n+    const computedStyle = window.getComputedStyle(anyTextarea);\n     const fontSize = parseFloat(computedStyle.fontSize) || 18;\n     const lineHeightRatio = parseFloat(computedStyle.lineHeight) / fontSize || 1.8;\n     const lineHeight = fontSize * lineHeightRatio;\n \n-    // Create a temporary canvas to measure text width\n     const canvas = document.createElement('canvas');\n     const ctx = canvas.getContext('2d');\n     if (ctx) {\n-      // Use actual font from computed styles\n       const fontFamily = computedStyle.fontFamily || 'system-ui, -apple-system, sans-serif';\n       ctx.font = `${fontSize}px ${fontFamily}`;\n     }\n \n-    // @@@ Build a map from character index to visual line number\n-    const charToVisualLine: number[] = new Array(text.length);\n-    let currentVisualLine = 0;\n-    let currentLineStartIndex = 0;\n-\n-    for (let i = 0; i < text.length; i++) {\n-      charToVisualLine[i] = currentVisualLine;\n-\n-      if (text[i] === '\\n') {\n-        // Hard line break - move to next visual line\n-        currentVisualLine++;\n-        currentLineStartIndex = i + 1;\n-      } else {\n-        // Check if we need to wrap\n-        const currentLineText = text.substring(currentLineStartIndex, i + 1);\n-        const width = ctx ? ctx.measureText(currentLineText).width : currentLineText.length * (fontSize * 0.6);\n-\n-        if (width > maxTextareaWidth && i > currentLineStartIndex) {\n-          // This character causes a wrap - move to next visual line\n+    // @@@ Process each text cell separately\n+    state.cells.forEach(cell => {\n+      if (cell.type !== 'text') return;\n+\n+      const textCell = cell as TextCell;\n+      const text = textCell.content;\n+\n+      // Calculate visual lines for this cell\n+      const charToVisualLine: number[] = new Array(text.length);\n+      let currentVisualLine = 0;\n+      let currentLineStartIndex = 0;\n+\n+      for (let i = 0; i < text.length; i++) {\n+        charToVisualLine[i] = currentVisualLine;\n+\n+        if (text[i] === '\\n') {\n           currentVisualLine++;\n-          currentLineStartIndex = i;\n-          charToVisualLine[i] = currentVisualLine;\n+          currentLineStartIndex = i + 1;\n+        } else {\n+          const currentLineText = text.substring(currentLineStartIndex, i + 1);\n+          const width = ctx ? ctx.measureText(currentLineText).width : currentLineText.length * (fontSize * 0.6);\n+\n+          if (width > maxTextareaWidth && i > currentLineStartIndex) {\n+            currentVisualLine++;\n+            currentLineStartIndex = i;\n+            charToVisualLine[i] = currentVisualLine;\n+          }\n         }\n       }\n-    }\n \n-    // Process each commentor\n-    state.commentors\n-      .filter(c => c.appliedAt)\n-      .forEach(commentor => {\n-        const index = text.toLowerCase().indexOf(commentor.phrase.toLowerCase());\n-        if (index === -1) return;\n-\n-        // Get visual line number for this character position\n-        const visualLineNumber = charToVisualLine[index] || 0;\n-\n-        // Determine which 2-row block this belongs to (0-1, 2-3, 4-5, etc.)\n-        const blockIndex = Math.floor(visualLineNumber / 2);\n-        const visualLineStart = blockIndex * 2;\n-        const visualLineEnd = visualLineStart + 1;\n-\n-        if (!groups.has(blockIndex)) {\n-          // For visual lines, we can assume they're all ~700px wide (or less)\n-          // So maxWidth is just the width of the longer of the two visual lines in this block\n-          let maxWidth = 0;\n-\n-          // Find all text on these two visual lines\n-          for (let i = 0; i < text.length; i++) {\n-            const vLine = charToVisualLine[i];\n-            if (vLine === visualLineStart || vLine === visualLineEnd) {\n-              // Find the end of this visual line\n-              let lineEnd = i;\n-              while (lineEnd < text.length && charToVisualLine[lineEnd] === vLine) {\n-                lineEnd++;\n+      // Find comments in this cell\n+      state.commentors\n+        .filter(c => c.appliedAt)\n+        .forEach(commentor => {\n+          const index = text.toLowerCase().indexOf(commentor.phrase.toLowerCase());\n+          if (index === -1) return;\n+\n+          const visualLineNumber = charToVisualLine[index] || 0;\n+          const blockIndex = Math.floor(visualLineNumber / 2);\n+          const visualLineStart = blockIndex * 2;\n+          const visualLineEnd = visualLineStart + 1;\n+\n+          // Create unique group key per cell\n+          const groupKey = `${cell.id}-${blockIndex}`;\n+\n+          if (!groups.has(groupKey)) {\n+            let maxWidth = 0;\n+\n+            for (let i = 0; i < text.length; i++) {\n+              const vLine = charToVisualLine[i];\n+              if (vLine === visualLineStart || vLine === visualLineEnd) {\n+                let lineEnd = i;\n+                while (lineEnd < text.length && charToVisualLine[lineEnd] === vLine) {\n+                  lineEnd++;\n+                }\n+                const lineText = text.substring(i, lineEnd);\n+                const width = ctx ? ctx.measureText(lineText).width : lineText.length * (fontSize * 0.6);\n+                maxWidth = Math.max(maxWidth, Math.min(width, maxTextareaWidth));\n+                i = lineEnd - 1;\n               }\n-              const lineText = text.substring(i, lineEnd);\n-              const width = ctx ? ctx.measureText(lineText).width : lineText.length * (fontSize * 0.6);\n-              maxWidth = Math.max(maxWidth, Math.min(width, maxTextareaWidth));\n-              i = lineEnd - 1; // Skip to end of this visual line\n             }\n-          }\n-\n-          // Calculate vertical center of the 2-row block\n-          const centerY = (visualLineStart + 1) * lineHeight;\n \n-          groups.set(blockIndex, {\n-            comments: [],\n-            blockIndex,\n-            visualLineStart,\n-            visualLineEnd,\n-            maxLineWidth: maxWidth,\n-            centerY\n-          });\n-        }\n+            const centerY = (visualLineStart + 1) * lineHeight;\n+\n+            groups.set(groupKey, {\n+              comments: [],\n+              cellId: cell.id,\n+              blockIndex,\n+              visualLineStart,\n+              visualLineEnd,\n+              maxLineWidth: maxWidth,\n+              centerY\n+            });\n+          }\n \n-        groups.get(blockIndex)!.comments.push(commentor);\n-      });\n+          groups.get(groupKey)!.comments.push(commentor);\n+        });\n+    });\n \n     return groups;\n-  }, [state?.commentors, localText, state]);\n+  }, [state?.commentors, state, refsReady]);\n \n-  // @@@ Auto-switch to newest comment when group size changes\n   useEffect(() => {\n     if (!commentGroups) return;\n \n     setGroupPages(prev => {\n       const next = new Map(prev);\n \n-      // For each group, ensure the page index is valid\n-      commentGroups.forEach((group, blockIndex) => {\n+      commentGroups.forEach((group, groupKey) => {\n         if (group.comments.length === 0) {\n-          next.delete(blockIndex);\n+          next.delete(groupKey);\n           return;\n         }\n \n-        const currentPage = prev.get(blockIndex) || 0;\n+        const currentPage = prev.get(groupKey) || 0;\n         const maxPage = group.comments.length - 1;\n \n-        // If we're on an old page and there are new comments, switch to the newest\n         if (group.comments.length > 1 && currentPage < maxPage) {\n-          next.set(blockIndex, maxPage); // Show the newest comment\n+          next.set(groupKey, maxPage);\n         } else if (currentPage > maxPage) {\n-          // Current page is out of bounds, reset to last valid page\n-          next.set(blockIndex, maxPage);\n+          next.set(groupKey, maxPage);\n         }\n       });\n \n-      // Remove pages for groups that no longer exist\n-      prev.forEach((_, blockIndex) => {\n-        if (!commentGroups.has(blockIndex)) {\n-          next.delete(blockIndex);\n+      prev.forEach((_, groupKey) => {\n+        if (!commentGroups.has(groupKey)) {\n+          next.delete(groupKey);\n         }\n       });\n \n       return next;\n     });\n   }, [commentGroups]);\n \n-  // @@@ Handle page navigation for comment groups\n-  const handleGroupNavigate = useCallback((blockIndex: number, newIndex: number) => {\n+  const handleGroupNavigate = useCallback((groupKey: string, newIndex: number) => {\n     setGroupPages(prev => {\n       const next = new Map(prev);\n-      next.set(blockIndex, newIndex);\n+      next.set(groupKey, newIndex);\n       return next;\n     });\n   }, []);\n \n-  // @@@ Detect which comment the cursor is inside and switch to it\n+  // @@@ Cursor-based comment navigation (per-cell)\n   useEffect(() => {\n-    if (!state || !localText) return;\n+    if (!state || !cursorCellId) return;\n \n+    // Get text for the cell where cursor is\n+    const cell = state.cells.find(c => c.id === cursorCellId);\n+    if (!cell || cell.type !== 'text') return;\n+\n+    const cellText = (cell as TextCell).content;\n     const appliedComments = state.commentors.filter(c => c.appliedAt);\n     if (appliedComments.length === 0) return;\n \n-    // Find which comment contains the cursor\n+    // Find comment at cursor position within this cell's text\n     let foundComment: Commentor | null = null;\n     for (const comment of appliedComments) {\n-      const index = localText.toLowerCase().indexOf(comment.phrase.toLowerCase());\n+      const index = cellText.toLowerCase().indexOf(comment.phrase.toLowerCase());\n       if (index !== -1) {\n         const start = index;\n         const end = index + comment.phrase.length;\n \n-        // Check if cursor is inside this phrase\n         if (cursorPosition >= start && cursorPosition <= end) {\n           foundComment = comment;\n           break;\n@@ -479,86 +558,274 @@ export default function App() {\n \n     if (!foundComment) return;\n \n-    // Find which group this comment belongs to\n-    commentGroups.forEach((group, blockIndex) => {\n+    // Find the group key for this cell and navigate to the comment\n+    commentGroups.forEach((group, groupKey) => {\n+      // Only update groups in the current cell\n+      if (group.cellId !== cursorCellId) return;\n+\n       const commentIndex = group.comments.findIndex(c => c.id === foundComment!.id);\n       if (commentIndex !== -1) {\n-        // Switch to this comment in the group\n         setGroupPages(prev => {\n           const next = new Map(prev);\n-          if (next.get(blockIndex) !== commentIndex) {\n-            next.set(blockIndex, commentIndex);\n+          if (next.get(groupKey) !== commentIndex) {\n+            next.set(groupKey, commentIndex);\n           }\n           return next;\n         });\n       }\n     });\n-  }, [cursorPosition, state, localText, commentGroups]);\n-\n-  // @@@ Handle text changes (with IME support)\n-  const handleTextChange = useCallback((newText: string) => {\n-    // Always update local text for the textarea\n-    setLocalText(newText);\n-    // Only update the engine when not composing\n-    if (!isComposing && engineRef.current) {\n-      engineRef.current.updateText(newText);\n+  }, [cursorPosition, cursorCellId, state, commentGroups]);\n+\n+  // @@@ Per-cell text change handler\n+  const handleTextChange = useCallback((cellId: string, newText: string) => {\n+    setLocalTexts(prev => {\n+      const next = new Map(prev);\n+      next.set(cellId, newText);\n+      return next;\n+    });\n+\n+    // Close dropdown if @ was deleted in the trigger cell\n+    if (dropdownVisible && dropdownTriggerCellId === cellId) {\n+      if (!newText.includes('@')) {\n+        setDropdownVisible(false);\n+        setDropdownTriggerCellId(null);\n+      }\n     }\n-  }, [isComposing]);\n \n-  const handleCompositionStart = useCallback(() => {\n-    setIsComposing(true);\n+    if (!composingCells.has(cellId) && engineRef.current) {\n+      engineRef.current.updateTextCell(cellId, newText);\n+    }\n+  }, [composingCells, dropdownVisible, dropdownTriggerCellId]);\n+\n+  // @@@ Per-cell composition handlers\n+  const handleCompositionStart = useCallback((cellId: string) => {\n+    setComposingCells(prev => new Set(prev).add(cellId));\n   }, []);\n \n-  const handleCompositionEnd = useCallback((e: React.CompositionEvent<HTMLTextAreaElement>) => {\n-    setIsComposing(false);\n+  const handleCompositionEnd = useCallback((cellId: string, e: React.CompositionEvent<HTMLTextAreaElement>) => {\n+    setComposingCells(prev => {\n+      const next = new Set(prev);\n+      next.delete(cellId);\n+      return next;\n+    });\n+\n     const newText = e.currentTarget.value;\n-    setLocalText(newText);\n+    setLocalTexts(prev => {\n+      const next = new Map(prev);\n+      next.set(cellId, newText);\n+      return next;\n+    });\n+\n     if (engineRef.current) {\n-      engineRef.current.updateText(newText);\n+      engineRef.current.updateTextCell(cellId, newText);\n     }\n   }, []);\n \n-  // @@@ Handle paste events to ensure highlighting is triggered\n-  const handlePaste = useCallback((e: React.ClipboardEvent<HTMLTextAreaElement>) => {\n-    // Let the default paste happen, then update the engine\n+  const handlePaste = useCallback((cellId: string, e: React.ClipboardEvent<HTMLTextAreaElement>) => {\n     setTimeout(() => {\n       const newText = e.currentTarget.value;\n-      setLocalText(newText);\n+      setLocalTexts(prev => {\n+        const next = new Map(prev);\n+        next.set(cellId, newText);\n+        return next;\n+      });\n       if (engineRef.current) {\n-        engineRef.current.updateText(newText);\n+        engineRef.current.updateTextCell(cellId, newText);\n       }\n     }, 0);\n   }, []);\n \n-  // @@@ Handle cursor position changes\n-  const handleCursorChange = useCallback(() => {\n-    if (textareaRef.current) {\n-      setCursorPosition(textareaRef.current.selectionStart);\n-    }\n+  const handleCursorChange = useCallback((cellId: string, e: React.SyntheticEvent<HTMLTextAreaElement>) => {\n+    setCursorPosition(e.currentTarget.selectionStart);\n+    setCursorCellId(cellId);\n   }, []);\n \n-  // @@@ Handle Start Fresh\n   const handleStartFresh = useCallback(() => {\n-    if (confirm('Clear everything and start fresh? This will delete all your current writing and comments.')) {\n-      localStorage.removeItem('ink_memory_state');\n-      window.location.reload();\n+    setShowWarning(true);\n+  }, []);\n+\n+  const confirmStartFresh = useCallback(() => {\n+    localStorage.removeItem('ink_memory_state');\n+    window.location.reload();\n+  }, []);\n+\n+  // @@@ Insert @ character at the end of last text cell\n+  const handleInsertAgent = useCallback(() => {\n+    if (!state || !engineRef.current) return;\n+\n+    // Find last text cell\n+    const lastTextCell = [...state.cells].reverse().find(c => c.type === 'text');\n+    if (!lastTextCell) return;\n+\n+    const textarea = textareaRefs.current.get(lastTextCell.id);\n+    if (!textarea) return;\n+\n+    // Insert @ character at the end\n+    const currentContent = (lastTextCell as TextCell).content;\n+    const newContent = currentContent + '@';\n+\n+    // Update the text\n+    engineRef.current.updateTextCell(lastTextCell.id, newContent);\n+\n+    // Focus the textarea and position cursor after @\n+    setTimeout(() => {\n+      textarea.focus();\n+      textarea.selectionStart = newContent.length;\n+      textarea.selectionEnd = newContent.length;\n+\n+      // Show dropdown\n+      const rect = textarea.getBoundingClientRect();\n+      const computedStyle = window.getComputedStyle(textarea);\n+      const lineHeight = parseFloat(computedStyle.lineHeight) || 32;\n+      const linesBefore = newContent.substring(0, newContent.length).split('\\n').length - 1;\n+\n+      setDropdownPosition({\n+        x: rect.left + 10,\n+        y: rect.top + (linesBefore * lineHeight) + lineHeight + 5\n+      });\n+      setDropdownTriggerCellId(lastTextCell.id);\n+      setDropdownVisible(true);\n+    }, 0);\n+  }, [state]);\n+\n+  // @@@ Handle @ key press for agent dropdown\n+  const handleKeyDown = useCallback((cellId: string, e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n+    if (e.key === '@' && !composingCells.has(cellId)) {\n+      // @@@ Capture textarea ref before setTimeout (React synthetic events are nullified)\n+      const textarea = e.currentTarget;\n+      setTimeout(() => {\n+        if (textarea) {\n+          // Get cursor position in textarea\n+          const cursorPos = textarea.selectionStart;\n+          const textBeforeCursor = textarea.value.substring(0, cursorPos);\n+\n+          // Count lines before cursor\n+          const linesBefore = textBeforeCursor.split('\\n').length - 1;\n+\n+          // Calculate approximate cursor position\n+          const computedStyle = window.getComputedStyle(textarea);\n+          const lineHeight = parseFloat(computedStyle.lineHeight) || 32;\n+          const rect = textarea.getBoundingClientRect();\n+\n+          // Position dropdown at cursor (with small offset)\n+          setDropdownPosition({\n+            x: rect.left + 10,\n+            y: rect.top + (linesBefore * lineHeight) + lineHeight + 5\n+          });\n+          setDropdownTriggerCellId(cellId);\n+          setDropdownVisible(true);\n+        }\n+      }, 0);\n+    } else if (e.key === 'Escape' && dropdownVisible) {\n+      setDropdownVisible(false);\n+      setDropdownTriggerCellId(null);\n+    }\n+  }, [composingCells, dropdownVisible]);\n+\n+  // @@@ Handle agent selection from dropdown\n+  const handleAgentSelect = useCallback((voiceName: string, voiceConfig: VoiceConfig) => {\n+    setDropdownVisible(false);\n+\n+    if (!engineRef.current || !dropdownTriggerCellId) return;\n+\n+    const textarea = textareaRefs.current.get(dropdownTriggerCellId);\n+    if (!textarea) {\n+      setDropdownTriggerCellId(null);\n+      return;\n+    }\n+\n+    const cursorPos = textarea.selectionStart;\n+\n+    // Create chat widget\n+    const chatWidget = new ChatWidget(voiceName, voiceConfig);\n+\n+    // Insert widget at cursor (engine will handle @ removal)\n+    engineRef.current.insertWidgetAtCursor(dropdownTriggerCellId, cursorPos, 'chat', chatWidget.getData());\n+    setDropdownTriggerCellId(null);\n+  }, [dropdownTriggerCellId]);\n+\n+  // @@@ Handle sending chat message\n+  const handleChatSend = useCallback(async (widgetId: string, message: string) => {\n+    if (!engineRef.current || !state) return;\n+\n+    // Find widget\n+    const widgetCell = state.cells.find(c => c.type === 'widget' && c.id === widgetId);\n+    if (!widgetCell || widgetCell.type !== 'widget') return;\n+\n+    const widgetData = widgetCell.data as ChatWidgetData;\n+    const chatWidget = ChatWidget.fromData(widgetData);\n+\n+    // Add user message optimistically\n+    chatWidget.addUserMessage(message);\n+    engineRef.current.updateWidgetData(widgetId, chatWidget.getData());\n+\n+    // Mark as processing\n+    setChatProcessing(prev => new Set(prev).add(widgetId));\n+\n+    try {\n+      // Get ALL text from all text cells as unified context\n+      const allText = state.cells\n+        .filter(c => c.type === 'text')\n+        .map(c => (c as TextCell).content)\n+        .join('');\n+\n+      // Call backend - use voiceConfig.name as the voice name for the prompt\n+      const response = await chatWithVoice(\n+        widgetData.voiceConfig.name,  // Use the display name, not the key\n+        widgetData.voiceConfig,\n+        chatWidget.getConversationHistory().slice(0, -1), // Exclude last message (just added)\n+        message,\n+        allText\n+      );\n+\n+      // Add assistant response\n+      chatWidget.addAssistantMessage(response);\n+      engineRef.current.updateWidgetData(widgetId, chatWidget.getData());\n+    } catch (error) {\n+      console.error('Chat failed:', error);\n+      chatWidget.addAssistantMessage('Sorry, I encountered an error.');\n+      engineRef.current.updateWidgetData(widgetId, chatWidget.getData());\n+    } finally {\n+      setChatProcessing(prev => {\n+        const next = new Set(prev);\n+        next.delete(widgetId);\n+        return next;\n+      });\n     }\n+  }, [state]);\n+\n+  // @@@ Handle deleting chat widget\n+  const handleChatDelete = useCallback((widgetId: string) => {\n+    if (!engineRef.current) return;\n+    engineRef.current.deleteCell(widgetId);\n   }, []);\n \n-  // @@@ Render text with highlights\n-  const renderHighlightedText = () => {\n+  // @@@ Helper to get watercolor background\n+  const getWatercolorBg = (color: string) => {\n+    const brushes: Record<string, string> = {\n+      yellow: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-9&color=ffff43)',\n+      blue: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-7&color=a3d5ff)',\n+      pink: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-8&color=ffb3d9)',\n+      green: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-6&color=b3ffb3)',\n+      purple: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-5&color=ddb3ff)'\n+    };\n+    return brushes[color] || 'none';\n+  };\n+\n+  // @@@ Render highlighted text for a specific text content\n+  const renderHighlightedText = (text: string) => {\n     if (!state) return null;\n \n     const appliedComments = state.commentors.filter(c => c.appliedAt);\n \n     if (appliedComments.length === 0) {\n-      return <div style={{ whiteSpace: 'pre-wrap' }}>{localText}</div>;\n+      return <div style={{ whiteSpace: 'pre-wrap' }}>{text}</div>;\n     }\n \n-    // Create highlight ranges\n+    // Find highlights in this specific text\n     const highlights: Array<{ start: number; end: number; comment: Commentor }> = [];\n     appliedComments.forEach(comment => {\n-      const index = localText.toLowerCase().indexOf(comment.phrase.toLowerCase());\n+      const index = text.toLowerCase().indexOf(comment.phrase.toLowerCase());\n       if (index !== -1) {\n         highlights.push({\n           start: index,\n@@ -568,36 +835,20 @@ export default function App() {\n       }\n     });\n \n-    // Sort by start position\n     highlights.sort((a, b) => a.start - b.start);\n \n-    // Build highlighted text\n     const elements: React.ReactNode[] = [];\n     let lastEnd = 0;\n \n-    // Get watercolor brush URL for color\n-    const getWatercolorBg = (color: string) => {\n-      const brushes: Record<string, string> = {\n-        yellow: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-9&color=ffff43)',\n-        blue: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-7&color=a3d5ff)',\n-        pink: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-8&color=ffb3d9)',\n-        green: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-6&color=b3ffb3)',\n-        purple: 'url(https://s2.svgbox.net/pen-brushes.svg?ic=brush-5&color=ddb3ff)'\n-      };\n-      return brushes[color] || 'none';\n-    };\n-\n     highlights.forEach((highlight, idx) => {\n-      // Add text before highlight\n       if (highlight.start > lastEnd) {\n         elements.push(\n           <span key={`text-${idx}`}>\n-            {localText.substring(lastEnd, highlight.start)}\n+            {text.substring(lastEnd, highlight.start)}\n           </span>\n         );\n       }\n \n-      // Add highlighted text with watercolor effect\n       elements.push(\n         <span\n           key={`highlight-${idx}`}\n@@ -610,18 +861,17 @@ export default function App() {\n             transition: 'all 0.2s ease'\n           }}\n         >\n-          {localText.substring(highlight.start, highlight.end)}\n+          {text.substring(highlight.start, highlight.end)}\n         </span>\n       );\n \n       lastEnd = highlight.end;\n     });\n \n-    // Add remaining text\n-    if (lastEnd < localText.length) {\n+    if (lastEnd < text.length) {\n       elements.push(\n         <span key=\"text-final\">\n-          {localText.substring(lastEnd)}\n+          {text.substring(lastEnd)}\n         </span>\n       );\n     }\n@@ -640,128 +890,361 @@ export default function App() {\n   const appliedComments = state.commentors.filter(c => c.appliedAt);\n \n   return (\n-    <div style={{\n-      display: 'flex',\n-      height: '100vh',\n-      fontFamily: 'system-ui, -apple-system, sans-serif'\n-    }}>\n-      {/* Left Toolbar */}\n-      <LeftToolbar onStartFresh={handleStartFresh} />\n-\n-      {/* Main Editor Area with Inline Comments */}\n-      <div\n-        ref={containerRef}\n-        style={{\n-          flex: 1,\n-          position: 'relative',\n-          overflow: 'hidden'\n-        }}\n-      >\n+    <>\n+      <LeftSidebar currentView={currentView} onViewChange={setCurrentView} />\n+      {currentView === 'writing' && (\n         <div style={{\n-          height: '100%',\n           display: 'flex',\n-          flexDirection: 'column',\n-          width: '100%',\n-          margin: '0 auto'\n+          height: '100vh',\n+          paddingTop: '48px',\n+          fontFamily: 'system-ui, -apple-system, sans-serif'\n         }}>\n-          {/* Status Bar */}\n+          {/* Left spacer for layout */}\n           <div style={{\n-            padding: '10px 20px',\n-            borderBottom: '1px solid #e0e0e0',\n-            fontSize: '12px',\n-            color: '#666',\n-            display: 'flex',\n-            gap: '20px',\n-            backgroundColor: '#fafafa'\n+            width: '48px',\n+            backgroundColor: 'transparent',\n+            position: 'relative',\n+            flexShrink: 0,\n+            marginLeft: '12px'\n           }}>\n-            <span>Energy: {unusedEnergy}/{currentEnergy}</span>\n-            <span>Weight: {lastEntry?.weight || 0}</span>\n-            <span>Applied: {appliedComments.length}</span>\n-            <span>Groups: {commentGroups.size}</span>\n+            <LeftToolbar onStartFresh={handleStartFresh} onInsertAgent={handleInsertAgent} />\n           </div>\n \n-          {/* Writing Area with Comments */}\n-          <div style={{\n-            flex: 1,\n-            position: 'relative',\n-            overflow: 'auto',\n-            padding: '40px'\n-          }}>\n-            {/* Highlighted text overlay */}\n+          <div\n+            ref={containerRef}\n+            style={{\n+              flex: 1,\n+              position: 'relative',\n+              overflow: 'hidden'\n+            }}\n+          >\n             <div style={{\n-              position: 'absolute',\n-              top: '40px',\n-              left: '40px',\n-              right: '40px',\n-              maxWidth: '600px',\n-              pointerEvents: 'none',\n-              fontSize: '18px',\n-              lineHeight: '1.8',\n-              color: 'transparent',\n-              fontFamily: 'inherit'\n+              height: '100%',\n+              display: 'flex',\n+              flexDirection: 'column',\n+              width: '100%',\n+              margin: '0 auto'\n             }}>\n-              {renderHighlightedText()}\n+              <div style={{\n+                flex: 1,\n+                position: 'relative',\n+                overflow: 'auto',\n+                padding: '20px'\n+              }}>\n+                <div style={{\n+                  position: 'relative',\n+                  maxWidth: '600px'\n+                }}>\n+                  {/* Render cells sequentially with per-cell highlights */}\n+                  {state.cells.map((cell, idx) => {\n+                    if (cell.type === 'text') {\n+                      const textCell = cell as TextCell;\n+                      // Use local text if available, otherwise use engine state\n+                      const content = localTexts.get(cell.id) ?? textCell.content;\n+                      const lineCount = Math.max(content.split('\\n').length, 1);\n+\n+                      return (\n+                        <div key={cell.id} style={{ position: 'relative' }}>\n+                          {/* Highlight layer for this cell */}\n+                          <div style={{\n+                            position: 'absolute',\n+                            top: 0,\n+                            left: 0,\n+                            right: 0,\n+                            pointerEvents: 'none',\n+                            fontSize: '18px',\n+                            lineHeight: '1.8',\n+                            color: 'transparent',\n+                            fontFamily: \"'Excalifont', 'Xiaolai', 'Georgia', serif\",\n+                            zIndex: 0\n+                          }}>\n+                            {renderHighlightedText(content)}\n+                          </div>\n+\n+                          {/* Textarea for this cell */}\n+                          <textarea\n+                            ref={(el) => {\n+                              if (el) {\n+                                const wasEmpty = textareaRefs.current.size === 0;\n+                                textareaRefs.current.set(cell.id, el);\n+                                // Trigger re-render when first ref is set (once per mount)\n+                                if (wasEmpty && !refsReadyTriggered.current) {\n+                                  refsReadyTriggered.current = true;\n+                                  setRefsReady(prev => prev + 1);\n+                                }\n+                              } else {\n+                                textareaRefs.current.delete(cell.id);\n+                              }\n+                            }}\n+                            value={content}\n+                            onChange={(e) => handleTextChange(cell.id, e.target.value)}\n+                            onCompositionStart={() => handleCompositionStart(cell.id)}\n+                            onCompositionEnd={(e) => handleCompositionEnd(cell.id, e)}\n+                            onPaste={(e) => handlePaste(cell.id, e)}\n+                            onSelect={(e) => handleCursorChange(cell.id, e)}\n+                            onClick={(e) => handleCursorChange(cell.id, e)}\n+                            onKeyUp={(e) => handleCursorChange(cell.id, e)}\n+                            onKeyDown={(e) => handleKeyDown(cell.id, e)}\n+                            placeholder={idx === 0 ? \"Start writing...\" : \"Continue writing...\"}\n+                            rows={lineCount}\n+                            style={{\n+                              width: '100%',\n+                              border: 'none',\n+                              outline: 'none',\n+                              resize: 'none',\n+                              fontSize: '18px',\n+                              lineHeight: '1.8',\n+                              fontFamily: \"'Excalifont', 'Xiaolai', 'Georgia', serif\",\n+                              background: 'transparent',\n+                              color: '#333',\n+                              caretColor: '#333',\n+                              position: 'relative',\n+                              zIndex: 1,\n+                              marginBottom: '0px',\n+                              overflow: 'hidden',\n+                              minHeight: '32px'\n+                            }}\n+                          />\n+                        </div>\n+                      );\n+                    } else if (cell.type === 'widget' && cell.widgetType === 'chat') {\n+                      return (\n+                        <ChatWidgetUI\n+                          key={cell.id}\n+                          data={cell.data as ChatWidgetData}\n+                          onSendMessage={(msg) => handleChatSend(cell.id, msg)}\n+                          onDelete={() => handleChatDelete(cell.id)}\n+                          isProcessing={chatProcessing.has(cell.id)}\n+                        />\n+                      );\n+                    }\n+                    return null;\n+                  })}\n+                </div>\n+\n+                {/* Comments layer (absolute positioned) */}\n+                {Array.from(commentGroups.entries()).map(([groupKey, group]) => {\n+                  const currentIndex = groupPages.get(groupKey) || 0;\n+\n+                  // @@@ Get the specific textarea for this group's cell\n+                  const cellTextarea = textareaRefs.current.get(group.cellId);\n+                  if (!cellTextarea) return null;\n+\n+                  // Calculate position relative to this cell's textarea\n+                  const cellRect = cellTextarea.getBoundingClientRect();\n+                  const containerRect = containerRef.current?.getBoundingClientRect();\n+                  if (!containerRect) return null;\n+\n+                  const containerPadding = parseFloat(window.getComputedStyle(cellTextarea.parentElement || cellTextarea).paddingLeft) || 20;\n+                  const gap = Math.max(30, window.innerWidth * 0.02);\n+                  const leftPosition = containerPadding + group.maxLineWidth + gap;\n+\n+                  // @@@ Position relative to cell's top, not global document\n+                  // centerY is already relative to cell's top, so just add cell offset\n+                  const topPosition = cellRect.top - containerRect.top + group.centerY;\n+\n+                  return (\n+                    <CommentGroupCard\n+                      key={groupKey}\n+                      comments={group.comments}\n+                      currentIndex={currentIndex}\n+                      onNavigate={(idx) => handleGroupNavigate(groupKey, idx)}\n+                      position={{\n+                        top: topPosition,\n+                        left: leftPosition\n+                      }}\n+                    />\n+                  );\n+                })}\n+              </div>\n+\n+              {/* Debug stats bar at bottom */}\n+              <div style={{\n+                position: 'fixed',\n+                bottom: 0,\n+                left: 0,\n+                right: 0,\n+                padding: '10px 20px',\n+                borderTop: '1px solid #e0e0e0',\n+                fontSize: '12px',\n+                color: '#666',\n+                display: 'flex',\n+                gap: '20px',\n+                backgroundColor: '#fafafa',\n+                zIndex: 50\n+              }}>\n+                <span>Energy: {unusedEnergy}/{currentEnergy}</span>\n+                <span>Weight: {lastEntry?.weight || 0}</span>\n+                <span>Applied: {appliedComments.length}</span>\n+                <span>Groups: {commentGroups.size}</span>\n+              </div>\n             </div>\n+          </div>\n \n-            {/* Textarea */}\n-            <textarea\n-              ref={textareaRef}\n-              value={localText}\n-              onChange={(e) => handleTextChange(e.target.value)}\n-              onCompositionStart={handleCompositionStart}\n-              onCompositionEnd={handleCompositionEnd}\n-              onPaste={handlePaste}\n-              onSelect={handleCursorChange}\n-              onClick={handleCursorChange}\n-              onKeyUp={handleCursorChange}\n-              placeholder=\"Start writing...\"\n-              style={{\n-                width: '100%',\n-                maxWidth: '600px',\n-                minHeight: '100%',\n-                border: 'none',\n-                outline: 'none',\n-                resize: 'none',\n-                fontSize: '18px',\n-                lineHeight: '1.8',\n-                fontFamily: 'inherit',\n-                background: 'transparent',\n-                color: '#333',\n-                caretColor: '#333',\n-                position: 'relative',\n-                zIndex: 1\n-              }}\n+          {/* Agent dropdown */}\n+          {dropdownVisible && (\n+            <AgentDropdown\n+              voices={voiceConfigs}\n+              position={dropdownPosition}\n+              onSelect={handleAgentSelect}\n+              onClose={() => setDropdownVisible(false)}\n             />\n+          )}\n+        </div>\n+      )}\n+      {currentView === 'settings' && (\n+        <div style={{\n+          position: 'fixed',\n+          top: 48,\n+          left: 0,\n+          right: 0,\n+          bottom: 0,\n+          background: '#f8f0e6',\n+          display: 'flex',\n+          overflow: 'hidden'\n+        }}>\n+          <VoiceSettings\n+            defaultVoices={defaultVoiceConfigs}\n+            onSave={setVoiceConfigs}\n+          />\n+        </div>\n+      )}\n+      {currentView === 'calendar' && (\n+        <div style={{\n+          position: 'fixed',\n+          top: 48,\n+          left: 0,\n+          right: 0,\n+          bottom: 0,\n+          background: '#f8f0e6',\n+          display: 'flex',\n+          overflow: 'hidden'\n+        }}>\n+          <CalendarView />\n+        </div>\n+      )}\n+      {currentView === 'analysis' && (\n+        <div style={{\n+          position: 'fixed',\n+          top: 48,\n+          left: 0,\n+          right: 0,\n+          bottom: 0,\n+          background: '#f8f0e6',\n+          display: 'flex',\n+          overflow: 'hidden'\n+        }}>\n+          <AnalysisView />\n+        </div>\n+      )}\n+      {currentView === 'about' && (\n+        <div style={{\n+          position: 'fixed',\n+          top: 48,\n+          left: 0,\n+          right: 0,\n+          bottom: 0,\n+          background: '#f8f0e6',\n+          display: 'flex',\n+          overflow: 'hidden'\n+        }}>\n+          <AboutView />\n+        </div>\n+      )}\n \n-            {/* Comment Groups - positioned absolutely based on 2-row blocks */}\n-            {Array.from(commentGroups.entries()).map(([blockIndex, group]) => {\n-              const currentIndex = groupPages.get(blockIndex) || 0;\n-\n-              // Get actual padding values from the container\n-              const containerPadding = textareaRef.current?.parentElement ?\n-                parseFloat(window.getComputedStyle(textareaRef.current.parentElement).paddingLeft) || 40 : 40;\n-\n-              // Dynamic gap based on viewport size\n-              const gap = Math.max(30, window.innerWidth * 0.02); // Min 30px, scales with viewport\n-\n-              const leftPosition = containerPadding + group.maxLineWidth + gap;\n-\n-              return (\n-                <CommentGroupCard\n-                  key={blockIndex}\n-                  comments={group.comments}\n-                  currentIndex={currentIndex}\n-                  onNavigate={(idx) => handleGroupNavigate(blockIndex, idx)}\n-                  position={{\n-                    top: group.centerY + containerPadding,\n-                    left: leftPosition\n-                  }}\n-                />\n-              );\n-            })}\n+      {/* Warning Dialog */}\n+      {showWarning && (\n+        <div style={{\n+          position: 'fixed',\n+          top: 0,\n+          left: 0,\n+          right: 0,\n+          bottom: 0,\n+          backgroundColor: 'rgba(0, 0, 0, 0.5)',\n+          display: 'flex',\n+          alignItems: 'center',\n+          justifyContent: 'center',\n+          zIndex: 1000\n+        }}>\n+          <div style={{\n+            backgroundColor: '#fffef9',\n+            border: '2px solid #d0c4b0',\n+            borderRadius: '8px',\n+            padding: '32px',\n+            maxWidth: '400px',\n+            boxShadow: '0 8px 24px rgba(0, 0, 0, 0.2)',\n+            fontFamily: \"'Excalifont', 'Xiaolai', 'Georgia', serif\"\n+          }}>\n+            <h2 style={{\n+              margin: '0 0 16px 0',\n+              fontSize: '20px',\n+              color: '#333',\n+              fontWeight: 600\n+            }}>\n+              Start Fresh?\n+            </h2>\n+            <p style={{\n+              margin: '0 0 24px 0',\n+              fontSize: '16px',\n+              lineHeight: '1.6',\n+              color: '#555'\n+            }}>\n+              This will delete all your current writing and comments. This action cannot be undone.\n+            </p>\n+            <div style={{\n+              display: 'flex',\n+              gap: '12px',\n+              justifyContent: 'space-between'\n+            }}>\n+              <button\n+                onClick={confirmStartFresh}\n+                style={{\n+                  padding: '8px 20px',\n+                  border: '1px solid #d44',\n+                  background: '#d44',\n+                  borderRadius: '4px',\n+                  cursor: 'pointer',\n+                  fontSize: '15px',\n+                  fontFamily: \"'Excalifont', 'Xiaolai', 'Georgia', serif\",\n+                  color: '#fff',\n+                  fontWeight: 600,\n+                  transition: 'all 0.2s'\n+                }}\n+                onMouseEnter={(e) => {\n+                  e.currentTarget.style.backgroundColor = '#c33';\n+                }}\n+                onMouseLeave={(e) => {\n+                  e.currentTarget.style.backgroundColor = '#d44';\n+                }}\n+              >\n+                Delete All\n+              </button>\n+              <button\n+                onClick={() => setShowWarning(false)}\n+                style={{\n+                  padding: '8px 20px',\n+                  border: '1px solid #d0c4b0',\n+                  background: '#fff',\n+                  borderRadius: '4px',\n+                  cursor: 'pointer',\n+                  fontSize: '15px',\n+                  fontFamily: \"'Excalifont', 'Xiaolai', 'Georgia', serif\",\n+                  color: '#333',\n+                  transition: 'all 0.2s'\n+                }}\n+                onMouseEnter={(e) => {\n+                  e.currentTarget.style.backgroundColor = '#f5f5f5';\n+                }}\n+                onMouseLeave={(e) => {\n+                  e.currentTarget.style.backgroundColor = '#fff';\n+                }}\n+              >\n+                Cancel\n+              </button>\n+            </div>\n           </div>\n         </div>\n-      </div>\n-    </div>\n+      )}\n+    </>\n   );\n-}\n\\ No newline at end of file\n+}"
    },
    {
      "sha": "d0c08d138141b9b3bcd914057494eec57bf0e2a4",
      "filename": "frontend/src/components/AgentDropdown.tsx",
      "status": "added",
      "additions": 127,
      "deletions": 0,
      "changes": 127,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/a4eb52998c60b0de1bbf875423f681091b5eb39a/frontend%2Fsrc%2Fcomponents%2FAgentDropdown.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/a4eb52998c60b0de1bbf875423f681091b5eb39a/frontend%2Fsrc%2Fcomponents%2FAgentDropdown.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FAgentDropdown.tsx?ref=a4eb52998c60b0de1bbf875423f681091b5eb39a",
      "patch": "@@ -0,0 +1,127 @@\n+import React from 'react';\n+import type { VoiceConfig } from '../types/voice';\n+import {\n+  FaBrain, FaHeart, FaQuestion, FaCloud, FaTheaterMasks, FaEye,\n+  FaFistRaised, FaLightbulb, FaShieldAlt, FaWind, FaFire, FaCompass\n+} from 'react-icons/fa';\n+\n+// Icon map\n+const iconMap = {\n+  brain: FaBrain,\n+  heart: FaHeart,\n+  question: FaQuestion,\n+  cloud: FaCloud,\n+  masks: FaTheaterMasks,\n+  eye: FaEye,\n+  fist: FaFistRaised,\n+  lightbulb: FaLightbulb,\n+  shield: FaShieldAlt,\n+  wind: FaWind,\n+  fire: FaFire,\n+  compass: FaCompass,\n+};\n+\n+interface AgentDropdownProps {\n+  voices: Record<string, VoiceConfig>;\n+  position: { x: number; y: number };\n+  onSelect: (voiceName: string, voiceConfig: VoiceConfig) => void;\n+  onClose: () => void;\n+}\n+\n+export default function AgentDropdown({ voices, position, onSelect, onClose }: AgentDropdownProps) {\n+  const enabledVoices = Object.entries(voices).filter(([_, cfg]) => cfg.enabled);\n+  const [selectedIndex, setSelectedIndex] = React.useState(0);\n+\n+  // Keyboard navigation\n+  React.useEffect(() => {\n+    const handleKeyDown = (e: KeyboardEvent) => {\n+      if (e.key === 'Escape') {\n+        e.preventDefault();\n+        onClose();\n+      } else if (e.key === 'ArrowDown') {\n+        e.preventDefault();\n+        setSelectedIndex(prev => (prev + 1) % enabledVoices.length);\n+      } else if (e.key === 'ArrowUp') {\n+        e.preventDefault();\n+        setSelectedIndex(prev => (prev - 1 + enabledVoices.length) % enabledVoices.length);\n+      } else if (e.key === 'Enter') {\n+        e.preventDefault();\n+        const [name, cfg] = enabledVoices[selectedIndex];\n+        onSelect(name, cfg);\n+      }\n+    };\n+    document.addEventListener('keydown', handleKeyDown);\n+    return () => document.removeEventListener('keydown', handleKeyDown);\n+  }, [onClose, enabledVoices, selectedIndex, onSelect]);\n+\n+  if (enabledVoices.length === 0) {\n+    return (\n+      <div style={{\n+        position: 'fixed',\n+        left: `${position.x}px`,\n+        top: `${position.y}px`,\n+        background: '#fff',\n+        border: '1px solid #ccc',\n+        borderRadius: '8px',\n+        boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n+        padding: '8px',\n+        zIndex: 1000,\n+        minWidth: '200px',\n+        fontSize: '14px',\n+        color: '#666'\n+      }}>\n+        No agents available\n+      </div>\n+    );\n+  }\n+\n+  return (\n+    <div\n+      style={{\n+        position: 'fixed',\n+        left: `${position.x}px`,\n+        top: `${position.y}px`,\n+        background: '#fff',\n+        border: '1px solid #ccc',\n+        borderRadius: '8px',\n+        boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n+        padding: '4px 0',\n+        zIndex: 1000,\n+        minWidth: '220px',\n+        maxHeight: '300px',\n+        overflow: 'auto'\n+      }}\n+    >\n+      {enabledVoices.map(([name, cfg], idx) => {\n+        const Icon = iconMap[cfg.icon as keyof typeof iconMap] || FaBrain;\n+        const isSelected = idx === selectedIndex;\n+        return (\n+          <div\n+            key={name}\n+            onClick={() => onSelect(name, cfg)}\n+            onMouseEnter={() => setSelectedIndex(idx)}\n+            style={{\n+              padding: '8px 12px',\n+              cursor: 'pointer',\n+              display: 'flex',\n+              alignItems: 'center',\n+              gap: '10px',\n+              transition: 'background 0.15s',\n+              background: isSelected ? '#f0f0f0' : 'transparent'\n+            }}\n+          >\n+            <Icon size={16} color=\"#666\" />\n+            <div style={{ flex: 1 }}>\n+              <div style={{ fontWeight: 600, fontSize: '14px', color: '#333' }}>\n+                {cfg.name}\n+              </div>\n+              <div style={{ fontSize: '12px', color: '#666', marginTop: '2px' }}>\n+                {cfg.systemPrompt.substring(0, 40)}...\n+              </div>\n+            </div>\n+          </div>\n+        );\n+      })}\n+    </div>\n+  );\n+}"
    },
    {
      "sha": "03ba410ce6401999cdbef1407b719ebcc243b7d4",
      "filename": "frontend/src/components/ChatWidgetUI.tsx",
      "status": "added",
      "additions": 262,
      "deletions": 0,
      "changes": 262,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/a4eb52998c60b0de1bbf875423f681091b5eb39a/frontend%2Fsrc%2Fcomponents%2FChatWidgetUI.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/a4eb52998c60b0de1bbf875423f681091b5eb39a/frontend%2Fsrc%2Fcomponents%2FChatWidgetUI.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FChatWidgetUI.tsx?ref=a4eb52998c60b0de1bbf875423f681091b5eb39a",
      "patch": "@@ -0,0 +1,262 @@\n+import React, { useState, useRef, useEffect } from 'react';\n+import type { ChatWidgetData, ChatMessage } from '../engine/ChatWidget';\n+import {\n+  FaBrain, FaHeart, FaQuestion, FaCloud, FaTheaterMasks, FaEye,\n+  FaFistRaised, FaLightbulb, FaShieldAlt, FaWind, FaFire, FaCompass\n+} from 'react-icons/fa';\n+\n+const iconMap = {\n+  brain: FaBrain,\n+  heart: FaHeart,\n+  question: FaQuestion,\n+  cloud: FaCloud,\n+  masks: FaTheaterMasks,\n+  eye: FaEye,\n+  fist: FaFistRaised,\n+  lightbulb: FaLightbulb,\n+  shield: FaShieldAlt,\n+  wind: FaWind,\n+  fire: FaFire,\n+  compass: FaCompass,\n+};\n+\n+interface ChatWidgetUIProps {\n+  data: ChatWidgetData;\n+  onSendMessage: (message: string) => void;\n+  onDelete: () => void;\n+  isProcessing: boolean;\n+}\n+\n+export default function ChatWidgetUI({ data, onSendMessage, onDelete, isProcessing }: ChatWidgetUIProps) {\n+  const [inputValue, setInputValue] = useState('');\n+  const messagesContainerRef = useRef<HTMLDivElement>(null);\n+  const [isHovered, setIsHovered] = useState(false);\n+\n+  // @@@ Auto-scroll to bottom when new messages arrive\n+  useEffect(() => {\n+    setTimeout(() => {\n+      if (messagesContainerRef.current) {\n+        messagesContainerRef.current.scrollTop = messagesContainerRef.current.scrollHeight;\n+      }\n+    }, 100);\n+  }, [data.messages.length]);\n+\n+  const handleSend = () => {\n+    if (inputValue.trim() && !isProcessing) {\n+      onSendMessage(inputValue.trim());\n+      setInputValue('');\n+    }\n+  };\n+\n+  const handleKeyDown = (e: React.KeyboardEvent) => {\n+    if (e.key === 'Enter' && !e.shiftKey) {\n+      e.preventDefault();\n+      handleSend();\n+    }\n+  };\n+\n+  const Icon = iconMap[data.voiceConfig.icon as keyof typeof iconMap] || FaBrain;\n+\n+  return (\n+    <div\n+      style={{\n+        margin: '20px 0',\n+        padding: '16px 20px',\n+        background: 'rgba(250, 248, 245, 0.6)',\n+        borderRadius: '12px',\n+        maxWidth: '600px',\n+        position: 'relative',\n+        transition: 'all 0.2s ease'\n+      }}\n+      onMouseEnter={() => setIsHovered(true)}\n+      onMouseLeave={() => setIsHovered(false)}\n+    >\n+      {/* Delete button - only visible on hover */}\n+      <button\n+        onClick={onDelete}\n+        style={{\n+          position: 'absolute',\n+          top: '8px',\n+          right: '8px',\n+          padding: '4px 8px',\n+          backgroundColor: 'transparent',\n+          color: '#999',\n+          border: 'none',\n+          borderRadius: '4px',\n+          fontSize: '16px',\n+          cursor: 'pointer',\n+          transition: 'all 0.2s',\n+          opacity: isHovered ? 0.6 : 0,\n+          pointerEvents: isHovered ? 'auto' : 'none',\n+          lineHeight: '1'\n+        }}\n+        onMouseEnter={(e) => {\n+          e.currentTarget.style.opacity = '1';\n+          e.currentTarget.style.color = '#d44';\n+        }}\n+        onMouseLeave={(e) => {\n+          e.currentTarget.style.opacity = '0.6';\n+          e.currentTarget.style.color = '#999';\n+        }}\n+        title=\"Delete chat\"\n+      >\n+        Ã—\n+      </button>\n+\n+      {/* Initial greeting or first message */}\n+      <div style={{\n+        display: 'flex',\n+        gap: '10px',\n+        alignItems: 'flex-start',\n+        marginBottom: '16px'\n+      }}>\n+        <Icon size={18} color=\"#666\" style={{ marginTop: '2px', flexShrink: 0 }} />\n+        <div style={{\n+          color: '#444',\n+          fontSize: '15px',\n+          lineHeight: '1.6',\n+          fontFamily: \"'Excalifont', 'Xiaolai', 'Georgia', serif\",\n+          flex: 1\n+        }}>\n+          {data.messages.length === 0\n+            ? \"What's up?\"\n+            : data.messages[0].role === 'assistant'\n+              ? data.messages[0].content\n+              : \"What's up?\"\n+          }\n+        </div>\n+      </div>\n+\n+      {/* Messages (skip first if it's assistant) */}\n+      <div\n+        ref={messagesContainerRef}\n+        style={{\n+          maxHeight: '300px',\n+          overflowY: 'auto',\n+          marginBottom: '16px'\n+        }}\n+      >\n+        {data.messages.length > 0 && (\n+          data.messages\n+            .slice(data.messages[0].role === 'assistant' ? 1 : 0)\n+            .map((msg, idx) => (\n+              <div\n+                key={idx}\n+                style={{\n+                  marginBottom: '12px',\n+                  display: 'flex',\n+                  gap: '10px',\n+                  alignItems: 'flex-start'\n+                }}\n+              >\n+                {msg.role === 'user' ? (\n+                  <>\n+                    <div style={{\n+                      width: '26px',\n+                      height: '26px',\n+                      borderRadius: '50%',\n+                      backgroundColor: 'rgba(100, 100, 100, 0.1)',\n+                      flexShrink: 0,\n+                      display: 'flex',\n+                      alignItems: 'center',\n+                      justifyContent: 'center',\n+                      fontSize: '11px',\n+                      color: '#666',\n+                      fontWeight: 600,\n+                      fontFamily: 'system-ui'\n+                    }}>\n+                      U\n+                    </div>\n+                    <div style={{\n+                      color: '#555',\n+                      fontSize: '15px',\n+                      lineHeight: '1.6',\n+                      paddingTop: '2px',\n+                      fontFamily: \"'Excalifont', 'Xiaolai', 'Georgia', serif\"\n+                    }}>\n+                      {msg.content}\n+                    </div>\n+                  </>\n+                ) : (\n+                  <>\n+                    <Icon size={18} color=\"#666\" style={{ marginTop: '2px', flexShrink: 0 }} />\n+                    <div style={{\n+                      color: '#444',\n+                      fontSize: '15px',\n+                      lineHeight: '1.6',\n+                      paddingTop: '2px',\n+                      fontFamily: \"'Excalifont', 'Xiaolai', 'Georgia', serif\"\n+                    }}>\n+                      {msg.content}\n+                    </div>\n+                  </>\n+                )}\n+              </div>\n+            ))\n+        )}\n+      </div>\n+\n+      {/* Input */}\n+      <div style={{\n+        display: 'flex',\n+        gap: '10px',\n+        alignItems: 'center',\n+        paddingTop: '4px'\n+      }}>\n+        <input\n+          type=\"text\"\n+          value={inputValue}\n+          onChange={(e) => setInputValue(e.target.value)}\n+          onKeyDown={handleKeyDown}\n+          placeholder={`Chat with ${data.voiceConfig.name}...`}\n+          disabled={isProcessing}\n+          style={{\n+            flex: 1,\n+            padding: '8px 12px',\n+            border: 'none',\n+            borderBottom: '2px solid rgba(0, 0, 0, 0.1)',\n+            fontSize: '15px',\n+            outline: 'none',\n+            backgroundColor: 'transparent',\n+            fontFamily: \"'Excalifont', 'Xiaolai', 'Georgia', serif\",\n+            color: '#444',\n+            transition: 'border-color 0.2s'\n+          }}\n+          onFocus={(e) => {\n+            e.currentTarget.style.borderBottomColor = 'rgba(0, 0, 0, 0.2)';\n+          }}\n+          onBlur={(e) => {\n+            e.currentTarget.style.borderBottomColor = 'rgba(0, 0, 0, 0.1)';\n+          }}\n+        />\n+        <button\n+          onClick={handleSend}\n+          disabled={!inputValue.trim() || isProcessing}\n+          style={{\n+            padding: '6px 14px',\n+            backgroundColor: 'transparent',\n+            color: isProcessing || !inputValue.trim() ? '#ccc' : '#666',\n+            border: '1.5px solid',\n+            borderColor: isProcessing || !inputValue.trim() ? 'rgba(0,0,0,0.1)' : 'rgba(0,0,0,0.2)',\n+            borderRadius: '6px',\n+            fontSize: '14px',\n+            fontWeight: 500,\n+            cursor: isProcessing || !inputValue.trim() ? 'not-allowed' : 'pointer',\n+            transition: 'all 0.2s',\n+            fontFamily: 'system-ui'\n+          }}\n+          onMouseEnter={(e) => {\n+            if (!isProcessing && inputValue.trim()) {\n+              e.currentTarget.style.backgroundColor = 'rgba(0,0,0,0.05)';\n+            }\n+          }}\n+          onMouseLeave={(e) => {\n+            e.currentTarget.style.backgroundColor = 'transparent';\n+          }}\n+        >\n+          {isProcessing ? '...' : 'â†µ'}\n+        </button>\n+      </div>\n+    </div>\n+  );\n+}"
    },
    {
      "sha": "8a128a9d8dc03bf370bf79c81391bb7bda67c19e",
      "filename": "frontend/src/components/VoiceSettings.tsx",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/a4eb52998c60b0de1bbf875423f681091b5eb39a/frontend%2Fsrc%2Fcomponents%2FVoiceSettings.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/a4eb52998c60b0de1bbf875423f681091b5eb39a/frontend%2Fsrc%2Fcomponents%2FVoiceSettings.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FVoiceSettings.tsx?ref=a4eb52998c60b0de1bbf875423f681091b5eb39a",
      "patch": "@@ -73,7 +73,7 @@ export default function VoiceSettings({ defaultVoices, onSave }: Props) {\n   };\n \n   const handleRename = (id: string, newName: string) => {\n-    // Just update the name, keep the ID stable to avoid React re-renders\n+    // Just update the name, keep the ID stable\n     setVoices({ ...voices, [id]: { ...voices[id], name: newName } });\n   };\n \n@@ -155,6 +155,7 @@ export default function VoiceSettings({ defaultVoices, onSave }: Props) {\n                   type=\"text\"\n                   value={voice.name}\n                   onChange={e => handleRename(id, e.target.value)}\n+                  placeholder=\"Voice Name\"\n                   style={{ flex: 1, border: 'none', borderBottom: '1px solid #d0c4b0', fontSize: 14, fontWeight: 'bold', background: 'transparent', padding: '4px 0' }}\n                 />\n               </label>"
    },
    {
      "sha": "b37cbc7fd1b5174746e319d5ab2fde323e9e8a49",
      "filename": "frontend/src/engine/ChatWidget.ts",
      "status": "added",
      "additions": 98,
      "deletions": 0,
      "changes": 98,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/a4eb52998c60b0de1bbf875423f681091b5eb39a/frontend%2Fsrc%2Fengine%2FChatWidget.ts",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/a4eb52998c60b0de1bbf875423f681091b5eb39a/frontend%2Fsrc%2Fengine%2FChatWidget.ts",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fengine%2FChatWidget.ts?ref=a4eb52998c60b0de1bbf875423f681091b5eb39a",
      "patch": "@@ -0,0 +1,98 @@\n+/**\n+ * ChatWidget - Persistent 1-to-1 chat with a voice agent\n+ *\n+ * Each widget maintains its own conversation history.\n+ * The widget is inserted after the line where @ was triggered.\n+ */\n+\n+export interface ChatMessage {\n+  role: 'user' | 'assistant';\n+  content: string;\n+  timestamp: number;\n+}\n+\n+export interface ChatWidgetData {\n+  id: string;\n+  voiceName: string;\n+  voiceConfig: {\n+    name: string;\n+    tagline: string;\n+    icon: string;\n+    color: string;\n+  };\n+  messages: ChatMessage[];\n+  createdAt: number;\n+}\n+\n+export class ChatWidget {\n+  private data: ChatWidgetData;\n+\n+  constructor(voiceName: string, voiceConfig: any) {\n+    this.data = {\n+      id: crypto.randomUUID ? crypto.randomUUID() : Date.now().toString(),\n+      voiceName,\n+      voiceConfig: {\n+        name: voiceConfig.name,\n+        tagline: voiceConfig.systemPrompt || voiceConfig.tagline,\n+        icon: voiceConfig.icon,\n+        color: voiceConfig.color\n+      },\n+      messages: [],\n+      createdAt: Date.now()\n+    };\n+  }\n+\n+  // @@@ Load from saved state\n+  static fromData(data: ChatWidgetData): ChatWidget {\n+    const widget = Object.create(ChatWidget.prototype);\n+    widget.data = data;\n+    return widget;\n+  }\n+\n+  // @@@ Add user message (frontend only, before sending to backend)\n+  addUserMessage(content: string): void {\n+    this.data.messages.push({\n+      role: 'user',\n+      content,\n+      timestamp: Date.now()\n+    });\n+  }\n+\n+  // @@@ Add assistant response (after backend returns)\n+  addAssistantMessage(content: string): void {\n+    this.data.messages.push({\n+      role: 'assistant',\n+      content,\n+      timestamp: Date.now()\n+    });\n+  }\n+\n+  // @@@ Get conversation history for backend API\n+  getConversationHistory(): Array<{ role: string; content: string }> {\n+    return this.data.messages.map(msg => ({\n+      role: msg.role,\n+      content: msg.content\n+    }));\n+  }\n+\n+  // @@@ Get all data for persistence\n+  getData(): ChatWidgetData {\n+    return this.data;\n+  }\n+\n+  getId(): string {\n+    return this.data.id;\n+  }\n+\n+  getVoiceName(): string {\n+    return this.data.voiceName;\n+  }\n+\n+  getVoiceConfig(): ChatWidgetData['voiceConfig'] {\n+    return this.data.voiceConfig;\n+  }\n+\n+  getMessages(): ChatMessage[] {\n+    return this.data.messages;\n+  }\n+}"
    },
    {
      "sha": "66d49fa759c4c11d73fc505ce6cbcfd1040c13de",
      "filename": "frontend/src/engine/EditorEngine.ts",
      "status": "modified",
      "additions": 234,
      "deletions": 16,
      "changes": 250,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/a4eb52998c60b0de1bbf875423f681091b5eb39a/frontend%2Fsrc%2Fengine%2FEditorEngine.ts",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/a4eb52998c60b0de1bbf875423f681091b5eb39a/frontend%2Fsrc%2Fengine%2FEditorEngine.ts",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fengine%2FEditorEngine.ts?ref=a4eb52998c60b0de1bbf875423f681091b5eb39a",
      "patch": "@@ -65,7 +65,7 @@ export function computeWeight(text: string): number {\n     }\n     // Chinese comma (ignored)\n     else if (char === 'ï¼Œ') {\n-      weight += 0;\n+      // Skip: weight += 0\n     }\n     // CJK characters\n     else if (/[\\u4e00-\\u9fa5\\u3040-\\u309f\\u30a0-\\u30ff]/.test(char)) {\n@@ -106,6 +106,7 @@ export class EditorEngine {\n   private sentCache: Map<string, string> = new Map(); // Track sent sentences -> commentor hash\n   private onStateChange?: (state: EditorState) => void;\n   private isRequesting: boolean = false; // Track if request in progress\n+  private voiceConfigs: Record<string, any> = {}; // Voice configurations from settings\n \n   constructor(sessionId: string) {\n     this.state = {\n@@ -117,16 +118,26 @@ export class EditorEngine {\n     };\n   }\n \n-  // @@@ Update text and track weight changes\n-  updateText(newText: string) {\n-    // Update the first text cell (for now, single cell mode)\n-    const textCell = this.state.cells.find(c => c.type === 'text') as TextCell;\n-    if (!textCell) return;\n+  // @@@ Update voice configurations from settings\n+  setVoiceConfigs(configs: Record<string, any>) {\n+    this.voiceConfigs = configs;\n+  }\n+\n+  // @@@ Update a specific text cell by ID\n+  updateTextCell(cellId: string, newText: string) {\n+    const cell = this.state.cells.find(c => c.id === cellId);\n+    if (!cell || cell.type !== 'text') return;\n+\n+    (cell as TextCell).content = newText;\n+    this.applyTextUpdate();\n+  }\n \n-    textCell.content = newText;\n+  // @@@ Apply weight calculation and trigger analysis\n+  private applyTextUpdate() {\n+    const combinedText = this.getCombinedText();\n \n     // Compute new weight entry\n-    const weight = computeWeight(newText);\n+    const weight = computeWeight(combinedText);\n     const lastEntry = this.state.weightPath[this.state.weightPath.length - 1];\n     const prevWeight = lastEntry?.weight || 0;\n     const delta = Math.max(0, weight - prevWeight);\n@@ -136,21 +147,30 @@ export class EditorEngine {\n     // Add to weight path\n     this.state.weightPath.push({\n       timestamp: Date.now(),\n-      text: newText,\n+      text: combinedText,\n       weight,\n       delta,\n       energy\n     });\n \n     // Check if we should request analysis\n-    this.checkAnalysisTrigger(newText, energy);\n+    this.checkAnalysisTrigger(combinedText, energy);\n \n     // Check if we can apply commentors\n-    this.checkCommentorApplication(newText, energy);\n+    this.checkCommentorApplication(combinedText, energy);\n \n     this.notifyChange();\n   }\n \n+  // @@@ Get combined text from all text cells\n+  private getCombinedText(): string {\n+    return this.state.cells\n+      .filter(c => c.type === 'text')\n+      .map(c => (c as TextCell).content)\n+      .join('');\n+  }\n+\n+\n   // @@@ Check if we should send text for analysis\n   private checkAnalysisTrigger(text: string, _currentEnergy: number) {\n     const completedSentences = getCompletedSentences(text);\n@@ -164,12 +184,11 @@ export class EditorEngine {\n     const commentorHash = this.getCommentorHash();\n \n     // Check if this text+commentor combination was already sent\n-    const cacheKey = completedSentences;\n-    const cachedHash = this.sentCache.get(cacheKey);\n+    const cachedHash = this.sentCache.get(completedSentences);\n \n     // Only send if not in cache OR commentor config changed\n     if (!cachedHash || cachedHash !== commentorHash) {\n-      this.sentCache.set(cacheKey, commentorHash);\n+      this.sentCache.set(completedSentences, commentorHash);\n \n       // Request analysis from backend (async, results go to waitlist)\n       this.requestAnalysis(completedSentences);\n@@ -242,9 +261,22 @@ export class EditorEngine {\n       // Call backend (returns ONLY ONE comment at a time)\n       const { analyzeText } = await import('../api/voiceApi');\n \n+      // Convert voiceConfigs to backend format\n+      const backendVoices: Record<string, any> = {};\n+      for (const [name, cfg] of Object.entries(this.voiceConfigs)) {\n+        if (cfg.enabled) {\n+          backendVoices[name] = {\n+            name: cfg.name,\n+            tagline: cfg.systemPrompt,\n+            icon: cfg.icon,\n+            color: cfg.color\n+          };\n+        }\n+      }\n+\n       // Send only APPLIED commentors to backend\n       const appliedCommentors = this.state.commentors.filter(c => c.appliedAt);\n-      const result = await analyzeText(text, this.state.sessionId, undefined, appliedCommentors);\n+      const result = await analyzeText(text, this.state.sessionId, backendVoices, appliedCommentors);\n \n       // Backend returns at most ONE voice\n       if (result.voices.length > 0) {\n@@ -304,7 +336,166 @@ export class EditorEngine {\n     }\n   }\n \n-  // @@@ Add a widget cell\n+  // @@@ Merge consecutive text cells to prevent text-text pattern\n+  private mergeConsecutiveTextCells() {\n+    const merged: Cell[] = [];\n+    let i = 0;\n+    let mergeCount = 0;\n+\n+    while (i < this.state.cells.length) {\n+      const cell = this.state.cells[i];\n+\n+      if (cell.type === 'text') {\n+        // Collect all consecutive text cells\n+        let combinedContent = (cell as TextCell).content;\n+        let j = i + 1;\n+        let mergedCells = 0;\n+\n+        while (j < this.state.cells.length && this.state.cells[j].type === 'text') {\n+          combinedContent += (this.state.cells[j] as TextCell).content;\n+          j++;\n+          mergedCells++;\n+        }\n+\n+        if (mergedCells > 0) {\n+          mergeCount += mergedCells;\n+          console.log(`ðŸ”— Merged ${mergedCells + 1} consecutive text cells into one`);\n+        }\n+\n+        // Add merged text cell\n+        merged.push({\n+          id: cell.id, // Keep first cell's ID\n+          type: 'text',\n+          content: combinedContent\n+        });\n+\n+        i = j; // Skip all merged cells\n+      } else {\n+        merged.push(cell);\n+        i++;\n+      }\n+    }\n+\n+    if (mergeCount > 0) {\n+      console.log(`âœ… Total merged: ${mergeCount} cells â†’ Final cell count: ${merged.length}`);\n+    }\n+\n+    this.state.cells = merged;\n+  }\n+\n+  // @@@ Insert widget at cursor, removing @ character if present\n+  insertWidgetAtCursor(cellId: string, cursorPosition: number, widgetType: WidgetCell['widgetType'], data: any) {\n+    const cell = this.state.cells.find(c => c.id === cellId);\n+    if (!cell || cell.type !== 'text') return;\n+\n+    const text = (cell as TextCell).content;\n+\n+    // Remove @ character if it's right before cursor\n+    const atPosition = cursorPosition - 1;\n+    if (atPosition >= 0 && text[atPosition] === '@') {\n+      // Check if @ is the only character on its line\n+      const lineStart = text.lastIndexOf('\\n', atPosition - 1) + 1;\n+      const lineEnd = text.indexOf('\\n', cursorPosition);\n+      const lineEndPos = lineEnd === -1 ? text.length : lineEnd;\n+      const lineContent = text.substring(lineStart, lineEndPos);\n+      const isOnlyCharOnLine = lineContent.trim() === '@';\n+\n+      // Remove the @ and optionally the newline\n+      let newText: string;\n+      if (isOnlyCharOnLine) {\n+        // @ is alone on its line - remove the newline before it (if exists)\n+        const hasNewlineBefore = atPosition > 0 && text[atPosition - 1] === '\\n';\n+        if (hasNewlineBefore) {\n+          // Remove the newline before @ and the @\n+          newText = text.substring(0, atPosition - 1) + text.substring(cursorPosition);\n+          console.log('âœ‚ï¸ Removed newline before @ and the @');\n+        } else {\n+          // Just remove @\n+          newText = text.substring(0, atPosition) + text.substring(cursorPosition);\n+          console.log('âœ‚ï¸ Removed @ only (first line)');\n+        }\n+      } else {\n+        // @ is not alone - just remove @\n+        newText = text.substring(0, atPosition) + text.substring(cursorPosition);\n+        console.log('âœ‚ï¸ Removed @ only (inline)');\n+      }\n+      (cell as TextCell).content = newText;\n+\n+      // Insert widget at the @ position (adjust if we removed newline before)\n+      const insertPos = isOnlyCharOnLine && atPosition > 0 && text[atPosition - 1] === '\\n'\n+        ? atPosition - 1\n+        : atPosition;\n+      this.insertWidgetAfterLine(cellId, insertPos, widgetType, data);\n+    } else {\n+      // No @ found, just insert widget at cursor position\n+      this.insertWidgetAfterLine(cellId, cursorPosition, widgetType, data);\n+    }\n+  }\n+\n+  // @@@ Add a widget cell after a specific text position in a specific cell\n+  insertWidgetAfterLine(cellId: string, cursorPosition: number, widgetType: WidgetCell['widgetType'], data: any) {\n+    // Find the specific cell and its index\n+    const cellIndex = this.state.cells.findIndex(c => c.id === cellId);\n+    if (cellIndex === -1) return;\n+\n+    const cell = this.state.cells[cellIndex];\n+    if (cell.type !== 'text') return;\n+\n+    const text = (cell as TextCell).content;\n+\n+    // Find the line end after cursor position\n+    let lineEndPos = text.indexOf('\\n', cursorPosition);\n+    if (lineEndPos === -1) {\n+      lineEndPos = text.length;\n+    } else {\n+      lineEndPos += 1; // Include the newline\n+    }\n+\n+    // Split text into before and after\n+    const beforeText = text.substring(0, lineEndPos);\n+    const afterText = text.substring(lineEndPos);\n+\n+    // Create replacement cells for this position\n+    const replacementCells: Cell[] = [];\n+\n+    // Text before widget (only if non-empty)\n+    if (beforeText.length > 0) {\n+      replacementCells.push({\n+        id: generateId(),\n+        type: 'text',\n+        content: beforeText\n+      });\n+    }\n+\n+    // Widget cell\n+    replacementCells.push({\n+      id: generateId(),\n+      type: 'widget',\n+      widgetType,\n+      data\n+    });\n+\n+    // Text after widget (only if non-empty, otherwise rely on adjacent cell or create empty)\n+    // Always add if non-empty, or if this is the last cell (to allow continued writing)\n+    const isLastCell = cellIndex === this.state.cells.length - 1;\n+    const hasNextTextCell = cellIndex + 1 < this.state.cells.length &&\n+                           this.state.cells[cellIndex + 1].type === 'text';\n+\n+    if (afterText.length > 0 || (isLastCell && !hasNextTextCell)) {\n+      replacementCells.push({\n+        id: generateId(),\n+        type: 'text',\n+        content: afterText\n+      });\n+    }\n+\n+    // Replace the cell at cellIndex with the new cells, keeping all other cells intact\n+    this.state.cells.splice(cellIndex, 1, ...replacementCells);\n+    this.mergeConsecutiveTextCells(); // Ensure no consecutive text cells\n+    this.notifyChange();\n+  }\n+\n+  // @@@ Add a widget cell at the end\n   addWidgetCell(widgetType: WidgetCell['widgetType'], data: any) {\n     const widget: WidgetCell = {\n       id: generateId(),\n@@ -316,6 +507,15 @@ export class EditorEngine {\n     this.notifyChange();\n   }\n \n+  // @@@ Update widget data (for chat messages)\n+  updateWidgetData(widgetId: string, data: any) {\n+    const widget = this.state.cells.find(c => c.type === 'widget' && c.id === widgetId);\n+    if (widget && widget.type === 'widget') {\n+      widget.data = data;\n+      this.notifyChange();\n+    }\n+  }\n+\n   // @@@ Subscribe to state changes\n   subscribe(callback: (state: EditorState) => void) {\n     this.onStateChange = callback;\n@@ -337,6 +537,24 @@ export class EditorEngine {\n     this.usedEnergy = this.state.commentors.filter(c => c.appliedAt).length * this.threshold;\n     this.notifyChange();\n   }\n+\n+  // @@@ Delete a cell by ID\n+  deleteCell(cellId: string) {\n+    const cellIndex = this.state.cells.findIndex(c => c.id === cellId);\n+    if (cellIndex === -1) return;\n+\n+    this.state.cells.splice(cellIndex, 1);\n+\n+    // Ensure we always have at least one text cell\n+    if (this.state.cells.length === 0) {\n+      this.state.cells.push({ id: generateId(), type: 'text', content: '' });\n+    }\n+\n+    // Merge consecutive text cells (important when deleting a widget between text cells)\n+    this.mergeConsecutiveTextCells();\n+\n+    this.notifyChange();\n+  }\n }\n \n // @@@ Helper to generate IDs"
    }
  ]
}