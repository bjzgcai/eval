{
  "sha": "baaa7c48bbe4681ca47b0322800073d29e853e58",
  "node_id": "C_kwDOP2Zrm9oAKGJhYWE3YzQ4YmJlNDY4MWNhNDdiMDMyMjgwMDA3M2QyOWU4NTNlNTg",
  "commit": {
    "author": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-11-21T10:00:36Z"
    },
    "committer": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-11-21T10:00:36Z"
    },
    "message": "Sync timeline/calendar data and persist timezones",
    "tree": {
      "sha": "d9d8dd2977867b9d345e53676c17ceed60de1d4f",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/trees/d9d8dd2977867b9d345e53676c17ceed60de1d4f"
    },
    "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/commits/baaa7c48bbe4681ca47b0322800073d29e853e58",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null,
      "verified_at": null
    }
  },
  "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/baaa7c48bbe4681ca47b0322800073d29e853e58",
  "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/baaa7c48bbe4681ca47b0322800073d29e853e58",
  "comments_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/baaa7c48bbe4681ca47b0322800073d29e853e58/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "d7648abef143902c3abde6ab14cf53f343281547",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/d7648abef143902c3abde6ab14cf53f343281547",
      "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/d7648abef143902c3abde6ab14cf53f343281547"
    }
  ],
  "stats": {
    "total": 414,
    "additions": 302,
    "deletions": 112
  },
  "files": [
    {
      "sha": "77f12d5eeeb3412cff029131ef460c76d36dea3b",
      "filename": "backend/database.py",
      "status": "modified",
      "additions": 15,
      "deletions": 5,
      "changes": 20,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/baaa7c48bbe4681ca47b0322800073d29e853e58/backend%2Fdatabase.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/baaa7c48bbe4681ca47b0322800073d29e853e58/backend%2Fdatabase.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fdatabase.py?ref=baaa7c48bbe4681ca47b0322800073d29e853e58",
      "patch": "@@ -96,12 +96,18 @@ def create_tables(db):\n       meta_prompt TEXT,\n       state_config_json TEXT,\n       selected_state TEXT,\n+      timezone TEXT,\n       first_login_completed INTEGER DEFAULT 0,\n       updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n       FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE\n     )\n     \"\"\")\n \n+    try:\n+        db.execute(\"ALTER TABLE user_preferences ADD COLUMN timezone TEXT\")\n+    except Exception:\n+        pass\n+\n     # Auth sessions\n     db.execute(\"\"\"\n     CREATE TABLE IF NOT EXISTS auth_sessions (\n@@ -1290,7 +1296,7 @@ def get_friend_picture_full(user_id: int, friend_id: int, date: str):\n # ========== User Preferences ==========\n \n def save_preferences(user_id: int, voice_configs: dict = None, meta_prompt: str = None,\n-                    state_config: dict = None, selected_state: str = None):\n+                    state_config: dict = None, selected_state: str = None, timezone: str = None):\n     \"\"\"Save or update user preferences.\"\"\"\n     db = get_db()\n     try:\n@@ -1313,6 +1319,9 @@ def save_preferences(user_id: int, voice_configs: dict = None, meta_prompt: str\n             if selected_state is not None:\n                 updates.append(\"selected_state = ?\")\n                 params.append(selected_state)\n+            if timezone is not None:\n+                updates.append(\"timezone = ?\")\n+                params.append(timezone)\n \n             if updates:\n                 updates.append(\"updated_at = CURRENT_TIMESTAMP\")\n@@ -1321,13 +1330,14 @@ def save_preferences(user_id: int, voice_configs: dict = None, meta_prompt: str\n         else:\n             # Insert\n             db.execute(\"\"\"\n-            INSERT INTO user_preferences (user_id, voice_configs_json, meta_prompt, state_config_json, selected_state)\n-            VALUES (?, ?, ?, ?, ?)\n+            INSERT INTO user_preferences (user_id, voice_configs_json, meta_prompt, state_config_json, selected_state, timezone)\n+            VALUES (?, ?, ?, ?, ?, ?)\n             \"\"\", (user_id,\n                   json.dumps(voice_configs) if voice_configs else None,\n                   meta_prompt,\n                   json.dumps(state_config) if state_config else None,\n-                  selected_state))\n+                  selected_state,\n+                  timezone))\n \n         db.commit()\n     finally:\n@@ -1339,7 +1349,7 @@ def get_preferences(user_id: int):\n     try:\n         row = db.execute(\"\"\"\n         SELECT voice_configs_json, meta_prompt, state_config_json, selected_state,\n-               first_login_completed, updated_at\n+               timezone, first_login_completed, updated_at\n         FROM user_preferences\n         WHERE user_id = ?\n         \"\"\", (user_id,)).fetchone()"
    },
    {
      "sha": "8125aab39accd861625bfebe58d92140541eeaed",
      "filename": "backend/scheduler.py",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/baaa7c48bbe4681ca47b0322800073d29e853e58/backend%2Fscheduler.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/baaa7c48bbe4681ca47b0322800073d29e853e58/backend%2Fscheduler.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fscheduler.py?ref=baaa7c48bbe4681ca47b0322800073d29e853e58",
      "patch": "@@ -6,6 +6,13 @@\n Runs concurrently for all users with activity on the previous day.\n \"\"\"\n \n+import os\n+import time\n+\n+os.environ.setdefault('TZ', 'UTC')\n+if hasattr(time, 'tzset'):\n+    time.tzset()\n+\n import asyncio\n from concurrent.futures import ThreadPoolExecutor, as_completed\n from datetime import datetime, timedelta"
    },
    {
      "sha": "2f745fa59050abb9fd735e12a3c06cf7a1d327ee",
      "filename": "backend/server.py",
      "status": "modified",
      "additions": 9,
      "deletions": 1,
      "changes": 10,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/baaa7c48bbe4681ca47b0322800073d29e853e58/backend%2Fserver.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/baaa7c48bbe4681ca47b0322800073d29e853e58/backend%2Fserver.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fserver.py?ref=baaa7c48bbe4681ca47b0322800073d29e853e58",
      "patch": "@@ -1,6 +1,13 @@\n #!/usr/bin/env python3\n \"\"\"FastAPI-based voice analysis server with sync API support.\"\"\"\n \n+import os\n+import time\n+\n+os.environ.setdefault('TZ', 'UTC')\n+if hasattr(time, 'tzset'):\n+    time.tzset()\n+\n import asyncio\n import httpx\n from fastapi import FastAPI, HTTPException, Depends, Header\n@@ -1242,7 +1249,8 @@ def save_preferences_endpoint(\n         voice_configs=request.get('voice_configs'),\n         meta_prompt=request.get('meta_prompt'),\n         state_config=request.get('state_config'),\n-        selected_state=request.get('selected_state')\n+        selected_state=request.get('selected_state'),\n+        timezone=request.get('timezone')\n     )\n \n     return {\"success\": True}"
    },
    {
      "sha": "771dfb671ce8c4150d61bbc3d6616476a57b1ee3",
      "filename": "frontend/src/App.tsx",
      "status": "modified",
      "additions": 96,
      "deletions": 35,
      "changes": 131,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/baaa7c48bbe4681ca47b0322800073d29e853e58/frontend%2Fsrc%2FApp.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/baaa7c48bbe4681ca47b0322800073d29e853e58/frontend%2Fsrc%2FApp.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2FApp.tsx?ref=baaa7c48bbe4681ca47b0322800073d29e853e58",
      "patch": "@@ -299,6 +299,50 @@ export default function App() {\n   const prevInspirationRef = useRef<VoiceInspiration | null>(null);\n   const [_suggestionSnapshot, setSuggestionSnapshot] = useState<string>('');  // Not used yet\n   const suggestionTimerRef = useRef<number | null>(null);\n+  const browserTimezone = useMemo(() => {\n+    try {\n+      return Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';\n+    } catch {\n+      return 'UTC';\n+    }\n+  }, []);\n+  const timezoneSyncRef = useRef<string | null>(null);\n+\n+  const ensureStateForPersistence = useCallback((): EditorState | null => {\n+    if (engineRef.current) {\n+      const engineState = engineRef.current.getState();\n+      if (!engineState.createdAt) {\n+        engineState.createdAt = new Date().toISOString().split('T')[0];\n+        setState({ ...engineState });\n+      }\n+      return engineState;\n+    }\n+\n+    if (state && !state.createdAt) {\n+      const today = new Date().toISOString().split('T')[0];\n+      const nextState = { ...state, createdAt: today };\n+      setState(nextState);\n+      return nextState;\n+    }\n+\n+    return state;\n+  }, [state]);\n+\n+  const getFirstLineFromState = useCallback((editorState: EditorState) => {\n+    const firstTextCell = editorState.cells.find(c => c.type === 'text') as TextCell | undefined;\n+    return firstTextCell?.content.split('\\n')[0].trim() || 'Untitled';\n+  }, []);\n+\n+  const saveSessionToDatabase = useCallback(async (editorState: EditorState, firstLine?: string) => {\n+    const line = firstLine ?? getFirstLineFromState(editorState);\n+    const { saveSession } = await import('./api/voiceApi');\n+    const sessionId = editorState.currentEntryId || crypto.randomUUID();\n+    await saveSession(sessionId, editorState, line);\n+    if (engineRef.current) {\n+      engineRef.current.setCurrentEntryId(sessionId);\n+    }\n+    return sessionId;\n+  }, [getFirstLineFromState]);\n \n   // @@@ Detect if this is a new inspiration appearing (different from previous)\n   // Only check appearing when NOT disappearing (to avoid conflict)\n@@ -463,6 +507,29 @@ export default function App() {\n     checkMigration();\n   }, [isAuthenticated, isLoading]);\n \n+  useEffect(() => {\n+    if (!isAuthenticated) return;\n+    const timezone = browserTimezone || 'UTC';\n+    if (!timezone) return;\n+    if (timezoneSyncRef.current === timezone) return;\n+\n+    const syncTimezone = async () => {\n+      try {\n+        const { getPreferences, savePreferences } = await import('./api/voiceApi');\n+        const prefs = await getPreferences();\n+        if ((prefs?.timezone || 'UTC') !== timezone) {\n+          await savePreferences({ timezone });\n+        }\n+      } catch (error) {\n+        console.error('Failed to sync timezone preference:', error);\n+      } finally {\n+        timezoneSyncRef.current = timezone;\n+      }\n+    };\n+\n+    syncTimezone();\n+  }, [isAuthenticated, browserTimezone]);\n+\n   // Initialize engine\n   useEffect(() => {\n     const sessionId = crypto.randomUUID ? crypto.randomUUID() : Date.now().toString();\n@@ -670,32 +737,27 @@ export default function App() {\n \n   // @@@ Auto-save to database for authenticated users\n   useEffect(() => {\n-    if (!isAuthenticated || !state) return;\n-\n-    // @@@ currentEntryId is always defined after engine initialization\n-    if (!state.currentEntryId) {\n-      console.error('BUG: currentEntryId should always be defined after engine init');\n-      return;\n-    }\n+    if (!isAuthenticated) return;\n \n     const autoSaveTimer = setTimeout(async () => {\n-      try {\n-        // @@@ Auto-save: update content only, preserve existing name\n-        // Date comes from created_at, so we don't include it in name\n-        const firstTextCell = state.cells.find(c => c.type === 'text') as TextCell | undefined;\n-        const firstLine = firstTextCell?.content.split('\\n')[0].trim() || 'Untitled';\n+      const currentState = ensureStateForPersistence();\n+      if (!currentState) return;\n+      if (!currentState.currentEntryId) {\n+        console.error('BUG: currentEntryId should always be defined after engine init');\n+        return;\n+      }\n \n-        const { saveSession } = await import('./api/voiceApi');\n-        const sessionId = state.currentEntryId || crypto.randomUUID();\n-        await saveSession(sessionId, state, firstLine);\n+      try {\n+        const firstLine = getFirstLineFromState(currentState);\n+        await saveSessionToDatabase(currentState, firstLine);\n         console.log('Auto-saved to database');\n       } catch (error) {\n         console.error('Auto-save failed:', error);\n       }\n-    }, 3000); // Save 3 seconds after last change\n+    }, 3000);\n \n     return () => clearTimeout(autoSaveTimer);\n-  }, [state, isAuthenticated]);\n+  }, [ensureStateForPersistence, getFirstLineFromState, isAuthenticated, saveSessionToDatabase, state]);\n \n   // @@@ Group comments by 2-row blocks, accounting for widgets between cells\n   const commentGroups = useMemo(() => {\n@@ -1152,31 +1214,25 @@ export default function App() {\n   }, [isAuthenticated]);\n \n   const handleSaveToday = useCallback(async () => {\n-    if (!state || !engineRef.current) return;\n+    if (!engineRef.current) return;\n+    const currentState = ensureStateForPersistence();\n+    if (!currentState) return;\n \n     try {\n-      // @@@ Save to database if authenticated, localStorage if guest\n-      if (isAuthenticated) {\n-        // @@@ Save with title only (date comes from created_at)\n-        const firstTextCell = state.cells.find(c => c.type === 'text') as TextCell | undefined;\n-        const firstLine = firstTextCell?.content.split('\\n')[0].trim() || 'Untitled';\n-\n-        // Save to database\n-        const { saveSession } = await import('./api/voiceApi');\n-        const sessionId = state.currentEntryId || crypto.randomUUID();\n-        await saveSession(sessionId, state, firstLine);\n+      const hadExistingId = Boolean(currentState.currentEntryId);\n+      let updatedFlag = hadExistingId;\n \n-        // Update current entry ID in engine state\n-        engineRef.current.setCurrentEntryId(sessionId);\n+      if (isAuthenticated) {\n+        const firstLine = getFirstLineFromState(currentState);\n+        const savedSessionId = await saveSessionToDatabase(currentState, firstLine);\n+        engineRef.current.setCurrentEntryId(savedSessionId);\n       } else {\n-        // Guest mode: save to localStorage\n-        const entryId = saveEntryToToday(state);\n+        const entryId = saveEntryToToday(currentState);\n         engineRef.current.setCurrentEntryId(entryId);\n       }\n \n-      // Show toast notification\n       const toast = document.createElement('div');\n-      toast.textContent = state.currentEntryId ? 'Saved (updated)' : 'Saved';\n+      toast.textContent = updatedFlag ? 'Saved (updated)' : 'Saved';\n       toast.style.cssText = `\n         position: fixed;\n         top: 70px;\n@@ -1221,7 +1277,7 @@ export default function App() {\n         setTimeout(() => document.body.removeChild(toast), 300);\n       }, 2000);\n     }\n-  }, [state, isAuthenticated]);\n+  }, [ensureStateForPersistence, getFirstLineFromState, isAuthenticated, saveSessionToDatabase]);\n \n   const handleLoadEntry = useCallback((entry: CalendarEntry) => {\n     if (engineRef.current) {\n@@ -1235,6 +1291,11 @@ export default function App() {\n         setSelectedState(loadedState.selectedState);\n       }\n \n+      if (!loadedState.createdAt) {\n+        loadedState.createdAt = new Date().toISOString().split('T')[0];\n+        engineRef.current.loadState(loadedState);\n+      }\n+\n       // @@@ Trigger textarea resize after loading entry\n       setRefsReady(prev => prev + 1);\n "
    },
    {
      "sha": "fe5b53145d4e4e1c35d792efe79f05fce444924a",
      "filename": "frontend/src/api/voiceApi.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/baaa7c48bbe4681ca47b0322800073d29e853e58/frontend%2Fsrc%2Fapi%2FvoiceApi.ts",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/baaa7c48bbe4681ca47b0322800073d29e853e58/frontend%2Fsrc%2Fapi%2FvoiceApi.ts",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fapi%2FvoiceApi.ts?ref=baaa7c48bbe4681ca47b0322800073d29e853e58",
      "patch": "@@ -500,6 +500,7 @@ export async function savePreferences(preferences: {\n   meta_prompt?: string;\n   state_config?: any;\n   selected_state?: string;\n+  timezone?: string;\n }): Promise<void> {\n   const response = await fetch(`${API_BASE}/api/preferences`, {\n     method: 'POST',"
    },
    {
      "sha": "0c21ac39a7a6f8a3e4a0e5f32087eaef250634ec",
      "filename": "frontend/src/components/CalendarPopup.tsx",
      "status": "modified",
      "additions": 2,
      "deletions": 32,
      "changes": 34,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/baaa7c48bbe4681ca47b0322800073d29e853e58/frontend%2Fsrc%2Fcomponents%2FCalendarPopup.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/baaa7c48bbe4681ca47b0322800073d29e853e58/frontend%2Fsrc%2Fcomponents%2FCalendarPopup.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FCalendarPopup.tsx?ref=baaa7c48bbe4681ca47b0322800073d29e853e58",
      "patch": "@@ -8,6 +8,7 @@ import {\n   deleteEntry,\n   type CalendarEntry\n } from '../utils/calendarStorage';\n+import { loadSessionsGroupedByDate } from '../utils/sessionGrouping';\n import { useAuth } from '../contexts/AuthContext';\n \n interface Props {\n@@ -31,38 +32,7 @@ export default function CalendarPopup({ onLoadEntry, onClose, currentEntryId }:\n         try {\n           // Load from database - sessions imported during migration\n           const { listSessions, getSession } = await import('../api/voiceApi');\n-          const sessions = await listSessions();\n-\n-          // Group sessions by date (extract from session name which has format \"YYYY-MM-DD - FirstLine\")\n-          const grouped: Record<string, CalendarEntry[]> = {};\n-\n-          for (const session of sessions) {\n-            // @@@ Skip unnamed sessions (working drafts not saved yet)\n-            if (!session.name) continue;\n-\n-            const fullSession = await getSession(session.id);\n-\n-            // @@@ BUGFIX: Extract date from timestamp (format: \"2025-11-02 10:42:17\" or \"2025-11-02T10:42:17\")\n-            // Just take first 10 characters to get \"YYYY-MM-DD\"\n-            let dateKey = session.created_at?.substring(0, 10) || getTodayKey();\n-\n-            // If name starts with YYYY-MM-DD format, use that\n-            if (session.name && /^\\d{4}-\\d{2}-\\d{2}/.test(session.name)) {\n-              dateKey = session.name.split(' - ')[0];\n-            }\n-\n-            if (!grouped[dateKey]) {\n-              grouped[dateKey] = [];\n-            }\n-\n-            grouped[dateKey].push({\n-              id: session.id,\n-              timestamp: new Date(session.created_at || Date.now()).getTime(),\n-              state: fullSession.editor_state,\n-              firstLine: session.name\n-            });\n-          }\n-\n+          const grouped = await loadSessionsGroupedByDate(listSessions, getSession, { requireName: true });\n           setCalendarData(grouped);\n         } catch (error) {\n           console.error('Failed to load calendar from database:', error);"
    },
    {
      "sha": "b92c392959c1460c864a297c39b74da143a79197",
      "filename": "frontend/src/components/CollectionsView.tsx",
      "status": "modified",
      "additions": 82,
      "deletions": 37,
      "changes": 119,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/baaa7c48bbe4681ca47b0322800073d29e853e58/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/baaa7c48bbe4681ca47b0322800073d29e853e58/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx?ref=baaa7c48bbe4681ca47b0322800073d29e853e58",
      "patch": "@@ -6,6 +6,8 @@ import { useAuth } from '../contexts/AuthContext';\n import { STORAGE_KEYS } from '../constants/storageKeys';\n import { getDateLocale } from '../i18n';\n import type { Friend } from '../api/voiceApi';\n+import { extractFirstLine } from '../utils/calendarStorage';\n+import { loadSessionsGroupedByDate } from '../utils/sessionGrouping';\n \n // @@@ TypeScript interfaces\n interface TimelineDay {\n@@ -222,6 +224,7 @@ interface TimelineCardProps {\n   isGenerating: boolean;\n   placeholder: string;\n   textByDate: Map<string, string>;\n+  firstLineByDate: Map<string, string>;\n   dateLocale: string;\n   t: (key: string, options?: any) => string;\n   onImageClick: (picture: TimelinePicture) => void;\n@@ -237,6 +240,7 @@ function renderTimelineCard({\n   isGenerating,\n   placeholder,\n   textByDate,\n+  firstLineByDate,\n   dateLocale,\n   t,\n   onImageClick,\n@@ -245,7 +249,8 @@ function renderTimelineCard({\n   customDescription\n }: TimelineCardProps) {\n   const cardCursor = dayData?.picture && !isGenerating ? 'pointer' : 'default';\n-  const textContent = dayData && textByDate.get(day.date);\n+  const textContent = textByDate.get(day.date);\n+  const firstLine = firstLineByDate.get(day.date);\n   const commentCount = dayData?.comments?.length || 0;\n \n   let description = placeholder;\n@@ -255,6 +260,8 @@ function renderTimelineCard({\n     description = t('timeline.generating');\n   } else if (day.isToday && !dayData?.picture) {\n     description = placeholder;\n+  } else if (firstLine) {\n+    description = firstLine;\n   } else if (textContent) {\n     description = getTextPreview(textContent);\n   } else if (commentCount > 0) {\n@@ -456,6 +463,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n   const [starredComments, setStarredComments] = useState<Commentor[]>([]);\n   const [allCommentsByDate, setAllCommentsByDate] = useState<Map<string, Commentor[]>>(new Map());\n   const [textByDate, setTextByDate] = useState<Map<string, string>>(new Map());\n+  const [firstLineByDate, setFirstLineByDate] = useState<Map<string, string>>(new Map());\n   const [pictures, setPictures] = useState<TimelinePicture[]>([]);\n   const [generatingForDate, setGeneratingForDate] = useState<string | null>(null);\n   const [viewingImage, setViewingImage] = useState<{ base64: string; full_base64?: string; prompt: string; date: string; origin?: 'self' | 'friend'; friendId?: number } | null>(null);\n@@ -489,9 +497,10 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n   const [, setLoadingFriends] = useState(false);\n   const [friendLoadError, setFriendLoadError] = useState<string | null>(null);\n   const [, setFriendTimelineError] = useState<string | null>(null);\n-  const [, setLoadingFriendTimeline] = useState(false);\n+  const [loadingFriendTimeline, setLoadingFriendTimeline] = useState(false);\n   const scrollContainerRef = useRef<HTMLDivElement | null>(null);\n   const emptyTextMap = useMemo(() => new Map<string, string>(), []);\n+  const emptyFirstLineMap = useMemo(() => new Map<string, string>(), []);\n   const allTimelineDays = useMemo(() => generateTimelineDays(), []);\n   const filteredFriends = useMemo(() => {\n     const term = friendSearchTerm.trim().toLowerCase();\n@@ -547,29 +556,54 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n   const orderedRecentFriends = orderedFriendIds\n     .map(id => friendMap.get(id))\n     .filter((friend): friend is Friend => Boolean(friend));\n+  const friendTimelineByDate = useMemo(() => {\n+    const map = new Map<string, TimelineEntryData>();\n+    friendPictures.forEach(pic => {\n+      map.set(pic.date, { picture: pic, comments: [] });\n+    });\n+    return map;\n+  }, [friendPictures]);\n+  const friendHasVisibleCards = useMemo(() => {\n+    if (!selectedFriendId) return false;\n+    return allTimelineDays.some(day => Boolean(friendTimelineByDate.get(day.date)?.picture));\n+  }, [selectedFriendId, friendTimelineByDate, allTimelineDays]);\n+\n+  useEffect(() => {\n+    console.debug('[Timeline] friend hint state', {\n+      selectedFriendId,\n+      isFriendPickerOpen,\n+      friendPicturesCount: friendPictures.length,\n+      loadingFriendTimeline,\n+      visibleFriendCards: friendHasVisibleCards\n+    });\n+  }, [selectedFriendId, isFriendPickerOpen, friendPictures.length, loadingFriendTimeline, friendHasVisibleCards]);\n \n   useEffect(() => {\n     const loadTimelineData = async () => {\n       // @@@ Load all comments grouped by date from database if authenticated, localStorage if guest\n       if (isAuthenticated) {\n         try {\n           const { listSessions, getSession } = await import('../api/voiceApi');\n-          const sessions = await listSessions();\n+          const groupedEntries = await loadSessionsGroupedByDate(listSessions, getSession, { requireName: true });\n+\n           const allStarred: Commentor[] = [];\n           const commentsByDate = new Map<string, Commentor[]>();\n           const textByDateMap = new Map<string, string>();\n+          const firstLineMap = new Map<string, string>();\n \n-          for (const session of sessions) {\n-            try {\n-              const fullSession = await getSession(session.id);\n-              const comments = fullSession.editor_state?.commentors || [];\n+          Object.entries(groupedEntries).forEach(([dateKey, entries]) => {\n+            if (entries.length > 0 && !firstLineMap.has(dateKey)) {\n+              firstLineMap.set(dateKey, entries[0].firstLine);\n+            }\n \n-              // Collect starred comments for timeline cards\n+            entries.forEach(entry => {\n+              const state = entry.state;\n+              if (!state) return;\n+\n+              const comments = state.commentors || [];\n               const starred = comments.filter((c: Commentor) => c.feedback === 'star');\n               allStarred.push(...starred);\n \n-              // Group ALL comments by date (for image modal display)\n-              // @@@ Use each comment's appliedAt timestamp (not session's created_at) to handle timezone properly\n               comments.filter((c: Commentor) => c.appliedAt).forEach((comment: Commentor) => {\n                 const commentDate = new Date(comment.appliedAt || comment.computedAt);\n                 const date = getLocalDateString(commentDate);\n@@ -579,29 +613,23 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n                 commentsByDate.get(date)!.push(comment);\n               });\n \n-              // @@@ Extract text from session and group by creation date\n-              if (fullSession.editor_state?.createdAt && fullSession.editor_state?.cells) {\n-                const sessionDate = fullSession.editor_state.createdAt; // Already in YYYY-MM-DD format\n-                const text = fullSession.editor_state.cells\n-                  .filter((c: any) => c.type === 'text')\n-                  .map((c: any) => c.content)\n-                  .join(' ')\n-                  .trim();\n-\n-                if (text) {\n-                  // Append text for this date (sessions can have multiple entries per day)\n-                  const existingText = textByDateMap.get(sessionDate) || '';\n-                  textByDateMap.set(sessionDate, existingText ? `${existingText} ${text}` : text);\n-                }\n+              const text = state.cells\n+                ?.filter((c: any) => c.type === 'text')\n+                .map((c: any) => c.content)\n+                .join(' ')\n+                .trim();\n+\n+              if (text) {\n+                const existingText = textByDateMap.get(dateKey) || '';\n+                textByDateMap.set(dateKey, existingText ? `${existingText} ${text}` : text);\n               }\n-            } catch (err) {\n-              console.error(`Failed to load session ${session.id}:`, err);\n-            }\n-          }\n+            });\n+          });\n \n           setStarredComments(allStarred);\n           setAllCommentsByDate(commentsByDate);\n           setTextByDate(textByDateMap);\n+          setFirstLineByDate(firstLineMap);\n         } catch (error) {\n           console.error('Failed to load comments from database:', error);\n         }\n@@ -622,9 +650,30 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n               commentsByDate.set(today, allComments);\n             }\n             setAllCommentsByDate(commentsByDate);\n+\n+            const guestTextMap = new Map<string, string>();\n+            const guestFirstLineMap = new Map<string, string>();\n+            if (state.cells) {\n+              const dateKey = state.createdAt || getLocalDateString();\n+              const combined = state.cells\n+                .filter((c: any) => c.type === 'text')\n+                .map((c: any) => c.content)\n+                .join(' ')\n+                .trim();\n+\n+              if (combined) {\n+                guestTextMap.set(dateKey, combined);\n+              }\n+              guestFirstLineMap.set(dateKey, extractFirstLine(state));\n+            }\n+            setTextByDate(guestTextMap);\n+            setFirstLineByDate(guestFirstLineMap);\n           } catch (e) {\n             console.error('Failed to load comments:', e);\n           }\n+        } else {\n+          setTextByDate(new Map());\n+          setFirstLineByDate(new Map());\n         }\n       }\n \n@@ -745,12 +794,6 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n     }\n     timelineByDate.get(date)!.picture = pic;\n   });\n-\n-  const friendTimelineByDate = new Map<string, TimelineEntryData>();\n-  friendPictures.forEach(pic => {\n-    friendTimelineByDate.set(pic.date, { picture: pic, comments: [] });\n-  });\n-\n   useEffect(() => {\n     if (!isAuthenticated || !selectedFriendId) {\n       setFriendPictures([]);\n@@ -1034,7 +1077,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n           const isActive = friend.friend_id === selectedFriendId;\n           return (\n             <button\n-              key={friend.id}\n+              key={friend.friend_id}\n               onClick={() => handleFriendSelection(friend.friend_id)}\n               style={{\n                 width: '42px',\n@@ -1106,7 +1149,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n         </div>\n       )}\n \n-      {selectedFriendId && !isFriendPickerOpen && friendPictures.length === 0 && (\n+      {selectedFriendId && !isFriendPickerOpen && !loadingFriendTimeline && !friendHasVisibleCards && (\n         <div style={{\n           position: 'fixed',\n           right: '6.5rem',\n@@ -1237,7 +1280,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n                 const isSelected = friend.friend_id === selectedFriendId;\n                 return (\n                   <button\n-                    key={friend.id}\n+                    key={friend.friend_id}\n                     onClick={() => handleFriendSelection(friend.friend_id)}\n                     style={{\n                       border: isSelected ? '1px solid #2c2c2c' : '1px solid #d0c4b0',\n@@ -1307,6 +1350,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n                   onImageClick: handleImageClick,\n                   onGenerate: handleGenerateForDate,\n                   textByDate,\n+                  firstLineByDate,\n                   t,\n                   dateLocale,\n                   placeholder\n@@ -1355,6 +1399,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n                     isGenerating: false,\n                     onImageClick: handleFriendImageClick,\n                     textByDate: emptyTextMap,\n+                    firstLineByDate: emptyFirstLineMap,\n                     t,\n                     dateLocale,\n                     placeholder,"
    },
    {
      "sha": "4ad528f622dcc4192574cb76d036cd526b86650c",
      "filename": "frontend/src/components/FriendsView.tsx",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/baaa7c48bbe4681ca47b0322800073d29e853e58/frontend%2Fsrc%2Fcomponents%2FFriendsView.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/baaa7c48bbe4681ca47b0322800073d29e853e58/frontend%2Fsrc%2Fcomponents%2FFriendsView.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FFriendsView.tsx?ref=baaa7c48bbe4681ca47b0322800073d29e853e58",
      "patch": "@@ -245,7 +245,9 @@ export default function FriendsView({ isVisible, onViewFriendTimeline }: Props)\n             ) : (\n               <div style={{ display: 'flex', flexDirection: 'column', gap: 16 }}>\n                 {friends.map(friend => (\n-                  <div key={friend.id} style={{\n+                  <div\n+                    key={friend.friend_id ?? friend.id ?? ('friend-' + (friend.friend_email ?? 'unknown'))}\n+                    style={{\n                     background: '#fff',\n                     border: '1px solid #d0c4b0',\n                     borderRadius: 8,\n@@ -342,7 +344,9 @@ export default function FriendsView({ isVisible, onViewFriendTimeline }: Props)\n             ) : (\n               <div style={{ display: 'flex', flexDirection: 'column', gap: 16 }}>\n                 {requests.map(request => (\n-                  <div key={request.id} style={{\n+                  <div\n+                    key={request.id ?? ('request-' + (request.requester_email ?? 'unknown'))}\n+                    style={{\n                     background: '#fff',\n                     border: '1px solid #d0c4b0',\n                     borderRadius: 8,"
    },
    {
      "sha": "1521ec154c3fbbc0a765f7903070da7bfe4afccc",
      "filename": "frontend/src/utils/sessionGrouping.ts",
      "status": "added",
      "additions": 84,
      "deletions": 0,
      "changes": 84,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/baaa7c48bbe4681ca47b0322800073d29e853e58/frontend%2Fsrc%2Futils%2FsessionGrouping.ts",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/baaa7c48bbe4681ca47b0322800073d29e853e58/frontend%2Fsrc%2Futils%2FsessionGrouping.ts",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Futils%2FsessionGrouping.ts?ref=baaa7c48bbe4681ca47b0322800073d29e853e58",
      "patch": "@@ -0,0 +1,84 @@\n+import type { CalendarEntry } from './calendarStorage';\n+import { extractFirstLine, getTodayKey } from './calendarStorage';\n+import type { EditorState } from '../engine/EditorEngine';\n+\n+type ListSessionsFn = () => Promise<any[]>;\n+type GetSessionFn = (id: string) => Promise<any>;\n+\n+function normalizeTimestamp(raw?: string | null): Date | null {\n+  if (!raw) return null;\n+  const normalized = raw.includes('T') ? raw : raw.replace(' ', 'T');\n+  const withZone = /[zZ]$/.test(normalized) ? normalized : `${normalized}Z`;\n+  const parsed = Date.parse(withZone);\n+  if (Number.isNaN(parsed)) {\n+    return null;\n+  }\n+  return new Date(parsed);\n+}\n+\n+export function getSessionDateKey(session: any, state?: EditorState): string {\n+  const name = session?.name;\n+  if (name && /^\\d{4}-\\d{2}-\\d{2}/.test(name)) {\n+    return name.split(' - ')[0];\n+  }\n+\n+  if (state?.createdAt) {\n+    return state.createdAt;\n+  }\n+\n+  const timestamp = normalizeTimestamp(session?.updated_at || session?.created_at);\n+  if (timestamp) {\n+    return timestamp.toISOString().substring(0, 10);\n+  }\n+\n+  return getTodayKey();\n+}\n+\n+function getEntryFirstLine(sessionName: string | undefined, state?: EditorState): string {\n+  if (sessionName && sessionName.trim().length > 0) {\n+    return sessionName.trim();\n+  }\n+  if (state) {\n+    return extractFirstLine(state);\n+  }\n+  return 'Untitled';\n+}\n+\n+export async function loadSessionsGroupedByDate(\n+  listSessions: ListSessionsFn,\n+  getSession: GetSessionFn,\n+  options: { requireName?: boolean } = {}\n+): Promise<Record<string, CalendarEntry[]>> {\n+  const { requireName = false } = options;\n+  const sessions = await listSessions();\n+  const grouped: Record<string, CalendarEntry[]> = {};\n+\n+  for (const session of sessions) {\n+    if (requireName && !session.name) continue;\n+\n+    try {\n+      const fullSession = await getSession(session.id);\n+      if (!fullSession?.editor_state) continue;\n+\n+      const dateKey = getSessionDateKey(session, fullSession.editor_state);\n+      const firstLine = getEntryFirstLine(session.name, fullSession.editor_state);\n+      if (!grouped[dateKey]) {\n+        grouped[dateKey] = [];\n+      }\n+\n+      const timestamp = normalizeTimestamp(session?.created_at || session?.updated_at);\n+      const displayTimestamp = timestamp ? timestamp.getTime() : Date.now();\n+\n+      grouped[dateKey].push({\n+        id: session.id,\n+        timestamp: displayTimestamp,\n+        state: fullSession.editor_state,\n+        firstLine\n+      });\n+    } catch (error) {\n+      console.error(`Failed to load session ${session.id}:`, error);\n+    }\n+  }\n+\n+  return grouped;\n+}"
    }
  ]
}